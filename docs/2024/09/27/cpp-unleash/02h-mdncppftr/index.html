
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <title>C++ Unleashed: Modern C++ Features | Tab&#39;s Blog</title>
    <meta name="author" content="Tab Nahida" />
    <meta name="description" content="" />
    <meta name="keywords" content="" />
    <meta
        name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0"
    />
    <link rel="icon" href="/images/avatar1.png" />
    <link rel="preconnect" href="https://s4.zstatic.net" />
<script src="https://s4.zstatic.net/ajax/libs/vue/3.3.7/vue.global.prod.min.js"></script>
<link rel="stylesheet" href="https://s4.zstatic.net/ajax/libs/font-awesome/6.4.2/css/all.min.css" />
<link rel="preconnect" href="https://fonts.googleapis.cn" />
<link rel="preconnect" href="https://fonts.gstatic.cn" crossorigin />
<link
    rel="stylesheet"
    href="https://fonts.googleapis.cn/css2?family=Fira+Code:wght@400;500;600;700&family=Lexend:wght@400;500;600;700;800;900&family=Noto+Sans+SC:wght@400;500;600;700;800;900&display=swap"
/>
<script> const mixins = {}; </script>

<script src="https://polyfill.alicdn.com/v3/polyfill.min.js?features=default"></script>


<script src="https://s4.zstatic.net/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://s4.zstatic.net/ajax/libs/highlightjs-line-numbers.js/2.8.0/highlightjs-line-numbers.min.js"></script>
<link
    rel="stylesheet"
    href="https://s4.zstatic.net/ajax/libs/highlight.js/11.9.0/styles/github.min.css"
/>
<script src="/js/lib/highlight.js"></script>



<script src="/js/lib/preview.js"></script>









<link rel="stylesheet" href="/css/main.css" />

<meta name="generator" content="Hexo 7.3.0"></head>
<body>
    <div id="layout">
        <transition name="fade">
            <div id="loading" v-show="loading">
                <div id="loading-circle">
                    <h2>LOADING</h2>
                    <p>加载过慢请开启缓存 浏览器默认开启</p>
                    <img src="/images/loading.gif" />
                </div>
            </div>
        </transition>
        <div id="menu" :class="{ hidden: hiddenMenu, 'menu-color': menuColor}">
    <nav id="desktop-menu">
        <a class="title" href="/">
            <span>TAB&#39;S BLOG</span>
        </a>
        
        <a href="/">
            <i class="fa-solid fa-house fa-fw"></i>
            <span>&ensp;Home</span>
        </a>
        
        <a href="/about">
            <i class="fa-solid fa-id-card fa-fw"></i>
            <span>&ensp;About</span>
        </a>
        
        <a href="/archives">
            <i class="fa-solid fa-box-archive fa-fw"></i>
            <span>&ensp;Archives</span>
        </a>
        
        <a href="/categories">
            <i class="fa-solid fa-bookmark fa-fw"></i>
            <span>&ensp;Categories</span>
        </a>
        
        <a href="/tags">
            <i class="fa-solid fa-tags fa-fw"></i>
            <span>&ensp;Tags</span>
        </a>
        
    </nav>
    <nav id="mobile-menu">
        <div class="title" @click="showMenuItems = !showMenuItems">
            <i class="fa-solid fa-bars fa-fw"></i>
            <span>&emsp;TAB&#39;S BLOG</span>
        </div>
        <transition name="slide">
            <div class="items" v-show="showMenuItems">
                
                <a href="/">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-house fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Home</div>
                    </div>
                </a>
                
                <a href="/about">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-id-card fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">About</div>
                    </div>
                </a>
                
                <a href="/archives">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-box-archive fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Archives</div>
                    </div>
                </a>
                
                <a href="/categories">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-bookmark fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Categories</div>
                    </div>
                </a>
                
                <a href="/tags">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-tags fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Tags</div>
                    </div>
                </a>
                
            </div>
        </transition>
    </nav>
</div>
<transition name="fade">
    <div id="menu-curtain" @click="showMenuItems = !showMenuItems" v-show="showMenuItems"></div>
</transition>

        <div id="main" :class="loading ? 'into-enter-from': 'into-enter-active'">
            <div class="article">
    <div>
        <h1>C++ Unleashed: Modern C++ Features</h1>
    </div>
    <div class="info">
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2024/9/27
        </span>
        
        <span class="category">
            <a href="/categories/tutor/">
                <span class="icon">
                    <i class="fa-solid fa-bookmark fa-fw"></i>
                </span>
                Tutorial
            </a>
        </span>
        
        
        <span class="tags">
            <span class="icon">
                <i class="fa-solid fa-tags fa-fw"></i>
            </span>
            
            
            <span class="tag">
                
                <a href="/tags/c-cpp/" style="color: #00bcd4">
                    C/C++
                </a>
            </span>
            
            <span class="tag">
                
                <a href="/tags/modern-cpp/" style="color: #ffa2c4">
                    Modern C++
                </a>
            </span>
            
            <span class="tag">
                
                <a href="/tags/cpp-unleash/" style="color: #00a596">
                    C++ Unleashed
                </a>
            </span>
            
            <span class="tag">
                
                <a href="/tags/Zero-to-Hero/" style="color: #00bcd4">
                    Zero to Hero
                </a>
            </span>
            
        </span>
        
    </div>
    
    <div class="content" v-pre>
        <p><em><strong>C++ Unleashed: From Zero to Hero</strong></em></p>
<p>Previous chapter: <a href="/2024/09/27/cpp-unleash/02h-tplgenpgm">Templates and Generic Programming</a></p>
<p><a href="/2024/09/26/cpp-unleash/02h-menu">Go to Table of Contents</a></p>
<h1 id="Chapter-9-Modern-C-Features"><a href="#Chapter-9-Modern-C-Features" class="headerlink" title="Chapter 9: Modern C++ Features"></a>Chapter 9: Modern C++ Features</h1><p>Modern C++ (C++11 and later) introduced a range of features that enhance the language’s expressiveness, performance, and safety. This chapter covers some of the most important features that you should know to write effective and modern C++ code today.</p>
<h2 id="Table-of-Contents"><a href="#Table-of-Contents" class="headerlink" title="Table of Contents"></a>Table of Contents</h2><ol>
<li><a href="#type-inference-with-auto">Type Inference with <code>auto</code></a></li>
<li><a href="#range-based-for-loops">Range-Based For Loops</a></li>
<li><a href="#type-aliases-using">Type Aliases (<code>using</code>)</a></li>
<li><a href="#constexpr-consteval-and-constinit"><code>constexpr</code>, <code>consteval</code>, and <code>constinit</code></a><ul>
<li><a href="#understanding-constexpr">Understanding <code>constexpr</code></a></li>
<li><a href="#introducing-consteval">Introducing <code>consteval</code></a></li>
<li><a href="#exploring-constinit">Exploring <code>constinit</code></a></li>
</ul>
</li>
<li><a href="#decltype"><code>decltype</code></a></li>
<li><a href="#stdvariant-and-stdoptional"><code>std::variant</code> and <code>std::optional</code></a></li>
<li><a href="#nullptr"><code>nullptr</code></a></li>
</ol>
<hr>
<h2 id="Type-Inference-with-auto"><a href="#Type-Inference-with-auto" class="headerlink" title="Type Inference with auto"></a>Type Inference with <code>auto</code></h2><h3 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h3><p>The <code>auto</code> keyword allows the compiler to automatically deduce the type of a variable at compile time. This feature simplifies code and improves readability, especially when dealing with complex types.</p>
<h3 id="Usage"><a href="#Usage" class="headerlink" title="Usage"></a>Usage</h3><p><strong>Basic Example:</strong></p>
<pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;

int main() &#123;
    auto x = 42; // x is int
    auto y = 3.14; // y is double
    auto str = &quot;Hello, World!&quot;; // str is const char*

    std::vector&lt;int&gt; vec = &#123;1, 2, 3, 4, 5&#125;;
    auto it = vec.begin(); // it is std::vector&lt;int&gt;::iterator

    std::cout &lt;&lt; &quot;x: &quot; &lt;&lt; x &lt;&lt; &quot;, y: &quot; &lt;&lt; y &lt;&lt; &quot;, str: &quot; &lt;&lt; str &lt;&lt; std::endl;

    return 0;
&#125;
</code></pre>
<p><strong>Output:</strong></p>
<pre><code>x: 42, y: 3.14, str: Hello, World!
</code></pre>
<h3 id="Best-Practices"><a href="#Best-Practices" class="headerlink" title="Best Practices"></a>Best Practices</h3><ul>
<li><p><strong>Use <code>auto</code> When Type is Obvious:</strong></p>
<pre><code class="cpp">auto count = 10; // Clearly an int
</code></pre>
</li>
<li><p><strong>Avoid Obscuring Types:</strong></p>
<pre><code class="cpp">auto result = someFunction(); // If the return type of someFunction is unclear
</code></pre>
</li>
<li><p><strong>Combine with <code>decltype</code> for Complex Deductions:</strong></p>
<pre><code class="cpp">decltype(auto) ref = someFunctionReturningReference();
</code></pre>
</li>
<li><p><strong>Prefer Explicit Types for Function Return Types and Parameters:</strong></p>
<pre><code class="cpp">int add(int a, int b); // Clear return type
</code></pre>
</li>
</ul>
<hr>
<h2 id="Range-Based-For-Loops"><a href="#Range-Based-For-Loops" class="headerlink" title="Range-Based For Loops"></a>Range-Based For Loops</h2><h3 id="Introduction-1"><a href="#Introduction-1" class="headerlink" title="Introduction"></a>Introduction</h3><p>Range-based for loops provide a more readable and concise way to iterate through containers, eliminating the need for explicit iterators or index-based loops. Introduced in C++11, they enhance code clarity and reduce the likelihood of errors associated with traditional loop constructs.</p>
<h3 id="Syntax"><a href="#Syntax" class="headerlink" title="Syntax"></a>Syntax</h3><pre><code class="cpp">for (auto&amp; element : container) &#123;
    // Use element
&#125;
</code></pre>
<h3 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h3><pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;

int main() &#123;
    std::vector&lt;int&gt; numbers = &#123;1, 2, 3, 4, 5&#125;;

    for (const auto&amp; num : numbers) &#123;
        std::cout &lt;&lt; num &lt;&lt; &quot; &quot;; // Outputs: 1 2 3 4 5
    &#125;
    std::cout &lt;&lt; std::endl;

    return 0;
&#125;
</code></pre>
<p><strong>Output:</strong></p>
<pre><code>1 2 3 4 5
</code></pre>
<h3 id="Best-Practices-1"><a href="#Best-Practices-1" class="headerlink" title="Best Practices"></a>Best Practices</h3><ul>
<li><p><strong>Use <code>const auto&amp;</code> When Not Modifying Elements:</strong></p>
<pre><code class="cpp">for (const auto&amp; num : numbers) &#123;
    // Read-only access
&#125;
</code></pre>
</li>
<li><p><strong>Use <code>auto&amp;</code> When Modifying Elements:</strong></p>
<pre><code class="cpp">for (auto&amp; num : numbers) &#123;
    num *= 2; // Modify elements
&#125;
</code></pre>
</li>
<li><p><strong>Avoid Unnecessary Copies:</strong></p>
<pre><code class="cpp">for (const auto&amp; str : stringList) &#123; /* ... */ &#125; // Avoid copying strings
</code></pre>
</li>
<li><p><strong>Use <code>auto&amp;&amp;</code> for Perfect Forwarding:</strong></p>
<pre><code class="cpp">for (auto&amp;&amp; element : container) &#123; /* ... */ &#125;
</code></pre>
</li>
</ul>
<hr>
<h2 id="Type-Aliases-using"><a href="#Type-Aliases-using" class="headerlink" title="Type Aliases (using)"></a>Type Aliases (<code>using</code>)</h2><h3 id="Introduction-2"><a href="#Introduction-2" class="headerlink" title="Introduction"></a>Introduction</h3><p>Type aliases allow you to create alternative names for existing types, enhancing code readability and maintainability. The <code>using</code> keyword is preferred over <code>typedef</code> in modern C++ due to its clearer syntax and enhanced capabilities, especially with templates.</p>
<h3 id="Syntax-1"><a href="#Syntax-1" class="headerlink" title="Syntax"></a>Syntax</h3><pre><code class="cpp">using AliasName = ExistingType;
</code></pre>
<h3 id="Example-1"><a href="#Example-1" class="headerlink" title="Example"></a>Example</h3><pre><code class="cpp">#include &lt;vector&gt;
#include &lt;string&gt;

using StringList = std::vector&lt;std::string&gt;;

int main() &#123;
    StringList names = &#123;&quot;Alice&quot;, &quot;Bob&quot;, &quot;Charlie&quot;&#125;;
    return 0;
&#125;
</code></pre>
<h3 id="Best-Practices-2"><a href="#Best-Practices-2" class="headerlink" title="Best Practices"></a>Best Practices</h3><ul>
<li><p><strong>Simplify Complex Type Declarations:</strong></p>
<pre><code class="cpp">using IntPair = std::pair&lt;int, int&gt;;
</code></pre>
</li>
<li><p><strong>Enhance Code Readability:</strong></p>
<pre><code class="cpp">using Byte = unsigned char;
</code></pre>
</li>
<li><p><strong>Use Descriptive Alias Names:</strong></p>
<pre><code class="cpp">using Matrix = std::vector&lt;std::vector&lt;double&gt;&gt;;
</code></pre>
</li>
<li><p><strong>Leverage with Templates:</strong></p>
<pre><code class="cpp">template &lt;typename T&gt;
using Vec = std::vector&lt;T&gt;;

Vec&lt;int&gt; intVec;
</code></pre>
</li>
</ul>
<hr>
<h2 id="constexpr-consteval-and-constinit"><a href="#constexpr-consteval-and-constinit" class="headerlink" title="constexpr, consteval, and constinit"></a><code>constexpr</code>, <code>consteval</code>, and <code>constinit</code></h2><p>Modern C++ introduces several keywords that enhance compile-time programming, enabling more efficient and safer code. Understanding the distinctions and appropriate usage of <code>constexpr</code>, <code>consteval</code>, and <code>constinit</code> is crucial for leveraging these features effectively.</p>
<h3 id="Understanding-constexpr"><a href="#Understanding-constexpr" class="headerlink" title="Understanding constexpr"></a>Understanding <code>constexpr</code></h3><p><strong><code>constexpr</code></strong> specifies that the value of a variable or the return value of a function can be evaluated at compile time. It allows for optimizations and ensures that certain computations are performed during compilation rather than at runtime.</p>
<p><strong>Usage:</strong></p>
<pre><code class="cpp">#include &lt;iostream&gt;

constexpr int square(int x) &#123;
    return x * x;
&#125;

int main() &#123;
    constexpr int result = square(5); // Computed at compile time
    int runtime_result = square(6);   // Also allowed, computed at runtime
    std::cout &lt;&lt; &quot;Square of 5 is: &quot; &lt;&lt; result &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;Square of 6 is: &quot; &lt;&lt; runtime_result &lt;&lt; std::endl;
    return 0;
&#125;
</code></pre>
<p><strong>Output:</strong></p>
<pre><code>Square of 5 is: 25
Square of 6 is: 36
</code></pre>
<p><strong>Key Points:</strong></p>
<ul>
<li><strong>Functions and Variables:</strong> Both can be declared <code>constexpr</code>.</li>
<li><strong>Compile-Time Evaluation:</strong> When used in a context that requires a compile-time constant, the evaluation must occur at compile time.</li>
<li><strong>Flexibility:</strong> <code>constexpr</code> functions can be used in both compile-time and runtime contexts.</li>
</ul>
<h3 id="Introducing-consteval"><a href="#Introducing-consteval" class="headerlink" title="Introducing consteval"></a>Introducing <code>consteval</code></h3><p><strong><code>consteval</code></strong> is a keyword introduced in C++20 that declares an <strong>immediate function</strong>. These functions are guaranteed to produce a compile-time constant and must be evaluated at compile time. Unlike <code>constexpr</code>, which allows both compile-time and runtime evaluations, <code>consteval</code> enforces compile-time evaluation.</p>
<p><strong>Usage:</strong></p>
<pre><code class="cpp">#include &lt;iostream&gt;

consteval int square(int x) &#123;
    return x * x;
&#125;

int main() &#123;
    constexpr int sq = square(5); // Valid
    // int runtime_sq = square(5); // Error: requires compile-time evaluation
    std::cout &lt;&lt; &quot;Square of 5 is: &quot; &lt;&lt; sq &lt;&lt; std::endl;
    return 0;
&#125;
</code></pre>
<p><strong>Output:</strong></p>
<pre><code>Square of 5 is: 25
</code></pre>
<p><strong>Key Points:</strong></p>
<ul>
<li><strong>Immediate Evaluation:</strong> Must be evaluated at compile time.</li>
<li><strong>Type Safety:</strong> Ensures that functions producing constants are not mistakenly used in runtime contexts.</li>
<li><strong>Use Cases:</strong> Ideal for functions that must generate constant expressions, enhancing both performance and reliability.</li>
</ul>
<h3 id="Exploring-constinit"><a href="#Exploring-constinit" class="headerlink" title="Exploring constinit"></a>Exploring <code>constinit</code></h3><p><strong><code>constinit</code></strong> is another keyword introduced in C++20 that ensures a variable is <strong>constantly initialized</strong> at compile time without making it immutable. Unlike <code>constexpr</code>, which makes a variable a compile-time constant, <code>constinit</code> only guarantees that the variable is initialized at compile time, allowing it to remain mutable during runtime.</p>
<p><strong>Usage:</strong></p>
<pre><code class="cpp">#include &lt;iostream&gt;

constinit int global_counter = 0;

int main() &#123;
    global_counter += 5; // Allowed, since constinit doesn&#39;t make it immutable
    std::cout &lt;&lt; &quot;Global Counter: &quot; &lt;&lt; global_counter &lt;&lt; std::endl;
    return 0;
&#125;
</code></pre>
<p><strong>Output:</strong></p>
<pre><code>Global Counter: 5
</code></pre>
<p><strong>Key Points:</strong></p>
<ul>
<li><strong>Static Initialization:</strong> Ensures that variables are initialized before any dynamic initialization occurs, preventing the <strong>static initialization order fiasco</strong>.</li>
<li><strong>Mutable Variables:</strong> Unlike <code>constexpr</code>, variables declared with <code>constinit</code> can be modified after initialization.</li>
<li><strong>Thread Safety:</strong> Guarantees that variables are initialized in a thread-safe manner at compile time.</li>
<li><strong>Use Cases:</strong> Ideal for global and static variables that require early initialization but need to remain mutable during runtime.</li>
</ul>
<h3 id="Best-Practices-3"><a href="#Best-Practices-3" class="headerlink" title="Best Practices"></a>Best Practices</h3><ul>
<li><p><strong>Use <code>constexpr</code>:</strong> When you want flexibility for compile-time and runtime evaluations. Ideal for functions and variables that can benefit from both contexts.</p>
</li>
<li><p><strong>Use <code>consteval</code>:</strong> When you need to guarantee that a function is evaluated at compile time, ensuring compile-time constants and preventing runtime evaluations.</p>
</li>
<li><p><strong>Use <code>constinit</code>:</strong> For variables that must be initialized at compile time but need to remain mutable. Essential for global and static variables to ensure proper initialization order.</p>
</li>
</ul>
<hr>
<h2 id="decltype"><a href="#decltype" class="headerlink" title="decltype"></a><code>decltype</code></h2><h3 id="Introduction-3"><a href="#Introduction-3" class="headerlink" title="Introduction"></a>Introduction</h3><p>The <code>decltype</code> keyword in C++ deduces the type of an expression at compile time. It is particularly useful in templates and when the type of an expression is complex or not easily determined. <code>decltype</code> enhances type safety and flexibility, allowing for more generic and adaptable code.</p>
<h3 id="Usage-1"><a href="#Usage-1" class="headerlink" title="Usage"></a>Usage</h3><p><strong>Basic Example:</strong></p>
<pre><code class="cpp">#include &lt;iostream&gt;

int main() &#123;
    int x = 5;
    decltype(x) y = 10; // y is of type int
    std::cout &lt;&lt; &quot;y: &quot; &lt;&lt; y &lt;&lt; std::endl;
    return 0;
&#125;
</code></pre>
<p><strong>Output:</strong></p>
<pre><code>y: 10
</code></pre>
<p><strong>With Complex Expressions:</strong></p>
<pre><code class="cpp">#include &lt;vector&gt;
#include &lt;iostream&gt;

int main() &#123;
    std::vector&lt;int&gt; vec = &#123;1, 2, 3, 4, 5&#125;;
    decltype(vec.begin()) it = vec.begin(); // it is std::vector&lt;int&gt;::iterator

    std::cout &lt;&lt; &quot;First element: &quot; &lt;&lt; *it &lt;&lt; std::endl;
    return 0;
&#125;
</code></pre>
<p><strong>Output:</strong></p>
<pre><code>First element: 1
</code></pre>
<h3 id="Best-Practices-4"><a href="#Best-Practices-4" class="headerlink" title="Best Practices"></a>Best Practices</h3><ul>
<li><p><strong>Use in Templates:</strong> Facilitate generic programming by deducing return types or variable types based on template parameters.</p>
</li>
<li><p><strong>Combine with <code>auto</code>:</strong> Create concise type declarations without sacrificing clarity.</p>
<pre><code class="cpp">auto x = someFunction();
decltype(x) y = anotherFunction();
</code></pre>
</li>
<li><p><strong>Avoid Overuse:</strong> While powerful, excessive use of <code>decltype</code> can make code harder to read. Use it judiciously to maintain clarity.</p>
</li>
</ul>
<hr>
<h2 id="std-variant-and-std-optional"><a href="#std-variant-and-std-optional" class="headerlink" title="std::variant and std::optional"></a><code>std::variant</code> and <code>std::optional</code></h2><h3 id="Introduction-4"><a href="#Introduction-4" class="headerlink" title="Introduction"></a>Introduction</h3><p>C++17 introduced <code>std::variant</code> and <code>std::optional</code> to handle situations where a value might belong to multiple types or might be absent, respectively. These utilities enhance type safety and expressiveness in your code, reducing the reliance on traditional approaches like unions or sentinel values.</p>
<h3 id="std-variant"><a href="#std-variant" class="headerlink" title="std::variant"></a><code>std::variant</code></h3><p><strong>Description:</strong></p>
<p><code>std::variant</code> is a type-safe union that can hold one value from a specified set of types. It provides a way to store and manage multiple types in a single variable, ensuring that only one type is active at any given time.</p>
<p><strong>Usage:</strong></p>
<pre><code class="cpp">#include &lt;variant&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;

int main() &#123;
    std::variant&lt;int, std::string&gt; data;
    
    data = 10;
    std::cout &lt;&lt; std::get&lt;int&gt;(data) &lt;&lt; std::endl; // Outputs: 10
    
    data = &quot;Hello, Variant!&quot;;
    std::cout &lt;&lt; std::get&lt;std::string&gt;(data) &lt;&lt; std::endl; // Outputs: Hello, Variant!
    
    return 0;
&#125;
</code></pre>
<p><strong>Handling Multiple Types with <code>std::visit</code>:</strong></p>
<pre><code class="cpp">#include &lt;variant&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;

struct Visitor &#123;
    void operator()(int i) const &#123; std::cout &lt;&lt; &quot;int: &quot; &lt;&lt; i &lt;&lt; std::endl; &#125;
    void operator()(const std::string&amp; str) const &#123; std::cout &lt;&lt; &quot;string: &quot; &lt;&lt; str &lt;&lt; std::endl; &#125;
&#125;;

int main() &#123;
    std::variant&lt;int, std::string&gt; data = &quot;Hello&quot;;
    std::visit(Visitor&#123;&#125;, data); // Outputs: string: Hello
    
    data = 42;
    std::visit(Visitor&#123;&#125;, data); // Outputs: int: 42
    
    return 0;
&#125;
</code></pre>
<p><strong>Output:</strong></p>
<pre><code>string: Hello
int: 42
</code></pre>
<h3 id="Best-Practices-5"><a href="#Best-Practices-5" class="headerlink" title="Best Practices"></a>Best Practices</h3><ul>
<li><p><strong>Use <code>std::variant</code> for Heterogeneous Data:</strong> When a variable needs to hold one of several types, <code>std::variant</code> provides a type-safe alternative to unions.</p>
</li>
<li><p><strong>Handle All Possible Types:</strong> Use <code>std::visit</code> to ensure that all possible types are handled, enhancing type safety.</p>
</li>
<li><p><strong>Avoid Excessive Nesting:</strong> Deeply nested <code>std::variant</code> instances can complicate code. Consider refactoring if necessary.</p>
</li>
<li><p><strong>Leverage with <code>std::monostate</code>:</strong> Use <code>std::monostate</code> as the first type in a <code>std::variant</code> to represent an empty state.</p>
</li>
</ul>
<h3 id="std-optional"><a href="#std-optional" class="headerlink" title="std::optional"></a><code>std::optional</code></h3><p><strong>Description:</strong></p>
<p><code>std::optional</code> represents an object that may or may not contain a value, eliminating the need for sentinel values like <code>nullptr</code> or special error codes. It enhances code clarity by explicitly indicating the presence or absence of a value.</p>
<p><strong>Usage:</strong></p>
<pre><code class="cpp">#include &lt;optional&gt;
#include &lt;iostream&gt;

std::optional&lt;int&gt; findValue(bool shouldFind) &#123;
    if (shouldFind) &#123;
        return 42; // Optional value is present
    &#125;
    return std::nullopt; // No value present
&#125;

int main() &#123;
    auto value = findValue(true);
    if (value) &#123;
        std::cout &lt;&lt; &quot;Found value: &quot; &lt;&lt; *value &lt;&lt; std::endl; // Dereference
    &#125; else &#123;
        std::cout &lt;&lt; &quot;No value found.&quot; &lt;&lt; std::endl;
    &#125;

    return 0;
&#125;
</code></pre>
<p><strong>Output:</strong></p>
<pre><code>Found value: 42
</code></pre>
<p><strong>Simplified Access with <code>operator*</code> and <code>operator-&gt;</code>:</strong></p>
<pre><code class="cpp">#include &lt;optional&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;

std::optional&lt;std::string&gt; getName(bool valid) &#123;
    if (valid)
        return &quot;Alice&quot;;
    else
        return std::nullopt;
&#125;

int main() &#123;
    auto nameOpt = getName(true);
    if (nameOpt) &#123;
        std::cout &lt;&lt; &quot;Name: &quot; &lt;&lt; *nameOpt &lt;&lt; std::endl; // Outputs: Name: Alice
    &#125;

    return 0;
&#125;
</code></pre>
<p><strong>Output:</strong></p>
<pre><code>Name: Alice
</code></pre>
<h3 id="Best-Practices-6"><a href="#Best-Practices-6" class="headerlink" title="Best Practices"></a>Best Practices</h3><ul>
<li><p><strong>Use <code>std::optional</code> for Optional Return Values:</strong> Functions that might not always return a meaningful value can return <code>std::optional</code> instead of using sentinel values.</p>
</li>
<li><p><strong>Avoid Using <code>std::optional</code> for Class Members:</strong> Prefer other design patterns, such as the Null Object pattern, to handle optional class members.</p>
</li>
<li><p><strong>Prefer Checking <code>has_value()</code> or Using <code>if (opt)</code>:</strong> Ensure that the presence of a value is checked before accessing it to prevent exceptions.</p>
</li>
<li><p><strong>Leverage <code>value_or</code> for Default Values:</strong> Provide a fallback value when the optional is empty.</p>
<pre><code class="cpp">int value = opt.value_or(0);
</code></pre>
</li>
</ul>
<hr>
<h2 id="nullptr"><a href="#nullptr" class="headerlink" title="nullptr"></a><code>nullptr</code></h2><h3 id="Introduction-5"><a href="#Introduction-5" class="headerlink" title="Introduction"></a>Introduction</h3><p>Introduced in C++11, <code>nullptr</code> is a type-safe pointer literal representing a null pointer. It replaces the traditional <code>NULL</code> macro and integer literal <code>0</code>, providing better type safety and clarity in your code.</p>
<h3 id="Usage-2"><a href="#Usage-2" class="headerlink" title="Usage"></a>Usage</h3><p><strong>Basic Example:</strong></p>
<pre><code class="cpp">#include &lt;iostream&gt;

void func(int* ptr) &#123;
    if (ptr == nullptr) &#123;
        std::cout &lt;&lt; &quot;Pointer is null.&quot; &lt;&lt; std::endl;
    &#125;
&#125;

int main() &#123;
    int* p = nullptr; // Safe null pointer
    func(p);

    return 0;
&#125;
</code></pre>
<p><strong>Output:</strong></p>
<pre><code>Pointer is null.
</code></pre>
<p><strong>Function Overloading Ambiguity Resolution:</strong></p>
<pre><code class="cpp">#include &lt;iostream&gt;

void func(int) &#123;
    std::cout &lt;&lt; &quot;Function with int parameter.&quot; &lt;&lt; std::endl;
&#125;

void func(char*) &#123;
    std::cout &lt;&lt; &quot;Function with char* parameter.&quot; &lt;&lt; std::endl;
&#125;

int main() &#123;
    func(nullptr); // Calls func(char*) due to type safety
    return 0;
&#125;
</code></pre>
<p><strong>Output:</strong></p>
<pre><code>Function with char* parameter.
</code></pre>
<h3 id="Advantages-Over-NULL-and-0"><a href="#Advantages-Over-NULL-and-0" class="headerlink" title="Advantages Over NULL and 0"></a>Advantages Over <code>NULL</code> and <code>0</code></h3><ul>
<li><p><strong>Type Safety:</strong> <code>nullptr</code> has its own type (<code>std::nullptr_t</code>), preventing unintended conversions and function overloading ambiguities.</p>
</li>
<li><p><strong>Clarity:</strong> Clearly indicates that the pointer is intended to be null, improving code readability.</p>
</li>
<li><p><strong>Avoids Ambiguity:</strong> Eliminates confusion between integer <code>0</code> and null pointers in function overloading scenarios.</p>
</li>
</ul>
<h3 id="Best-Practices-7"><a href="#Best-Practices-7" class="headerlink" title="Best Practices"></a>Best Practices</h3><ul>
<li><p><strong>Use <code>nullptr</code> Instead of <code>NULL</code> or <code>0</code>:</strong></p>
<pre><code class="cpp">int* ptr = nullptr;
</code></pre>
</li>
<li><p><strong>Consistently Use <code>nullptr</code> Across Codebase:</strong> Ensure uniformity to leverage its type safety benefits fully.</p>
</li>
<li><p><strong>Avoid Mixing <code>nullptr</code> with Other Null Representations:</strong> Stick to <code>nullptr</code> to maintain consistency and clarity.</p>
</li>
</ul>
<hr>
<h1 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h1><p>In this chapter, you learned about important features introduced in modern C++:</p>
<ul>
<li><strong>Type Inference with <code>auto</code>:</strong> Automatically deducing variable types.</li>
<li><strong>Range-Based For Loops:</strong> Simplifying iterations over containers.</li>
<li><strong>Type Aliases (<code>using</code>):</strong> Creating alternative names for existing types.</li>
<li><strong><code>constexpr</code>, <code>consteval</code>, and <code>constinit</code>:</strong> Enhancing compile-time computations and initialization.</li>
<li><strong><code>decltype</code>:</strong> Deducing the type of expressions at compile time.</li>
<li><strong><code>std::variant</code> and <code>std::optional</code>:</strong> Handling multiple types and optional values safely.</li>
<li><strong><code>nullptr</code>:</strong> A type-safe null pointer constant.</li>
</ul>
<p>These features make modern C++ more powerful, expressive, and safer, helping you write better code with less risk of errors. In the next chapter, we will delve into the <strong>Standard Template Library (STL)</strong>, exploring its containers, algorithms, and iterators.</p>
<p>Next chapter: <a href="/2024/09/27/cpp-unleash/02h-stl">Standard Template Library (STL)</a></p>

    </div>
    
    
    
    
    <div id="comment">
        <div id="giscus-container" class="giscus"></div>
    </div>
    
    
    
    
</div>

            <footer id="footer">
    <div id="footer-wrap">
        <div>
            &copy;
            2024 - 2024 Tab&#39;s Blog
            <span id="footer-icon">
                <i class="fa-solid fa-font-awesome fa-fw"></i>
            </span>
            &commat;Tab Nahida
        </div>
        <div>
            Based on the <a target="_blank" rel="noopener" href="https://hexo.io">Hexo Engine</a> &amp;
            <a target="_blank" rel="noopener" href="https://github.com/theme-particlex/hexo-theme-particlex">ParticleX Theme</a>
        </div>
        
    </div>
</footer>

        </div>
        
        <transition name="fade">
            <div id="preview" ref="preview" v-show="previewShow">
                <img id="preview-content" ref="previewContent" />
            </div>
        </transition>
        
    </div>
    <script src="/js/main.js"></script>
    
    
<script
    src="https://giscus.app/client.js"
    data-repo="TabNahida/TabNahida.github.io"
    data-repo-id="R_kgDOJtk4Ag"
    data-category="General"
    data-category-id="DIC_kwDOJtk4As4Ci3B7"
    data-mapping="pathname"
    data-strict="0"
    data-reactions-enabled="1"
    data-emit-metadata="0"
    data-input-position="bottom"
    data-theme="light_protanopia"
    data-lang="en"
    crossorigin
    async
></script>





    
</body>
</html>
