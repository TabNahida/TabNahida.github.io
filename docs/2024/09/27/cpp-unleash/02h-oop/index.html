
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <title>C++ Unleashed: Object-Oriented Programming | Tab&#39;s Blog</title>
    <meta name="author" content="Tab Nahida" />
    <meta name="description" content="" />
    <meta name="keywords" content="" />
    <meta
        name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0"
    />
    <link rel="icon" href="/images/avatar1.png" />
    <link rel="preconnect" href="https://s4.zstatic.net" />
<script src="https://s4.zstatic.net/ajax/libs/vue/3.3.7/vue.global.prod.min.js"></script>
<link rel="stylesheet" href="https://s4.zstatic.net/ajax/libs/font-awesome/6.4.2/css/all.min.css" />
<link rel="preconnect" href="https://fonts.googleapis.cn" />
<link rel="preconnect" href="https://fonts.gstatic.cn" crossorigin />
<link
    rel="stylesheet"
    href="https://fonts.googleapis.cn/css2?family=Fira+Code:wght@400;500;600;700&family=Lexend:wght@400;500;600;700;800;900&family=Noto+Sans+SC:wght@400;500;600;700;800;900&display=swap"
/>
<script> const mixins = {}; </script>

<script src="https://polyfill.alicdn.com/v3/polyfill.min.js?features=default"></script>


<script src="https://s4.zstatic.net/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://s4.zstatic.net/ajax/libs/highlightjs-line-numbers.js/2.8.0/highlightjs-line-numbers.min.js"></script>
<link
    rel="stylesheet"
    href="https://s4.zstatic.net/ajax/libs/highlight.js/11.9.0/styles/github.min.css"
/>
<script src="/js/lib/highlight.js"></script>



<script src="/js/lib/preview.js"></script>









<link rel="stylesheet" href="/css/main.css" />

<meta name="generator" content="Hexo 7.3.0"></head>
<body>
    <div id="layout">
        <transition name="fade">
            <div id="loading" v-show="loading">
                <div id="loading-circle">
                    <h2>LOADING</h2>
                    <p>加载过慢请开启缓存 浏览器默认开启</p>
                    <img src="/images/loading.gif" />
                </div>
            </div>
        </transition>
        <div id="menu" :class="{ hidden: hiddenMenu, 'menu-color': menuColor}">
    <nav id="desktop-menu">
        <a class="title" href="/">
            <span>TAB&#39;S BLOG</span>
        </a>
        
        <a href="/">
            <i class="fa-solid fa-house fa-fw"></i>
            <span>&ensp;Home</span>
        </a>
        
        <a href="/about">
            <i class="fa-solid fa-id-card fa-fw"></i>
            <span>&ensp;About</span>
        </a>
        
        <a href="/archives">
            <i class="fa-solid fa-box-archive fa-fw"></i>
            <span>&ensp;Archives</span>
        </a>
        
        <a href="/categories">
            <i class="fa-solid fa-bookmark fa-fw"></i>
            <span>&ensp;Categories</span>
        </a>
        
        <a href="/tags">
            <i class="fa-solid fa-tags fa-fw"></i>
            <span>&ensp;Tags</span>
        </a>
        
    </nav>
    <nav id="mobile-menu">
        <div class="title" @click="showMenuItems = !showMenuItems">
            <i class="fa-solid fa-bars fa-fw"></i>
            <span>&emsp;TAB&#39;S BLOG</span>
        </div>
        <transition name="slide">
            <div class="items" v-show="showMenuItems">
                
                <a href="/">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-house fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Home</div>
                    </div>
                </a>
                
                <a href="/about">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-id-card fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">About</div>
                    </div>
                </a>
                
                <a href="/archives">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-box-archive fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Archives</div>
                    </div>
                </a>
                
                <a href="/categories">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-bookmark fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Categories</div>
                    </div>
                </a>
                
                <a href="/tags">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-tags fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Tags</div>
                    </div>
                </a>
                
            </div>
        </transition>
    </nav>
</div>
<transition name="fade">
    <div id="menu-curtain" @click="showMenuItems = !showMenuItems" v-show="showMenuItems"></div>
</transition>

        <div id="main" :class="loading ? 'into-enter-from': 'into-enter-active'">
            <div class="article">
    <div>
        <h1>C++ Unleashed: Object-Oriented Programming</h1>
    </div>
    <div class="info">
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2024/9/27
        </span>
        
        <span class="category">
            <a href="/categories/tutor/">
                <span class="icon">
                    <i class="fa-solid fa-bookmark fa-fw"></i>
                </span>
                Tutorial
            </a>
        </span>
        
        
        <span class="tags">
            <span class="icon">
                <i class="fa-solid fa-tags fa-fw"></i>
            </span>
            
            
            <span class="tag">
                
                <a href="/tags/c-cpp/" style="color: #00bcd4">
                    C/C++
                </a>
            </span>
            
            <span class="tag">
                
                <a href="/tags/modern-cpp/" style="color: #00a596">
                    Modern C++
                </a>
            </span>
            
            <span class="tag">
                
                <a href="/tags/cpp-unleash/" style="color: #ffa2c4">
                    C++ Unleashed
                </a>
            </span>
            
            <span class="tag">
                
                <a href="/tags/Zero-to-Hero/" style="color: #ff7d73">
                    Zero to Hero
                </a>
            </span>
            
        </span>
        
    </div>
    
    <div class="content" v-pre>
        <p><em><strong>C++ Unleashed: From Zero to Hero</strong></em></p>
<p>Previous chapter: <a href="/2024/09/26/cpp-unleash/02h-arystr">Pointers and References</a></p>
<p><a href="/2024/09/26/cpp-unleash/02h-menu">Go to Table of Contents</a></p>
<h1 id="Object-Oriented-Programming"><a href="#Object-Oriented-Programming" class="headerlink" title="Object-Oriented Programming"></a>Object-Oriented Programming</h1><p><strong>Object-Oriented Programming (OOP)</strong> is a cornerstone of C++ programming, enabling developers to model complex systems through classes and objects. This chapter delves into the essential principles of OOP, providing a solid foundation for building robust and maintainable applications.</p>
<span id="more"></span>

<h2 id="Table-of-Contents-for-This-Chapter"><a href="#Table-of-Contents-for-This-Chapter" class="headerlink" title="Table of Contents for This Chapter"></a>Table of Contents for This Chapter</h2><ol>
<li><a href="#classes-and-objects">Classes and Objects</a></li>
<li><a href="#constructors-and-destructors">Constructors and Destructors</a></li>
<li><a href="#copy-and-move-semantics">Copy and Move Semantics</a></li>
<li><a href="#inheritance-and-polymorphism">Inheritance and Polymorphism</a></li>
<li><a href="#operator-overloading">Operator Overloading</a></li>
<li><a href="#union-and-struct-as-special-classes">Union and Struct as Special Classes</a></li>
<li><a href="#type-conversions">Type Conversions</a></li>
<li><a href="#variable-modifiers-const-static-mutable-volatile">Variable Modifiers (<code>const</code>, <code>static</code>, <code>mutable</code>, <code>volatile</code>)</a></li>
<li><a href="#virtual-functions-and-abstract-classes">Virtual Functions and Abstract Classes</a></li>
</ol>
<hr>
<h2 id="Classes-and-Objects"><a href="#Classes-and-Objects" class="headerlink" title="Classes and Objects"></a>Classes and Objects</h2><h3 id="What-Are-Classes-and-Objects"><a href="#What-Are-Classes-and-Objects" class="headerlink" title="What Are Classes and Objects?"></a>What Are Classes and Objects?</h3><ul>
<li><strong>Class</strong>: A blueprint for creating objects. It encapsulates data for the object and methods to manipulate that data.</li>
<li><strong>Object</strong>: An instance of a class. It represents a specific entity with its own state and behavior as defined by the class.</li>
</ul>
<h3 id="Defining-a-Class"><a href="#Defining-a-Class" class="headerlink" title="Defining a Class"></a>Defining a Class</h3><p>To define a class in C++, use the <code>class</code> keyword followed by the class name and a pair of curly braces <code>&#123;&#125;</code> enclosing its members.</p>
<p><strong>Syntax:</strong></p>
<pre><code class="cpp">class ClassName &#123;
public:
    // Public members
private:
    // Private members
protected:
    // Protected members
&#125;;
</code></pre>
<h3 id="Example-Defining-and-Using-a-Class"><a href="#Example-Defining-and-Using-a-Class" class="headerlink" title="Example: Defining and Using a Class"></a>Example: Defining and Using a Class</h3><pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;string&gt;

// Definition of the Person class
class Person &#123;
public:
    // Public member variables
    std::string name;
    int age;

    // Public member function
    void introduce() const &#123;
        std::cout &lt;&lt; &quot;Hello, my name is &quot; &lt;&lt; name 
                  &lt;&lt; &quot; and I am &quot; &lt;&lt; age &lt;&lt; &quot; years old.&quot; &lt;&lt; std::endl;
    &#125;

private:
    // Private member variable
    std::string secret;
&#125;;

int main() &#123;
    // Creating an object of the Person class
    Person person1;
    person1.name = &quot;Alice&quot;;
    person1.age = 30;
    
    // Calling a member function
    person1.introduce();

    return 0;
&#125;
</code></pre>
<p><strong>Output:</strong></p>
<pre><code>Hello, my name is Alice and I am 30 years old.
</code></pre>
<h3 id="Access-Specifiers"><a href="#Access-Specifiers" class="headerlink" title="Access Specifiers"></a>Access Specifiers</h3><ul>
<li><strong>public</strong>: Members are accessible from outside the class.</li>
<li><strong>private</strong>: Members are accessible only within the class.</li>
<li><strong>protected</strong>: Members are accessible within the class and by derived classes.</li>
</ul>
<p><strong>Example:</strong></p>
<pre><code class="cpp">class Example &#123;
public:
    int publicVar; // Accessible from anywhere

private:
    int privateVar; // Accessible only within the class

protected:
    int protectedVar; // Accessible within the class and derived classes
&#125;;
</code></pre>
<hr>
<h2 id="Constructors-and-Destructors"><a href="#Constructors-and-Destructors" class="headerlink" title="Constructors and Destructors"></a>Constructors and Destructors</h2><h3 id="Constructors"><a href="#Constructors" class="headerlink" title="Constructors"></a>Constructors</h3><p>Constructors are special member functions that are called when an object is created. They initialize the object’s data members and allocate resources if necessary.</p>
<p><strong>Types of Constructors:</strong></p>
<ol>
<li><strong>Default Constructor</strong>: Takes no arguments.</li>
<li><strong>Parameterized Constructor</strong>: Takes parameters to initialize the object.</li>
<li><strong>Copy Constructor</strong>: Creates a new object as a copy of an existing object.</li>
<li><strong>Move Constructor</strong>: Transfers resources from a temporary object to a new object.</li>
</ol>
<p><strong>Example:</strong></p>
<pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;string&gt;

class Person &#123;
public:
    // Default constructor
    Person() : name(&quot;Unknown&quot;), age(0) &#123;
        std::cout &lt;&lt; &quot;Default constructor called.&quot; &lt;&lt; std::endl;
    &#125;

    // Parameterized constructor
    Person(const std::string&amp; personName, int personAge) 
        : name(personName), age(personAge) &#123;
        std::cout &lt;&lt; &quot;Parameterized constructor called.&quot; &lt;&lt; std::endl;
    &#125;

    // Copy constructor
    Person(const Person&amp; other) 
        : name(other.name), age(other.age) &#123;
        std::cout &lt;&lt; &quot;Copy constructor called.&quot; &lt;&lt; std::endl;
    &#125;

    // Move constructor
    Person(Person&amp;&amp; other) noexcept 
        : name(std::move(other.name)), age(other.age) &#123;
        std::cout &lt;&lt; &quot;Move constructor called.&quot; &lt;&lt; std::endl;
    &#125;

    // Display information
    void display() const &#123;
        std::cout &lt;&lt; &quot;Name: &quot; &lt;&lt; name &lt;&lt; &quot;, Age: &quot; &lt;&lt; age &lt;&lt; std::endl;
    &#125;

private:
    std::string name;
    int age;
&#125;;

int main() &#123;
    Person p1; // Default constructor
    p1.display();

    Person p2(&quot;Alice&quot;, 30); // Parameterized constructor
    p2.display();

    Person p3 = p2; // Copy constructor
    p3.display();

    Person p4 = std::move(p2); // Move constructor
    p4.display();

    return 0;
&#125;
</code></pre>
<p><strong>Output:</strong></p>
<pre><code>Default constructor called.
Name: Unknown, Age: 0
Parameterized constructor called.
Name: Alice, Age: 30
Copy constructor called.
Name: Alice, Age: 30
Move constructor called.
Name: Alice, Age: 30
</code></pre>
<h3 id="Destructors"><a href="#Destructors" class="headerlink" title="Destructors"></a>Destructors</h3><p>Destructors are special member functions that are called when an object is destroyed. They are used to release resources allocated to the object and perform any necessary cleanup.</p>
<p><strong>Syntax:</strong></p>
<pre><code class="cpp">~ClassName() &#123;
    // Cleanup code
&#125;
</code></pre>
<p><strong>Example:</strong></p>
<pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;string&gt;

class Resource &#123;
public:
    // Constructor
    Resource(const std::string&amp; resourceName) : name(resourceName) &#123;
        std::cout &lt;&lt; &quot;Resource &quot; &lt;&lt; name &lt;&lt; &quot; acquired.&quot; &lt;&lt; std::endl;
    &#125;

    // Destructor
    ~Resource() &#123;
        std::cout &lt;&lt; &quot;Resource &quot; &lt;&lt; name &lt;&lt; &quot; released.&quot; &lt;&lt; std::endl;
    &#125;

private:
    std::string name;
&#125;;

int main() &#123;
    &#123;
        Resource res1(&quot;FileHandle&quot;);
        Resource res2(&quot;NetworkSocket&quot;);
    &#125; // res1 and res2 go out of scope here

    return 0;
&#125;
</code></pre>
<p><strong>Output:</strong></p>
<pre><code>Resource FileHandle acquired.
Resource NetworkSocket acquired.
Resource NetworkSocket released.
Resource FileHandle released.
</code></pre>
<hr>
<h2 id="Copy-and-Move-Semantics"><a href="#Copy-and-Move-Semantics" class="headerlink" title="Copy and Move Semantics"></a>Copy and Move Semantics</h2><h3 id="Copy-Semantics"><a href="#Copy-Semantics" class="headerlink" title="Copy Semantics"></a>Copy Semantics</h3><p>Copy semantics involve creating a new object as a copy of an existing object. This is typically handled by the copy constructor and copy assignment operator.</p>
<p><strong>Copy Constructor:</strong></p>
<pre><code class="cpp">ClassName(const ClassName&amp; other);
</code></pre>
<p><strong>Copy Assignment Operator:</strong></p>
<pre><code class="cpp">ClassName&amp; operator=(const ClassName&amp; other);
</code></pre>
<p><strong>Example:</strong></p>
<pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;string&gt;

class Box &#123;
public:
    // Parameterized constructor
    Box(double w, double h, double d) : width(w), height(h), depth(d) &#123;&#125;

    // Copy constructor
    Box(const Box&amp; other) 
        : width(other.width), height(other.height), depth(other.depth) &#123;
        std::cout &lt;&lt; &quot;Copy constructor called.&quot; &lt;&lt; std::endl;
    &#125;

    // Display dimensions
    void display() const &#123;
        std::cout &lt;&lt; &quot;Box(&quot; &lt;&lt; width &lt;&lt; &quot; x &quot; 
                  &lt;&lt; height &lt;&lt; &quot; x &quot; &lt;&lt; depth &lt;&lt; &quot;)&quot; &lt;&lt; std::endl;
    &#125;

private:
    double width;
    double height;
    double depth;
&#125;;

int main() &#123;
    Box box1(3.0, 4.0, 5.0);
    box1.display();

    Box box2 = box1; // Invokes copy constructor
    box2.display();

    return 0;
&#125;
</code></pre>
<p><strong>Output:</strong></p>
<pre><code>Box(3 x 4 x 5)
Copy constructor called.
Box(3 x 4 x 5)
</code></pre>
<h3 id="Move-Semantics"><a href="#Move-Semantics" class="headerlink" title="Move Semantics"></a>Move Semantics</h3><p>Move semantics allow the resources of a temporary object to be transferred rather than copied, enhancing performance, especially for objects with dynamic memory allocation.</p>
<p><strong>Move Constructor:</strong></p>
<pre><code class="cpp">ClassName(ClassName&amp;&amp; other) noexcept;
</code></pre>
<p><strong>Move Assignment Operator:</strong></p>
<pre><code class="cpp">ClassName&amp; operator=(ClassName&amp;&amp; other) noexcept;
</code></pre>
<p><strong>Example:</strong></p>
<pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;string&gt;

class Buffer &#123;
public:
    // Default constructor
    Buffer() : data(nullptr), size(0) &#123;&#125;

    // Parameterized constructor
    Buffer(size_t sz) : size(sz) &#123;
        data = new int[size];
        std::cout &lt;&lt; &quot;Buffer of size &quot; &lt;&lt; size &lt;&lt; &quot; created.&quot; &lt;&lt; std::endl;
    &#125;

    // Copy constructor
    Buffer(const Buffer&amp; other) : size(other.size) &#123;
        data = new int[size];
        std::copy(other.data, other.data + size, data);
        std::cout &lt;&lt; &quot;Buffer copied.&quot; &lt;&lt; std::endl;
    &#125;

    // Move constructor
    Buffer(Buffer&amp;&amp; other) noexcept : data(other.data), size(other.size) &#123;
        other.data = nullptr;
        other.size = 0;
        std::cout &lt;&lt; &quot;Buffer moved.&quot; &lt;&lt; std::endl;
    &#125;

    // Destructor
    ~Buffer() &#123;
        delete[] data;
        if (size &gt; 0) &#123;
            std::cout &lt;&lt; &quot;Buffer of size &quot; &lt;&lt; size &lt;&lt; &quot; destroyed.&quot; &lt;&lt; std::endl;
        &#125;
    &#125;

    // Display buffer info
    void display() const &#123;
        std::cout &lt;&lt; &quot;Buffer size: &quot; &lt;&lt; size &lt;&lt; &quot;, Data pointer: &quot; 
                  &lt;&lt; data &lt;&lt; std::endl;
    &#125;

private:
    int* data;
    size_t size;
&#125;;

int main() &#123;
    Buffer buf1(10);
    buf1.display();

    Buffer buf2 = std::move(buf1); // Invokes move constructor
    buf2.display();
    buf1.display(); // buf1 is now in a valid but unspecified state

    return 0;
&#125;
</code></pre>
<p><strong>Output:</strong></p>
<pre><code>Buffer of size 10 created.
Buffer size: 10, Data pointer: 0x7ffeefbff5c0
Buffer moved.
Buffer size: 10, Data pointer: 0x7ffeefbff5c0
Buffer size: 0, Data pointer: 0
Buffer of size 10 destroyed.
</code></pre>
<p><strong>Explanation:</strong></p>
<ul>
<li><strong>Move Constructor</strong>: Transfers ownership of resources from <code>buf1</code> to <code>buf2</code>. After the move, <code>buf1</code> no longer owns the data.</li>
<li><strong>Performance Benefit</strong>: Avoids unnecessary deep copies, especially beneficial for large or resource-intensive objects.</li>
</ul>
<hr>
<h2 id="Inheritance-and-Polymorphism"><a href="#Inheritance-and-Polymorphism" class="headerlink" title="Inheritance and Polymorphism"></a>Inheritance and Polymorphism</h2><h3 id="Inheritance"><a href="#Inheritance" class="headerlink" title="Inheritance"></a>Inheritance</h3><p>Inheritance allows a class (derived class) to inherit properties and behaviors from another class (base class). This promotes code reuse and establishes a hierarchical relationship between classes.</p>
<p><strong>Syntax:</strong></p>
<pre><code class="cpp">class BaseClass &#123;
public:
    void baseFunction() &#123;
        // Base class function
    &#125;
&#125;;

class DerivedClass : public BaseClass &#123;
public:
    void derivedFunction() &#123;
        // Derived class function
    &#125;
&#125;;
</code></pre>
<p><strong>Example:</strong></p>
<pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;string&gt;

// Base class
class Animal &#123;
public:
    void eat() const &#123;
        std::cout &lt;&lt; &quot;This animal eats food.&quot; &lt;&lt; std::endl;
    &#125;
&#125;;

// Derived class
class Dog : public Animal &#123;
public:
    void bark() const &#123;
        std::cout &lt;&lt; &quot;The dog barks.&quot; &lt;&lt; std::endl;
    &#125;
&#125;;

int main() &#123;
    Dog myDog;
    myDog.eat();   // Inherited from Animal
    myDog.bark();  // Defined in Dog

    return 0;
&#125;
</code></pre>
<p><strong>Output:</strong></p>
<pre><code>This animal eats food.
The dog barks.
</code></pre>
<h3 id="Polymorphism"><a href="#Polymorphism" class="headerlink" title="Polymorphism"></a>Polymorphism</h3><p>Polymorphism allows objects of different classes to be treated as objects of a common base class. It enables one interface to be used for a general class of actions, with specific actions determined by the exact nature of the situation.</p>
<p>There are two types of polymorphism in C++:</p>
<ol>
<li><strong>Compile-Time Polymorphism</strong>: Achieved through function overloading and templates.</li>
<li><strong>Run-Time Polymorphism</strong>: Achieved through inheritance and virtual functions.</li>
</ol>
<h4 id="Virtual-Functions"><a href="#Virtual-Functions" class="headerlink" title="Virtual Functions"></a>Virtual Functions</h4><p>A virtual function is a member function that you expect to be redefined in derived classes. When you refer to a derived class object using a pointer or a reference to the base class, you can call a virtual function for that object and execute the derived class’s version of the function.</p>
<p><strong>Example:</strong></p>
<pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;string&gt;

// Base class
class Shape &#123;
public:
    virtual void draw() const &#123; // Virtual function
        std::cout &lt;&lt; &quot;Drawing a generic shape.&quot; &lt;&lt; std::endl;
    &#125;
&#125;;

// Derived class
class Circle : public Shape &#123;
public:
    void draw() const override &#123; // Override keyword for clarity
        std::cout &lt;&lt; &quot;Drawing a circle.&quot; &lt;&lt; std::endl;
    &#125;
&#125;;

// Another derived class
class Square : public Shape &#123;
public:
    void draw() const override &#123;
        std::cout &lt;&lt; &quot;Drawing a square.&quot; &lt;&lt; std::endl;
    &#125;
&#125;;

int main() &#123;
    Shape* shape1 = new Circle();
    Shape* shape2 = new Square();

    shape1-&gt;draw(); // Outputs: Drawing a circle.
    shape2-&gt;draw(); // Outputs: Drawing a square.

    delete shape1;
    delete shape2;

    return 0;
&#125;
</code></pre>
<p><strong>Output:</strong></p>
<pre><code>Drawing a circle.
Drawing a square.
</code></pre>
<h4 id="Abstract-Classes"><a href="#Abstract-Classes" class="headerlink" title="Abstract Classes"></a>Abstract Classes</h4><p>An abstract class is a class that cannot be instantiated and is designed to be subclassed. It typically contains at least one pure virtual function, which must be overridden by derived classes.</p>
<p><strong>Syntax:</strong></p>
<pre><code class="cpp">class AbstractClass &#123;
public:
    virtual void pureVirtualFunction() = 0; // Pure virtual function
&#125;;
</code></pre>
<p><strong>Example:</strong></p>
<pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;string&gt;

// Abstract base class
class Vehicle &#123;
public:
    virtual void move() const = 0; // Pure virtual function
&#125;;

// Derived class
class Car : public Vehicle &#123;
public:
    void move() const override &#123;
        std::cout &lt;&lt; &quot;The car drives on the road.&quot; &lt;&lt; std::endl;
    &#125;
&#125;;

// Another derived class
class Boat : public Vehicle &#123;
public:
    void move() const override &#123;
        std::cout &lt;&lt; &quot;The boat sails on the water.&quot; &lt;&lt; std::endl;
    &#125;
&#125;;

int main() &#123;
    // Vehicle v; // Error: Cannot instantiate abstract class

    Vehicle* car = new Car();
    Vehicle* boat = new Boat();

    car-&gt;move();   // Outputs: The car drives on the road.
    boat-&gt;move();  // Outputs: The boat sails on the water.

    delete car;
    delete boat;

    return 0;
&#125;
</code></pre>
<p><strong>Output:</strong></p>
<pre><code>The car drives on the road.
The boat sails on the water.
</code></pre>
<p><strong>Explanation:</strong></p>
<ul>
<li><strong>Abstract Class (<code>Vehicle</code>)</strong>: Defines a common interface (<code>move</code>) for all vehicles.</li>
<li><strong>Derived Classes (<code>Car</code>, <code>Boat</code>)</strong>: Provide specific implementations of the <code>move</code> function.</li>
<li><strong>Polymorphism</strong>: Allows treating different vehicles uniformly through base class pointers.</li>
</ul>
<hr>
<h2 id="Operator-Overloading"><a href="#Operator-Overloading" class="headerlink" title="Operator Overloading"></a>Operator Overloading</h2><p>Operator overloading allows you to redefine the way operators work for user-defined types (classes and structs). This enhances the readability and intuitiveness of your classes by enabling natural syntax for operations.</p>
<h3 id="Why-Overload-Operators"><a href="#Why-Overload-Operators" class="headerlink" title="Why Overload Operators?"></a>Why Overload Operators?</h3><ul>
<li><strong>Intuitiveness</strong>: Makes objects behave like built-in types.</li>
<li><strong>Readability</strong>: Simplifies code by allowing concise expressions.</li>
<li><strong>Functionality</strong>: Enables complex operations to be performed seamlessly.</li>
</ul>
<h3 id="How-to-Overload-Operators"><a href="#How-to-Overload-Operators" class="headerlink" title="How to Overload Operators"></a>How to Overload Operators</h3><p>Operators can be overloaded as member functions or as friend functions. Not all operators can be overloaded, and care must be taken to maintain code clarity.</p>
<p><strong>Syntax:</strong></p>
<pre><code class="cpp">// Member function
ReturnType operatorOp(Parameters) &#123;
    // Implementation
&#125;

// Friend function
friend ReturnType operatorOp(const ClassName&amp; lhs, const ClassName&amp; rhs) &#123;
    // Implementation
&#125;
</code></pre>
<h3 id="Example-Overloading-the-Operator"><a href="#Example-Overloading-the-Operator" class="headerlink" title="Example: Overloading the + Operator"></a>Example: Overloading the <code>+</code> Operator</h3><pre><code class="cpp">#include &lt;iostream&gt;

class Vector &#123;
public:
    Vector(int x, int y) : x_(x), y_(y) &#123;&#125;

    // Overload the + operator as a member function
    Vector operator+(const Vector&amp; other) const &#123;
        return Vector(x_ + other.x_, y_ + other.y_);
    &#125;

    // Display vector components
    void display() const &#123;
        std::cout &lt;&lt; &quot;(&quot; &lt;&lt; x_ &lt;&lt; &quot;, &quot; &lt;&lt; y_ &lt;&lt; &quot;)&quot; &lt;&lt; std::endl;
    &#125;

private:
    int x_;
    int y_;
&#125;;

int main() &#123;
    Vector v1(1, 2);
    Vector v2(3, 4);
    Vector v3 = v1 + v2; // Uses overloaded + operator

    v3.display(); // Outputs: (4, 6)

    return 0;
&#125;
</code></pre>
<p><strong>Output:</strong></p>
<pre><code>(4, 6)
</code></pre>
<h3 id="Example-Overloading-the"><a href="#Example-Overloading-the" class="headerlink" title="Example: Overloading the &lt;&lt; Operator for Output"></a>Example: Overloading the <code>&lt;&lt;</code> Operator for Output</h3><pre><code class="cpp">#include &lt;iostream&gt;

class Point &#123;
public:
    Point(int x, int y) : x_(x), y_(y) &#123;&#125;

    // Overload the &lt;&lt; operator as a friend function
    friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const Point&amp; pt) &#123;
        os &lt;&lt; &quot;(&quot; &lt;&lt; pt.x_ &lt;&lt; &quot;, &quot; &lt;&lt; pt.y_ &lt;&lt; &quot;)&quot;;
        return os;
    &#125;

private:
    int x_;
    int y_;
&#125;;

int main() &#123;
    Point p(5, 10);
    std::cout &lt;&lt; &quot;Point p: &quot; &lt;&lt; p &lt;&lt; std::endl; // Uses overloaded &lt;&lt; operator
    return 0;
&#125;
</code></pre>
<p><strong>Output:</strong></p>
<pre><code>Point p: (5, 10)
</code></pre>
<h3 id="Best-Practices-for-Operator-Overloading"><a href="#Best-Practices-for-Operator-Overloading" class="headerlink" title="Best Practices for Operator Overloading"></a>Best Practices for Operator Overloading</h3><ol>
<li><strong>Maintain Intuitive Behavior</strong>: Overloaded operators should behave as expected to avoid confusing users.</li>
<li><strong>Consistency</strong>: Ensure that operator overloads are consistent with their traditional meanings.</li>
<li><strong>Avoid Overloading Unrelated Operators</strong>: Only overload operators that make logical sense for the class.</li>
<li><strong>Prefer Member Functions for Symmetric Operators</strong>: For operators like <code>+</code>, member functions are often more appropriate.</li>
<li><strong>Use Friend Functions When Necessary</strong>: For operators that require access to private members of multiple classes.</li>
</ol>
<hr>
<h2 id="Union-and-Struct-as-Special-Classes"><a href="#Union-and-Struct-as-Special-Classes" class="headerlink" title="Union and Struct as Special Classes"></a>Union and Struct as Special Classes</h2><p>In C++, <code>struct</code> and <code>union</code> are special types of classes with unique characteristics and use cases.</p>
<h3 id="Structs"><a href="#Structs" class="headerlink" title="Structs"></a>Structs</h3><p>A <code>struct</code> is similar to a <code>class</code> but has default public access specifiers. It is primarily used for passive objects that carry data.</p>
<p><strong>Syntax:</strong></p>
<pre><code class="cpp">struct StructName &#123;
    // Public members by default
    int member1;
    double member2;

    void display() const &#123;
        std::cout &lt;&lt; &quot;Member1: &quot; &lt;&lt; member1 
                  &lt;&lt; &quot;, Member2: &quot; &lt;&lt; member2 &lt;&lt; std::endl;
    &#125;
&#125;;
</code></pre>
<p><strong>Example:</strong></p>
<pre><code class="cpp">#include &lt;iostream&gt;

struct Point &#123;
    int x;
    int y;

    void display() const &#123;
        std::cout &lt;&lt; &quot;Point(&quot; &lt;&lt; x &lt;&lt; &quot;, &quot; &lt;&lt; y &lt;&lt; &quot;)&quot; &lt;&lt; std::endl;
    &#125;
&#125;;

int main() &#123;
    Point p = &#123;10, 20&#125;;
    p.display(); // Outputs: Point(10, 20)
    return 0;
&#125;
</code></pre>
<h3 id="Unions"><a href="#Unions" class="headerlink" title="Unions"></a>Unions</h3><p>A <code>union</code> allows storing different data types in the same memory location. Only one member can hold a value at any given time.</p>
<p><strong>Syntax:</strong></p>
<pre><code class="cpp">union UnionName &#123;
    int intVal;
    float floatVal;
    char charVal;
&#125;;
</code></pre>
<p><strong>Example:</strong></p>
<pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;cstring&gt;

union Data &#123;
    int intVal;
    float floatVal;
    char charVal;
&#125;;

int main() &#123;
    Data data;
    data.intVal = 100;
    std::cout &lt;&lt; &quot;data.intVal: &quot; &lt;&lt; data.intVal &lt;&lt; std::endl;

    data.floatVal = 98.6f;
    std::cout &lt;&lt; &quot;data.floatVal: &quot; &lt;&lt; data.floatVal &lt;&lt; std::endl;

    data.charVal = &#39;A&#39;;
    std::cout &lt;&lt; &quot;data.charVal: &quot; &lt;&lt; data.charVal &lt;&lt; std::endl;

    return 0;
&#125;
</code></pre>
<p><strong>Output:</strong></p>
<pre><code>data.intVal: 100
data.floatVal: 98.6
data.charVal: A
</code></pre>
<p><strong>Note:</strong> Assigning to one member overwrites the others since all members share the same memory.</p>
<hr>
<h2 id="Type-Conversions"><a href="#Type-Conversions" class="headerlink" title="Type Conversions"></a>Type Conversions</h2><p>Type conversions, also known as type casting, allow you to convert a value from one data type to another. Understanding type conversions is crucial for operations involving different data types, function calls, and more, especially within the context of OOP.</p>
<h3 id="Implicit-Type-Conversion"><a href="#Implicit-Type-Conversion" class="headerlink" title="Implicit Type Conversion"></a>Implicit Type Conversion</h3><p>Implicit type conversion occurs automatically when converting from a smaller to a larger type or between compatible types. The compiler handles this conversion without explicit instructions.</p>
<p><strong>Example:</strong></p>
<pre><code class="cpp">#include &lt;iostream&gt;

int main() &#123;
    int a = 10;
    double b = a; // Implicitly converts int to double
    std::cout &lt;&lt; &quot;b = &quot; &lt;&lt; b &lt;&lt; std::endl; // Outputs: b = 10.0
    return 0;
&#125;
</code></pre>
<p><strong>Key Points:</strong></p>
<ul>
<li>Safe and lossless when converting to a type that can represent all possible values of the original type.</li>
<li>Can lead to precision loss when converting from a floating-point to an integer type.</li>
</ul>
<h3 id="Explicit-Type-Conversion"><a href="#Explicit-Type-Conversion" class="headerlink" title="Explicit Type Conversion"></a>Explicit Type Conversion</h3><p>Explicit type conversion, or casting, is performed manually using casting operators. It is necessary when implicit conversion is not possible or could lead to data loss.</p>
<p><strong>C++ Casting Operators:</strong></p>
<ol>
<li><strong><code>static_cast</code></strong></li>
<li><strong><code>dynamic_cast</code></strong></li>
<li><strong><code>const_cast</code></strong></li>
<li><strong><code>reinterpret_cast</code></strong></li>
</ol>
<h4 id="static-cast"><a href="#static-cast" class="headerlink" title="static_cast"></a><code>static_cast</code></h4><p>Used for well-defined and safe conversions, such as between numeric types or upcasting in inheritance hierarchies.</p>
<p><strong>Example:</strong></p>
<pre><code class="cpp">#include &lt;iostream&gt;

int main() &#123;
    double pi = 3.14159;
    int intPi = static_cast&lt;int&gt;(pi); // Explicitly converts double to int
    std::cout &lt;&lt; &quot;intPi = &quot; &lt;&lt; intPi &lt;&lt; std::endl; // Outputs: intPi = 3
    return 0;
&#125;
</code></pre>
<h4 id="dynamic-cast"><a href="#dynamic-cast" class="headerlink" title="dynamic_cast"></a><code>dynamic_cast</code></h4><p>Used primarily for downcasting in inheritance hierarchies, ensuring that the cast is safe at runtime. Requires the base class to have at least one virtual function.</p>
<p><strong>Example:</strong></p>
<pre><code class="cpp">#include &lt;iostream&gt;

class Base &#123;
public:
    virtual void speak() const &#123; std::cout &lt;&lt; &quot;Base speaking.&quot; &lt;&lt; std::endl; &#125;
&#125;;

class Derived : public Base &#123;
public:
    void speak() const override &#123; std::cout &lt;&lt; &quot;Derived speaking.&quot; &lt;&lt; std::endl; &#125;
&#125;;

int main() &#123;
    Base* basePtr = new Derived();
    Derived* derivedPtr = dynamic_cast&lt;Derived*&gt;(basePtr);
    
    if (derivedPtr) &#123;
        derivedPtr-&gt;speak(); // Outputs: Derived speaking.
    &#125; else &#123;
        std::cout &lt;&lt; &quot;Cast failed.&quot; &lt;&lt; std::endl;
    &#125;

    delete basePtr;
    return 0;
&#125;
</code></pre>
<h4 id="const-cast"><a href="#const-cast" class="headerlink" title="const_cast"></a><code>const_cast</code></h4><p>Used to add or remove the <code>const</code> qualifier from a variable. It should be used cautiously, as modifying a <code>const</code> variable after removing <code>const</code> can lead to undefined behavior.</p>
<p><strong>Example:</strong></p>
<pre><code class="cpp">#include &lt;iostream&gt;

void printNumber(const int* num) &#123;
    int* modifiableNum = const_cast&lt;int*&gt;(num);
    *modifiableNum = 20; // Undefined behavior if num was originally const
    std::cout &lt;&lt; &quot;Number: &quot; &lt;&lt; *modifiableNum &lt;&lt; std::endl;
&#125;

int main() &#123;
    int value = 10;
    printNumber(&amp;value); // Outputs: Number: 20
    return 0;
&#125;
</code></pre>
<h4 id="reinterpret-cast"><a href="#reinterpret-cast" class="headerlink" title="reinterpret_cast"></a><code>reinterpret_cast</code></h4><p>Used for low-level, unsafe conversions, such as converting between pointer types or between pointers and integers. It should be used sparingly and only when absolutely necessary.</p>
<p><strong>Example:</strong></p>
<pre><code class="cpp">#include &lt;iostream&gt;

int main() &#123;
    int a = 65;
    char* charPtr = reinterpret_cast&lt;char*&gt;(&amp;a);
    std::cout &lt;&lt; &quot;Character: &quot; &lt;&lt; *charPtr &lt;&lt; std::endl; // May output: &#39;A&#39;
    return 0;
&#125;
</code></pre>
<p><strong>Caution:</strong> <code>reinterpret_cast</code> can lead to platform-dependent behavior and should be avoided unless you have a clear understanding of the implications.</p>
<h3 id="Best-Practices-for-Type-Conversion"><a href="#Best-Practices-for-Type-Conversion" class="headerlink" title="Best Practices for Type Conversion"></a>Best Practices for Type Conversion</h3><ol>
<li><p><strong>Prefer Implicit Conversions When Safe:</strong></p>
<ul>
<li>Use implicit conversions when they are safe and do not lead to data loss or unexpected behavior.</li>
</ul>
</li>
<li><p><strong>Use <code>static_cast</code> for Clear Intentions:</strong></p>
<ul>
<li>When you need to convert between compatible types, <code>static_cast</code> makes your intentions explicit.</li>
</ul>
</li>
<li><p><strong>Minimize the Use of <code>reinterpret_cast</code>:</strong></p>
<ul>
<li>Avoid <code>reinterpret_cast</code> unless absolutely necessary due to its unsafe nature.</li>
</ul>
</li>
<li><p><strong>Ensure Safe Downcasting with <code>dynamic_cast</code>:</strong></p>
<ul>
<li>When downcasting in an inheritance hierarchy, use <code>dynamic_cast</code> to ensure the cast is valid at runtime.</li>
</ul>
</li>
<li><p><strong>Maintain Const-Correctness:</strong></p>
<ul>
<li>Use <code>const_cast</code> judiciously to maintain the integrity of <code>const</code> variables.</li>
</ul>
</li>
<li><p><strong>Avoid Unnecessary Casts:</strong></p>
<ul>
<li>Unnecessary type casts can make code harder to read and maintain. Only cast when required.</li>
</ul>
</li>
</ol>
<h3 id="Using-Type-Conversions-in-Code"><a href="#Using-Type-Conversions-in-Code" class="headerlink" title="Using Type Conversions in Code"></a>Using Type Conversions in Code</h3><p>Understanding when and how to perform type conversions is essential for writing flexible and error-free C++ programs. Let’s modify our program to include examples of type conversions.</p>
<h4 id="Step-1-Update-main-cpp"><a href="#Step-1-Update-main-cpp" class="headerlink" title="Step 1: Update main.cpp"></a>Step 1: Update <code>main.cpp</code></h4><p>Open <code>src/main.cpp</code> and replace its contents with the following code:</p>
<pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;string&gt;

int main() &#123;
    // Implicit Type Conversion
    int integer = 42;
    double floating = integer; // Implicitly converts int to double
    std::cout &lt;&lt; &quot;Floating: &quot; &lt;&lt; floating &lt;&lt; std::endl; // Outputs: Floating: 42.0

    // Explicit Type Conversion using static_cast
    double pi = 3.14159;
    int intPi = static_cast&lt;int&gt;(pi); // Explicitly converts double to int
    std::cout &lt;&lt; &quot;intPi: &quot; &lt;&lt; intPi &lt;&lt; std::endl; // Outputs: intPi: 3

    // Explicit Type Conversion using reinterpret_cast
    int a = 65;
    char* charPtr = reinterpret_cast&lt;char*&gt;(&amp;a);
    std::cout &lt;&lt; &quot;Character: &quot; &lt;&lt; *charPtr &lt;&lt; std::endl; // May output: Character: &#39;A&#39;

    // Using const_cast
    const int value = 100;
    int* modifiableValue = const_cast&lt;int*&gt;(&amp;value);
    *modifiableValue = 200; // Undefined behavior if value was originally const
    std::cout &lt;&lt; &quot;Modified Value: &quot; &lt;&lt; value &lt;&lt; std::endl; // Outputs: Modified Value: 200

    return 0;
&#125;
</code></pre>
<h4 id="Step-2-Build-and-Run-the-Program"><a href="#Step-2-Build-and-Run-the-Program" class="headerlink" title="Step 2: Build and Run the Program"></a>Step 2: Build and Run the Program</h4><p>In the terminal, build the project:</p>
<pre><code class="bash">xmake
</code></pre>
<p>Run the program:</p>
<pre><code class="bash">xmake run
</code></pre>
<h4 id="Expected-Output"><a href="#Expected-Output" class="headerlink" title="Expected Output"></a>Expected Output</h4><pre><code>Floating: 42
intPi: 3
Character: A
Modified Value: 200
</code></pre>
<p><strong>Note:</strong> Modifying a <code>const</code> variable using <code>const_cast</code> leads to undefined behavior if the original variable was declared as <code>const</code>. In this example, <code>value</code> is modified after being cast, which is generally unsafe and should be avoided in real-world applications.</p>
<h4 id="Explanation"><a href="#Explanation" class="headerlink" title="Explanation"></a>Explanation</h4><ul>
<li><p><strong>Implicit Conversion:</strong></p>
<ul>
<li><code>int</code> to <code>double</code> is performed automatically without explicit casting.</li>
</ul>
</li>
<li><p><strong>Explicit Conversion (<code>static_cast</code>):</strong></p>
<ul>
<li>Converts <code>double</code> to <code>int</code>, truncating the decimal part.</li>
</ul>
</li>
<li><p><strong>Explicit Conversion (<code>reinterpret_cast</code>):</strong></p>
<ul>
<li>Treats the memory address of an <code>int</code> as a <code>char*</code> to access individual bytes. This is useful for low-level programming but should be used with caution.</li>
</ul>
</li>
<li><p><strong>Explicit Conversion (<code>const_cast</code>):</strong></p>
<ul>
<li>Removes the <code>const</code> qualifier from a variable, allowing modification. This can lead to undefined behavior if not used carefully.</li>
</ul>
</li>
</ul>
<hr>
<h2 id="Operator-Overloading-1"><a href="#Operator-Overloading-1" class="headerlink" title="Operator Overloading"></a>Operator Overloading</h2><p>Operator overloading allows you to redefine the way operators work for user-defined types (classes and structs). This enhances the readability and intuitiveness of your classes by enabling natural syntax for operations.</p>
<h3 id="Why-Overload-Operators-1"><a href="#Why-Overload-Operators-1" class="headerlink" title="Why Overload Operators?"></a>Why Overload Operators?</h3><ul>
<li><strong>Intuitiveness</strong>: Makes objects behave like built-in types.</li>
<li><strong>Readability</strong>: Simplifies code by allowing concise expressions.</li>
<li><strong>Functionality</strong>: Enables complex operations to be performed seamlessly.</li>
</ul>
<h3 id="How-to-Overload-Operators-1"><a href="#How-to-Overload-Operators-1" class="headerlink" title="How to Overload Operators"></a>How to Overload Operators</h3><p>Operators can be overloaded as member functions or as friend functions. Not all operators can be overloaded, and care must be taken to maintain code clarity.</p>
<p><strong>Syntax:</strong></p>
<pre><code class="cpp">// Member function
ReturnType operatorOp(Parameters) &#123;
    // Implementation
&#125;

// Friend function
friend ReturnType operatorOp(const ClassName&amp; lhs, const ClassName&amp; rhs) &#123;
    // Implementation
&#125;
</code></pre>
<h3 id="Example-Overloading-the-Operator-1"><a href="#Example-Overloading-the-Operator-1" class="headerlink" title="Example: Overloading the + Operator"></a>Example: Overloading the <code>+</code> Operator</h3><pre><code class="cpp">#include &lt;iostream&gt;

class Vector &#123;
public:
    Vector(int x, int y) : x_(x), y_(y) &#123;&#125;

    // Overload the + operator as a member function
    Vector operator+(const Vector&amp; other) const &#123;
        return Vector(x_ + other.x_, y_ + other.y_);
    &#125;

    // Display vector components
    void display() const &#123;
        std::cout &lt;&lt; &quot;(&quot; &lt;&lt; x_ &lt;&lt; &quot;, &quot; &lt;&lt; y_ &lt;&lt; &quot;)&quot; &lt;&lt; std::endl;
    &#125;

private:
    int x_;
    int y_;
&#125;;

int main() &#123;
    Vector v1(1, 2);
    Vector v2(3, 4);
    Vector v3 = v1 + v2; // Uses overloaded + operator

    v3.display(); // Outputs: (4, 6)

    return 0;
&#125;
</code></pre>
<p><strong>Output:</strong></p>
<pre><code>(4, 6)
</code></pre>
<h3 id="Example-Overloading-the-1"><a href="#Example-Overloading-the-1" class="headerlink" title="Example: Overloading the &lt;&lt; Operator for Output"></a>Example: Overloading the <code>&lt;&lt;</code> Operator for Output</h3><pre><code class="cpp">#include &lt;iostream&gt;

class Point &#123;
public:
    Point(int x, int y) : x_(x), y_(y) &#123;&#125;

    // Overload the &lt;&lt; operator as a friend function
    friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const Point&amp; pt) &#123;
        os &lt;&lt; &quot;(&quot; &lt;&lt; pt.x_ &lt;&lt; &quot;, &quot; &lt;&lt; pt.y_ &lt;&lt; &quot;)&quot;;
        return os;
    &#125;

private:
    int x_;
    int y_;
&#125;;

int main() &#123;
    Point p(5, 10);
    std::cout &lt;&lt; &quot;Point p: &quot; &lt;&lt; p &lt;&lt; std::endl; // Uses overloaded &lt;&lt; operator
    return 0;
&#125;
</code></pre>
<p><strong>Output:</strong></p>
<pre><code>Point p: (5, 10)
</code></pre>
<h3 id="Best-Practices-for-Operator-Overloading-1"><a href="#Best-Practices-for-Operator-Overloading-1" class="headerlink" title="Best Practices for Operator Overloading"></a>Best Practices for Operator Overloading</h3><ol>
<li><strong>Maintain Intuitive Behavior</strong>: Overloaded operators should behave as expected to avoid confusing users.</li>
<li><strong>Consistency</strong>: Ensure that operator overloads are consistent with their traditional meanings.</li>
<li><strong>Avoid Overloading Unrelated Operators</strong>: Only overload operators that make logical sense for the class.</li>
<li><strong>Prefer Member Functions for Symmetric Operators</strong>: For operators like <code>+</code>, member functions are often more appropriate.</li>
<li><strong>Use Friend Functions When Necessary</strong>: For operators that require access to private members of multiple classes.</li>
</ol>
<hr>
<h2 id="Union-and-Struct-as-Special-Classes-1"><a href="#Union-and-Struct-as-Special-Classes-1" class="headerlink" title="Union and Struct as Special Classes"></a>Union and Struct as Special Classes</h2><p>In C++, <code>struct</code> and <code>union</code> are special types of classes with unique characteristics and use cases.</p>
<h3 id="Structs-1"><a href="#Structs-1" class="headerlink" title="Structs"></a>Structs</h3><p>A <code>struct</code> is similar to a <code>class</code> but has default public access specifiers. It is primarily used for passive objects that carry data.</p>
<p><strong>Syntax:</strong></p>
<pre><code class="cpp">struct StructName &#123;
    // Public members by default
    int member1;
    double member2;

    void display() const &#123;
        std::cout &lt;&lt; &quot;Member1: &quot; &lt;&lt; member1 
                  &lt;&lt; &quot;, Member2: &quot; &lt;&lt; member2 &lt;&lt; std::endl;
    &#125;
&#125;;
</code></pre>
<p><strong>Example:</strong></p>
<pre><code class="cpp">#include &lt;iostream&gt;

struct Point &#123;
    int x;
    int y;

    void display() const &#123;
        std::cout &lt;&lt; &quot;Point(&quot; &lt;&lt; x &lt;&lt; &quot;, &quot; &lt;&lt; y &lt;&lt; &quot;)&quot; &lt;&lt; std::endl;
    &#125;
&#125;;

int main() &#123;
    Point p = &#123;10, 20&#125;;
    p.display(); // Outputs: Point(10, 20)
    return 0;
&#125;
</code></pre>
<h3 id="Unions-1"><a href="#Unions-1" class="headerlink" title="Unions"></a>Unions</h3><p>A <code>union</code> allows storing different data types in the same memory location. Only one member can hold a value at any given time.</p>
<p><strong>Syntax:</strong></p>
<pre><code class="cpp">union UnionName &#123;
    int intVal;
    float floatVal;
    char charVal;
&#125;;
</code></pre>
<p><strong>Example:</strong></p>
<pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;cstring&gt;

union Data &#123;
    int intVal;
    float floatVal;
    char charVal;
&#125;;

int main() &#123;
    Data data;
    data.intVal = 100;
    std::cout &lt;&lt; &quot;data.intVal: &quot; &lt;&lt; data.intVal &lt;&lt; std::endl;

    data.floatVal = 98.6f;
    std::cout &lt;&lt; &quot;data.floatVal: &quot; &lt;&lt; data.floatVal &lt;&lt; std::endl;

    data.charVal = &#39;A&#39;;
    std::cout &lt;&lt; &quot;data.charVal: &quot; &lt;&lt; data.charVal &lt;&lt; std::endl;

    return 0;
&#125;
</code></pre>
<p><strong>Output:</strong></p>
<pre><code>data.intVal: 100
data.floatVal: 98.6
data.charVal: A
</code></pre>
<p><strong>Note:</strong> Assigning to one member overwrites the others since all members share the same memory.</p>
<hr>
<h2 id="Type-Conversions-1"><a href="#Type-Conversions-1" class="headerlink" title="Type Conversions"></a>Type Conversions</h2><p>Type conversions, also known as type casting, allow you to convert a value from one data type to another. Understanding type conversions is crucial for operations involving different data types, function calls, and more, especially within the context of OOP.</p>
<h3 id="Implicit-Type-Conversion-1"><a href="#Implicit-Type-Conversion-1" class="headerlink" title="Implicit Type Conversion"></a>Implicit Type Conversion</h3><p>Implicit type conversion occurs automatically when converting from a smaller to a larger type or between compatible types. The compiler handles this conversion without explicit instructions.</p>
<p><strong>Example:</strong></p>
<pre><code class="cpp">#include &lt;iostream&gt;

int main() &#123;
    int a = 10;
    double b = a; // Implicitly converts int to double
    std::cout &lt;&lt; &quot;b = &quot; &lt;&lt; b &lt;&lt; std::endl; // Outputs: b = 10.0
    return 0;
&#125;
</code></pre>
<p><strong>Key Points:</strong></p>
<ul>
<li>Safe and lossless when converting to a type that can represent all possible values of the original type.</li>
<li>Can lead to precision loss when converting from a floating-point to an integer type.</li>
</ul>
<h3 id="Explicit-Type-Conversion-1"><a href="#Explicit-Type-Conversion-1" class="headerlink" title="Explicit Type Conversion"></a>Explicit Type Conversion</h3><p>Explicit type conversion, or casting, is performed manually using casting operators. It is necessary when implicit conversion is not possible or could lead to data loss.</p>
<p><strong>C++ Casting Operators:</strong></p>
<ol>
<li><strong><code>static_cast</code></strong></li>
<li><strong><code>dynamic_cast</code></strong></li>
<li><strong><code>const_cast</code></strong></li>
<li><strong><code>reinterpret_cast</code></strong></li>
</ol>
<h4 id="static-cast-1"><a href="#static-cast-1" class="headerlink" title="static_cast"></a><code>static_cast</code></h4><p>Used for well-defined and safe conversions, such as between numeric types or upcasting in inheritance hierarchies.</p>
<p><strong>Example:</strong></p>
<pre><code class="cpp">#include &lt;iostream&gt;

int main() &#123;
    double pi = 3.14159;
    int intPi = static_cast&lt;int&gt;(pi); // Explicitly converts double to int
    std::cout &lt;&lt; &quot;intPi = &quot; &lt;&lt; intPi &lt;&lt; std::endl; // Outputs: intPi = 3
    return 0;
&#125;
</code></pre>
<h4 id="dynamic-cast-1"><a href="#dynamic-cast-1" class="headerlink" title="dynamic_cast"></a><code>dynamic_cast</code></h4><p>Used primarily for downcasting in inheritance hierarchies, ensuring that the cast is safe at runtime. Requires the base class to have at least one virtual function.</p>
<p><strong>Example:</strong></p>
<pre><code class="cpp">#include &lt;iostream&gt;

class Base &#123;
public:
    virtual void speak() const &#123; std::cout &lt;&lt; &quot;Base speaking.&quot; &lt;&lt; std::endl; &#125;
&#125;;

class Derived : public Base &#123;
public:
    void speak() const override &#123; std::cout &lt;&lt; &quot;Derived speaking.&quot; &lt;&lt; std::endl; &#125;
&#125;;

int main() &#123;
    Base* basePtr = new Derived();
    Derived* derivedPtr = dynamic_cast&lt;Derived*&gt;(basePtr);
    
    if (derivedPtr) &#123;
        derivedPtr-&gt;speak(); // Outputs: Derived speaking.
    &#125; else &#123;
        std::cout &lt;&lt; &quot;Cast failed.&quot; &lt;&lt; std::endl;
    &#125;

    delete basePtr;
    return 0;
&#125;
</code></pre>
<h4 id="const-cast-1"><a href="#const-cast-1" class="headerlink" title="const_cast"></a><code>const_cast</code></h4><p>Used to add or remove the <code>const</code> qualifier from a variable. It should be used cautiously, as modifying a <code>const</code> variable after removing <code>const</code> can lead to undefined behavior.</p>
<p><strong>Example:</strong></p>
<pre><code class="cpp">#include &lt;iostream&gt;

void printNumber(const int* num) &#123;
    int* modifiableNum = const_cast&lt;int*&gt;(num);
    *modifiableNum = 20; // Undefined behavior if num was originally const
    std::cout &lt;&lt; &quot;Number: &quot; &lt;&lt; *modifiableNum &lt;&lt; std::endl;
&#125;

int main() &#123;
    int value = 10;
    printNumber(&amp;value); // Outputs: Number: 20
    return 0;
&#125;
</code></pre>
<h4 id="reinterpret-cast-1"><a href="#reinterpret-cast-1" class="headerlink" title="reinterpret_cast"></a><code>reinterpret_cast</code></h4><p>Used for low-level, unsafe conversions, such as converting between pointer types or between pointers and integers. It should be used sparingly and only when absolutely necessary.</p>
<p><strong>Example:</strong></p>
<pre><code class="cpp">#include &lt;iostream&gt;

int main() &#123;
    int a = 65;
    char* charPtr = reinterpret_cast&lt;char*&gt;(&amp;a);
    std::cout &lt;&lt; &quot;Character: &quot; &lt;&lt; *charPtr &lt;&lt; std::endl; // May output: &#39;A&#39;
    return 0;
&#125;
</code></pre>
<p><strong>Caution:</strong> <code>reinterpret_cast</code> can lead to platform-dependent behavior and should be avoided unless you have a clear understanding of the implications.</p>
<h3 id="Best-Practices-for-Type-Conversion-1"><a href="#Best-Practices-for-Type-Conversion-1" class="headerlink" title="Best Practices for Type Conversion"></a>Best Practices for Type Conversion</h3><ol>
<li><p><strong>Prefer Implicit Conversions When Safe:</strong></p>
<ul>
<li>Use implicit conversions when they are safe and do not lead to data loss or unexpected behavior.</li>
</ul>
</li>
<li><p><strong>Use <code>static_cast</code> for Clear Intentions:</strong></p>
<ul>
<li>When you need to convert between compatible types, <code>static_cast</code> makes your intentions explicit.</li>
</ul>
</li>
<li><p><strong>Minimize the Use of <code>reinterpret_cast</code>:</strong></p>
<ul>
<li>Avoid <code>reinterpret_cast</code> unless absolutely necessary due to its unsafe nature.</li>
</ul>
</li>
<li><p><strong>Ensure Safe Downcasting with <code>dynamic_cast</code>:</strong></p>
<ul>
<li>When downcasting in an inheritance hierarchy, use <code>dynamic_cast</code> to ensure the cast is valid at runtime.</li>
</ul>
</li>
<li><p><strong>Maintain Const-Correctness:</strong></p>
<ul>
<li>Use <code>const_cast</code> judiciously to maintain the integrity of <code>const</code> variables.</li>
</ul>
</li>
<li><p><strong>Avoid Unnecessary Casts:</strong></p>
<ul>
<li>Unnecessary type casts can make code harder to read and maintain. Only cast when required.</li>
</ul>
</li>
</ol>
<h3 id="Using-Type-Conversions-in-Code-1"><a href="#Using-Type-Conversions-in-Code-1" class="headerlink" title="Using Type Conversions in Code"></a>Using Type Conversions in Code</h3><p>Understanding when and how to perform type conversions is essential for writing flexible and error-free C++ programs. Let’s modify our program to include examples of type conversions.</p>
<h4 id="Step-1-Update-main-cpp-1"><a href="#Step-1-Update-main-cpp-1" class="headerlink" title="Step 1: Update main.cpp"></a>Step 1: Update <code>main.cpp</code></h4><p>Open <code>src/main.cpp</code> and replace its contents with the following code:</p>
<pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;string&gt;

int main() &#123;
    // Implicit Type Conversion
    int integer = 42;
    double floating = integer; // Implicitly converts int to double
    std::cout &lt;&lt; &quot;Floating: &quot; &lt;&lt; floating &lt;&lt; std::endl; // Outputs: Floating: 42.0

    // Explicit Type Conversion using static_cast
    double pi = 3.14159;
    int intPi = static_cast&lt;int&gt;(pi); // Explicitly converts double to int
    std::cout &lt;&lt; &quot;intPi: &quot; &lt;&lt; intPi &lt;&lt; std::endl; // Outputs: intPi: 3

    // Explicit Type Conversion using reinterpret_cast
    int a = 65;
    char* charPtr = reinterpret_cast&lt;char*&gt;(&amp;a);
    std::cout &lt;&lt; &quot;Character: &quot; &lt;&lt; *charPtr &lt;&lt; std::endl; // May output: Character: &#39;A&#39;

    // Using const_cast
    const int value = 100;
    int* modifiableValue = const_cast&lt;int*&gt;(&amp;value);
    *modifiableValue = 200; // Undefined behavior if value was originally const
    std::cout &lt;&lt; &quot;Modified Value: &quot; &lt;&lt; value &lt;&lt; std::endl; // Outputs: Modified Value: 200

    return 0;
&#125;
</code></pre>
<h4 id="Step-2-Build-and-Run-the-Program-1"><a href="#Step-2-Build-and-Run-the-Program-1" class="headerlink" title="Step 2: Build and Run the Program"></a>Step 2: Build and Run the Program</h4><p>In the terminal, build the project:</p>
<pre><code class="bash">xmake
</code></pre>
<p>Run the program:</p>
<pre><code class="bash">xmake run
</code></pre>
<h4 id="Expected-Output-1"><a href="#Expected-Output-1" class="headerlink" title="Expected Output"></a>Expected Output</h4><pre><code>Floating: 42
intPi: 3
Character: A
Modified Value: 200
</code></pre>
<p><strong>Note:</strong> Modifying a <code>const</code> variable using <code>const_cast</code> leads to undefined behavior if the original variable was declared as <code>const</code>. In this example, <code>value</code> is modified after being cast, which is generally unsafe and should be avoided in real-world applications.</p>
<h4 id="Explanation-1"><a href="#Explanation-1" class="headerlink" title="Explanation"></a>Explanation</h4><ul>
<li><p><strong>Implicit Conversion:</strong></p>
<ul>
<li><code>int</code> to <code>double</code> is performed automatically without explicit casting.</li>
</ul>
</li>
<li><p><strong>Explicit Conversion (<code>static_cast</code>):</strong></p>
<ul>
<li>Converts <code>double</code> to <code>int</code>, truncating the decimal part.</li>
</ul>
</li>
<li><p><strong>Explicit Conversion (<code>reinterpret_cast</code>):</strong></p>
<ul>
<li>Treats the memory address of an <code>int</code> as a <code>char*</code> to access individual bytes. This is useful for low-level programming but should be used with caution.</li>
</ul>
</li>
<li><p><strong>Explicit Conversion (<code>const_cast</code>):</strong></p>
<ul>
<li>Removes the <code>const</code> qualifier from a variable, allowing modification. This can lead to undefined behavior if not used carefully.</li>
</ul>
</li>
</ul>
<hr>
<h2 id="Variable-Modifiers-const-static-mutable-volatile"><a href="#Variable-Modifiers-const-static-mutable-volatile" class="headerlink" title="Variable Modifiers (const, static, mutable, volatile)"></a>Variable Modifiers (<code>const</code>, <code>static</code>, <code>mutable</code>, <code>volatile</code>)</h2><p>Variable modifiers in C++ alter the behavior or characteristics of variables. Within the context of OOP, these modifiers are often used to control access, manage memory, and enforce const-correctness.</p>
<h3 id="const"><a href="#const" class="headerlink" title="const"></a><code>const</code></h3><p>The <code>const</code> keyword makes a variable read-only after its initialization. Attempting to modify a <code>const</code> variable will result in a compile-time error.</p>
<p><strong>Usage in Classes:</strong></p>
<ul>
<li><p><strong>Constant Member Functions</strong>: Functions that do not modify the state of the object.</p>
<pre><code class="cpp">class Rectangle &#123;
public:
    Rectangle(double w, double h) : width(w), height(h) &#123;&#125;

    double area() const &#123; // const member function
        return width * height;
    &#125;

private:
    double width;
    double height;
&#125;;
</code></pre>
</li>
<li><p><strong>Constant Data Members</strong>: Data members that cannot be modified after initialization.</p>
<pre><code class="cpp">class Circle &#123;
public:
    Circle(double r) : radius(r) &#123;&#125;

    double getRadius() const &#123;
        return radius;
    &#125;

private:
    const double radius; // Constant data member
&#125;;
</code></pre>
</li>
</ul>
<h3 id="static"><a href="#static" class="headerlink" title="static"></a><code>static</code></h3><p>The <code>static</code> keyword has different meanings depending on the context within a class:</p>
<ul>
<li><p><strong>Static Data Members</strong>: Shared among all instances of the class. They are not tied to any specific object.</p>
<pre><code class="cpp">class Counter &#123;
public:
    Counter() &#123; ++count; &#125;
    static int getCount() &#123; return count; &#125;

private:
    static int count; // Declaration
&#125;;

// Definition and initialization
int Counter::count = 0;

int main() &#123;
    Counter c1;
    Counter c2;
    std::cout &lt;&lt; &quot;Number of Counter instances: &quot; &lt;&lt; Counter::getCount() &lt;&lt; std::endl; // Outputs: 2
    return 0;
&#125;
</code></pre>
</li>
<li><p><strong>Static Member Functions</strong>: Can be called without creating an instance of the class. They can only access static data members.</p>
<pre><code class="cpp">class MathUtils &#123;
public:
    static double pi() &#123;
        return 3.14159;
    &#125;
&#125;;

int main() &#123;
    std::cout &lt;&lt; &quot;Pi: &quot; &lt;&lt; MathUtils::pi() &lt;&lt; std::endl; // Outputs: Pi: 3.14159
    return 0;
&#125;
</code></pre>
</li>
</ul>
<h3 id="mutable"><a href="#mutable" class="headerlink" title="mutable"></a><code>mutable</code></h3><p>The <code>mutable</code> keyword allows a member of an object to be modified even if the object is declared as <code>const</code>. This is useful for fields that are logically not part of the object’s state, such as caching or logging information.</p>
<p><strong>Example:</strong></p>
<pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;string&gt;

class Logger &#123;
public:
    Logger(const std::string&amp; msg) : message(msg), logCount(0) &#123;&#125;

    void log() const &#123;
        ++logCount; // Allowed because logCount is mutable
        std::cout &lt;&lt; &quot;Log: &quot; &lt;&lt; message &lt;&lt; &quot; (Log Count: &quot; &lt;&lt; logCount &lt;&lt; &quot;)&quot; &lt;&lt; std::endl;
    &#125;

private:
    std::string message;
    mutable int logCount; // Mutable member
&#125;;

int main() &#123;
    const Logger logger(&quot;Starting application&quot;);
    logger.log(); // Log Count: 1
    logger.log(); // Log Count: 2

    return 0;
&#125;
</code></pre>
<p><strong>Output:</strong></p>
<pre><code>Log: Starting application (Log Count: 1)
Log: Starting application (Log Count: 2)
</code></pre>
<h3 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a><code>volatile</code></h3><p>The <code>volatile</code> keyword indicates that a variable’s value may be changed by something outside the control of the program, such as hardware or a different thread. It prevents the compiler from applying certain optimizations that assume values do not change unexpectedly.</p>
<p><strong>Usage in Classes:</strong></p>
<ul>
<li><p><strong>Volatile Member Variables</strong>: Useful in scenarios where variables can be modified by external factors, such as memory-mapped hardware registers or signal handlers.</p>
<pre><code class="cpp">class HardwareRegister &#123;
public:
    volatile int status; // Status register that can change unexpectedly

    HardwareRegister() : status(0) &#123;&#125;

    void updateStatus(int newStatus) &#123;
        status = newStatus;
    &#125;

    void checkStatus() const &#123;
        if (status &amp; 0x1) &#123;
            std::cout &lt;&lt; &quot;Status bit 0 is set.&quot; &lt;&lt; std::endl;
        &#125;
    &#125;
&#125;;

int main() &#123;
    HardwareRegister reg;
    reg.updateStatus(1);
    reg.checkStatus(); // Outputs: Status bit 0 is set.

    return 0;
&#125;
</code></pre>
</li>
</ul>
<p><strong>Important Considerations:</strong></p>
<ul>
<li><strong>Limited Use Cases</strong>: The <code>volatile</code> keyword has specific use cases and is not commonly needed in typical application development.</li>
<li><strong>Not a Substitute for Synchronization</strong>: <code>volatile</code> does not provide any thread synchronization or memory ordering guarantees. For multithreading, prefer using atomic types and synchronization primitives from <code>&lt;atomic&gt;</code> and <code>&lt;mutex&gt;</code>.</li>
</ul>
<p><strong>Example with Multithreading:</strong></p>
<pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;thread&gt;
#include &lt;atomic&gt;

class SharedCounter &#123;
public:
    SharedCounter() : count(0) &#123;&#125;

    void increment() &#123;
        ++count; // Atomic operation
    &#125;

    int getCount() const &#123;
        return count.load();
    &#125;

private:
    std::atomic&lt;int&gt; count; // Atomic variable for thread-safe operations
&#125;;

int main() &#123;
    SharedCounter counter;
    std::thread t1([&amp;counter]() &#123;
        for(int i = 0; i &lt; 1000; ++i) &#123;
            counter.increment();
        &#125;
    &#125;);

    std::thread t2([&amp;counter]() &#123;
        for(int i = 0; i &lt; 1000; ++i) &#123;
            counter.increment();
        &#125;
    &#125;);

    t1.join();
    t2.join();

    std::cout &lt;&lt; &quot;Final count: &quot; &lt;&lt; counter.getCount() &lt;&lt; std::endl; // Outputs: Final count: 2000

    return 0;
&#125;
</code></pre>
<p>In this example, using <code>std::atomic&lt;int&gt;</code> ensures that increments are thread-safe without needing the <code>volatile</code> keyword.</p>
<hr>
<h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><p>In this chapter, you’ve explored the foundational principles of <strong>Object-Oriented Programming (OOP)</strong> in C++:</p>
<ul>
<li><strong>Classes and Objects</strong>: Learned how to define classes as blueprints for objects and create instances from them.</li>
<li><strong>Constructors and Destructors</strong>: Gained insights into object initialization and cleanup through various types of constructors and destructors.</li>
<li><strong>Copy and Move Semantics</strong>: Learned how to efficiently copy and move objects, optimizing performance and resource management.</li>
<li><strong>Inheritance and Polymorphism</strong>: Discovered how to create hierarchical relationships between classes and enable run-time polymorphism using virtual functions.</li>
<li><strong>Operator Overloading</strong>: Understood how to redefine operators for user-defined types to enhance code readability and intuitiveness.</li>
<li><strong>Union and Struct as Special Classes</strong>: Explored the unique characteristics and use cases of <code>union</code> and <code>struct</code> in C++.</li>
<li><strong>Type Conversions</strong>: Mastered implicit and explicit type conversions, utilizing casting operators to ensure safe and efficient type handling.</li>
<li><strong>Variable Modifiers (<code>const</code>, <code>static</code>, <code>mutable</code>, <code>volatile</code>)</strong>: Understood how these modifiers control variable behavior within classes.</li>
<li><strong>Virtual Functions and Abstract Classes</strong>: Delved into creating abstract interfaces and leveraging polymorphism for flexible and reusable code.</li>
</ul>
<p>Mastering these OOP concepts is crucial for building complex, maintainable, and scalable C++ applications. As you progress, you’ll apply these principles to design robust software systems that effectively model real-world scenarios.</p>
<hr>
<p>Now you’re ready to move on to <strong>Templates and Generic Programming</strong> where you’ll learn how to create flexible and reusable code components using templates.</p>
<p>Next chapter: <a href="/2024/09/27/cpp-unleash/02h-tplgenpgm">Templates and Generic Programming</a></p>

    </div>
    
    
    
    
    <div id="comment">
        <div id="giscus-container" class="giscus"></div>
    </div>
    
    
    
    
</div>

            <footer id="footer">
    <div id="footer-wrap">
        <div>
            &copy;
            2024 - 2024 Tab&#39;s Blog
            <span id="footer-icon">
                <i class="fa-solid fa-font-awesome fa-fw"></i>
            </span>
            &commat;Tab Nahida
        </div>
        <div>
            Based on the <a target="_blank" rel="noopener" href="https://hexo.io">Hexo Engine</a> &amp;
            <a target="_blank" rel="noopener" href="https://github.com/theme-particlex/hexo-theme-particlex">ParticleX Theme</a>
        </div>
        
    </div>
</footer>

        </div>
        
        <transition name="fade">
            <div id="preview" ref="preview" v-show="previewShow">
                <img id="preview-content" ref="previewContent" />
            </div>
        </transition>
        
    </div>
    <script src="/js/main.js"></script>
    
    
<script
    src="https://giscus.app/client.js"
    data-repo="TabNahida/TabNahida.github.io"
    data-repo-id="R_kgDOJtk4Ag"
    data-category="General"
    data-category-id="DIC_kwDOJtk4As4Ci3B7"
    data-mapping="pathname"
    data-strict="0"
    data-reactions-enabled="1"
    data-emit-metadata="0"
    data-input-position="bottom"
    data-theme="light_protanopia"
    data-lang="en"
    crossorigin
    async
></script>





    
</body>
</html>
