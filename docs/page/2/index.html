
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <title>Tab&#39;s Blog</title>
    <meta name="author" content="Tab Nahida" />
    <meta name="description" content="" />
    <meta name="keywords" content="" />
    <meta
        name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0"
    />
    <link rel="icon" href="/images/avatar1.png" />
    <link rel="preconnect" href="https://s4.zstatic.net" />
<script src="https://s4.zstatic.net/ajax/libs/vue/3.3.7/vue.global.prod.min.js"></script>
<link rel="stylesheet" href="https://s4.zstatic.net/ajax/libs/font-awesome/6.4.2/css/all.min.css" />
<link rel="preconnect" href="https://fonts.googleapis.cn" />
<link rel="preconnect" href="https://fonts.gstatic.cn" crossorigin />
<link
    rel="stylesheet"
    href="https://fonts.googleapis.cn/css2?family=Fira+Code:wght@400;500;600;700&family=Lexend:wght@400;500;600;700;800;900&family=Noto+Sans+SC:wght@400;500;600;700;800;900&display=swap"
/>
<script> const mixins = {}; </script>

<script src="https://polyfill.alicdn.com/v3/polyfill.min.js?features=default"></script>


<script src="https://s4.zstatic.net/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://s4.zstatic.net/ajax/libs/highlightjs-line-numbers.js/2.8.0/highlightjs-line-numbers.min.js"></script>
<link
    rel="stylesheet"
    href="https://s4.zstatic.net/ajax/libs/highlight.js/11.9.0/styles/github.min.css"
/>
<script src="/js/lib/highlight.js"></script>



<script src="/js/lib/preview.js"></script>





<script src="/js/lib/home.js"></script>

<link rel="stylesheet" href="/css/main.css" />

<meta name="generator" content="Hexo 7.3.0"></head>
<body>
    <div id="layout">
        <transition name="fade">
            <div id="loading" v-show="loading">
                <div id="loading-circle">
                    <h2>LOADING</h2>
                    <p>加载过慢请开启缓存 浏览器默认开启</p>
                    <img src="/images/loading.gif" />
                </div>
            </div>
        </transition>
        <div id="menu" :class="{ hidden: hiddenMenu, 'menu-color': menuColor}">
    <nav id="desktop-menu">
        <a class="title" href="/">
            <span>TAB&#39;S BLOG</span>
        </a>
        
        <a href="/">
            <i class="fa-solid fa-house fa-fw"></i>
            <span>&ensp;Home</span>
        </a>
        
        <a href="/about">
            <i class="fa-solid fa-id-card fa-fw"></i>
            <span>&ensp;About</span>
        </a>
        
        <a href="/archives">
            <i class="fa-solid fa-box-archive fa-fw"></i>
            <span>&ensp;Archives</span>
        </a>
        
        <a href="/categories">
            <i class="fa-solid fa-bookmark fa-fw"></i>
            <span>&ensp;Categories</span>
        </a>
        
        <a href="/tags">
            <i class="fa-solid fa-tags fa-fw"></i>
            <span>&ensp;Tags</span>
        </a>
        
    </nav>
    <nav id="mobile-menu">
        <div class="title" @click="showMenuItems = !showMenuItems">
            <i class="fa-solid fa-bars fa-fw"></i>
            <span>&emsp;TAB&#39;S BLOG</span>
        </div>
        <transition name="slide">
            <div class="items" v-show="showMenuItems">
                
                <a href="/">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-house fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Home</div>
                    </div>
                </a>
                
                <a href="/about">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-id-card fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">About</div>
                    </div>
                </a>
                
                <a href="/archives">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-box-archive fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Archives</div>
                    </div>
                </a>
                
                <a href="/categories">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-bookmark fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Categories</div>
                    </div>
                </a>
                
                <a href="/tags">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-tags fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Tags</div>
                    </div>
                </a>
                
            </div>
        </transition>
    </nav>
</div>
<transition name="fade">
    <div id="menu-curtain" @click="showMenuItems = !showMenuItems" v-show="showMenuItems"></div>
</transition>

        <div id="main" :class="loading ? 'into-enter-from': 'into-enter-active'">
            <div id="home-head">
    <div
        id="home-background"
        ref="homeBackground"
        data-images="/images/background1.jpg,/images/background2.jpg"
    ></div>
    <div id="home-info" @click="homeClick">
        <span class="loop"></span>
        <span class="loop"></span>
        <span class="loop"></span>
        <span class="loop"></span>
        <span class="info">
            <div class="wrap">
                <h1>Tab&#39;s Blog</h1>
                <h3>Estas Tab-klavo ĉi tie</h3>
                <h5></h5>
            </div>
        </span>
    </div>
</div>
<div
    id="home-posts-wrap"
    ref="homePostsWrap"
    true
>
    <div id="home-posts">
        

<div class="post">
    <a href="/2024/09/27/cpp-unleash/02h-excpt/">
        <h2 class="post-title">C++ Unleashed: Error Handling and Exceptions</h2>
    </a>
    <div class="category-and-date">
        
        <span class="category">
            <a href="/categories/tutor/">
                <span class="icon">
                    <i class="fa-solid fa-bookmark fa-fw"></i>
                </span>
                tutor
            </a>
        </span>
        
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2024/9/27
        </span>
        
        
    </div>
    <div class="description">
        <div class="content" v-pre>
            
            <p><em><strong>C++ Unleashed: From Zero to Hero</strong></em></p>
<p>Previous chapter: <a href="/2024/09/27/cpp-unleash/02h-stl">Standard Template Library (STL)</a></p>
<p><a href="/2024/09/26/cpp-unleash/02h-menu">Go to Table of Contents</a></p>
<h1 id="Error-Handling-and-Exceptions"><a href="#Error-Handling-and-Exceptions" class="headerlink" title="Error Handling and Exceptions"></a>Error Handling and Exceptions</h1><p>In C++, effective error handling is crucial for creating robust applications. This chapter will cover the concept of exceptions, how to use them for error handling, and best practices for managing errors in your code.</p>
<h2 id="The-Concept-of-Exceptions"><a href="#The-Concept-of-Exceptions" class="headerlink" title="The Concept of Exceptions"></a>The Concept of Exceptions</h2><p>Exceptions are events that occur during program execution that disrupt the normal flow of the program. They can be used to signal errors or unexpected conditions. Instead of returning error codes, C++ provides a more structured way to handle errors through exceptions.</p>
<h3 id="Key-Components-of-Exception-Handling"><a href="#Key-Components-of-Exception-Handling" class="headerlink" title="Key Components of Exception Handling"></a>Key Components of Exception Handling</h3><ol>
<li><strong>Throwing Exceptions</strong>: When an error condition is detected, an exception can be thrown using the <code>throw</code> keyword.</li>
<li><strong>Catching Exceptions</strong>: Exceptions are caught using <code>try</code> and <code>catch</code> blocks.</li>
<li><strong>Handling Exceptions</strong>: Once an exception is caught, you can handle it appropriately, such as logging the error or providing a fallback mechanism.</li>
</ol>
<h2 id="Using-try-catch-and-throw"><a href="#Using-try-catch-and-throw" class="headerlink" title="Using try, catch, and throw"></a>Using <code>try</code>, <code>catch</code>, and <code>throw</code></h2><h3 id="Throwing-Exceptions"><a href="#Throwing-Exceptions" class="headerlink" title="Throwing Exceptions"></a>Throwing Exceptions</h3><p>To throw an exception, use the <code>throw</code> keyword followed by an instance of an exception class. C++ provides several built-in exception classes, but you can also create custom exceptions.</p>
<p><strong>Example:</strong></p>
<pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;stdexcept&gt;

void divide(int a, int b) &#123;
    if (b == 0) &#123;
        throw std::invalid_argument(&quot;Division by zero is not allowed.&quot;);
    &#125;
    std::cout &lt;&lt; &quot;Result: &quot; &lt;&lt; a / b &lt;&lt; std::endl;
&#125;

int main() &#123;
    try &#123;
        divide(10, 0);
    &#125; catch (const std::invalid_argument&amp; e) &#123;
        std::cerr &lt;&lt; &quot;Error: &quot; &lt;&lt; e.what() &lt;&lt; std::endl; // Outputs: Error: Division by zero is not allowed.
    &#125;

    return 0;
&#125;
</code></pre>
<h3 id="Catching-Exceptions"><a href="#Catching-Exceptions" class="headerlink" title="Catching Exceptions"></a>Catching Exceptions</h3><p>The <code>try</code> block contains code that might throw an exception, while the <code>catch</code> block defines how to handle it. You can catch specific exceptions or use a general catch-all.</p>
<p><strong>Example:</strong></p>
<pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;stdexcept&gt;

void mightGoWrong() &#123;
    throw std::runtime_error(&quot;Something went wrong!&quot;);
&#125;

int main() &#123;
    try &#123;
        mightGoWrong();
    &#125; catch (const std::runtime_error&amp; e) &#123;
        std::cerr &lt;&lt; &quot;Caught an exception: &quot; &lt;&lt; e.what() &lt;&lt; std::endl; // Outputs: Caught an exception: Something went wrong!
    &#125;

    return 0;
&#125;
</code></pre>
<h3 id="Multiple-Catch-Blocks"><a href="#Multiple-Catch-Blocks" class="headerlink" title="Multiple Catch Blocks"></a>Multiple Catch Blocks</h3><p>You can have multiple <code>catch</code> blocks to handle different types of exceptions.</p>
<p><strong>Example:</strong></p>
<pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;stdexcept&gt;

void testFunction() &#123;
    throw std::out_of_range(&quot;Out of range error!&quot;);
&#125;

int main() &#123;
    try &#123;
        testFunction();
    &#125; catch (const std::out_of_range&amp; e) &#123;
        std::cerr &lt;&lt; &quot;Out of range: &quot; &lt;&lt; e.what() &lt;&lt; std::endl;
    &#125; catch (const std::exception&amp; e) &#123;
        std::cerr &lt;&lt; &quot;Standard exception: &quot; &lt;&lt; e.what() &lt;&lt; std::endl;
    &#125;

    return 0;
&#125;
</code></pre>
<h2 id="Best-Practices-for-Error-Handling"><a href="#Best-Practices-for-Error-Handling" class="headerlink" title="Best Practices for Error Handling"></a>Best Practices for Error Handling</h2><ol>
<li><strong>Use Exceptions for Exceptional Cases</strong>: Only use exceptions for situations that are truly exceptional. Avoid using them for regular control flow.</li>
<li><strong>Provide Meaningful Error Messages</strong>: When throwing exceptions, ensure the message clearly describes the error.</li>
<li><strong>Catch by Reference</strong>: Catch exceptions by reference to avoid slicing and to improve performance.</li>
<li><strong>Clean Up Resources</strong>: Use RAII (Resource Acquisition Is Initialization) to manage resources, ensuring they are released even in the presence of exceptions.</li>
<li><strong>Document Exception Behavior</strong>: Clearly document which functions may throw exceptions, so users of your code are aware of potential error conditions.</li>
</ol>
<h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><p>In this chapter, we explored error handling in C++ using exceptions. You learned how to throw, catch, and handle exceptions effectively, along with best practices for robust error management. Understanding and implementing proper error handling will enhance the reliability of your C++ applications and improve user experience. </p>
<p>In the next chapter, we will delve into using <strong>xmake to Build Projects</strong>, where you’ll learn how to set up and manage builds for your C++ projects.</p>
<p>Next chapter: <a href="/2024/09/27/cpp-unleash/02h-concurrency">Concurrency and Multithreading</a></p>

            
        </div>
    </div>
    <div class="post-tags">
        
        <span class="icon">
            <i class="fa-solid fa-tags fa-fw"></i>
        </span>
        
        
        
        <span class="tag">
            
            <a href="/tags/c-cpp/" style="color: #ffa2c4">c-cpp</a>
        </span>
        
        <span class="tag">
            
            <a href="/tags/modern-cpp/" style="color: #03a9f4">modern-cpp</a>
        </span>
        
        <span class="tag">
            
            <a href="/tags/cpp-unleash/" style="color: #ff7d73">cpp-unleash</a>
        </span>
        
        <span class="tag">
            
            <a href="/tags/02Hero/" style="color: #ffa2c4">02Hero</a>
        </span>
        
    </div>
    <a href="/2024/09/27/cpp-unleash/02h-excpt/" class="go-post">阅读全文</a>
</div>

<div class="post">
    <a href="/2024/09/27/cpp-unleash/02h-stl/">
        <h2 class="post-title">C++ Unleashed: Standard Template Library (STL)</h2>
    </a>
    <div class="category-and-date">
        
        <span class="category">
            <a href="/categories/tutor/">
                <span class="icon">
                    <i class="fa-solid fa-bookmark fa-fw"></i>
                </span>
                tutor
            </a>
        </span>
        
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2024/9/27
        </span>
        
        
    </div>
    <div class="description">
        <div class="content" v-pre>
            
            <p><em><strong>C++ Unleashed: From Zero to Hero</strong></em></p>
<p>Previous chapter: <a href="/2024/09/27/cpp-unleash/02h-mdncppftr">Modern C++ Features</a></p>
<p><a href="/2024/09/26/cpp-unleash/02h-menu">Go to Table of Contents</a></p>
<h1 id="Standard-Template-Library-STL"><a href="#Standard-Template-Library-STL" class="headerlink" title="Standard Template Library (STL)"></a>Standard Template Library (STL)</h1><p>The Standard Template Library (STL) is a powerful feature of C++ that provides a collection of template classes and functions for managing data. It includes a wide range of data structures (containers), algorithms, and iterators that allow for efficient data manipulation and storage. In this chapter, we will explore the key components of the STL.</p>
<p>In this chapter, we will cover:</p>
<ul>
<li>Containers<ul>
<li>Sequence Containers</li>
<li>Associative Containers</li>
<li>Unordered Containers</li>
<li>Container Adaptors</li>
</ul>
</li>
<li>Iterators</li>
<li>Algorithms</li>
<li>Function Objects (Functors)</li>
</ul>
<h2 id="Containers"><a href="#Containers" class="headerlink" title="Containers"></a>Containers</h2><p>Containers are data structures that store objects and provide member functions to manipulate them. The STL provides several types of containers, each designed for specific use cases.</p>
<h3 id="Sequence-Containers"><a href="#Sequence-Containers" class="headerlink" title="Sequence Containers"></a>Sequence Containers</h3><p>Sequence containers maintain the order of elements. The primary sequence containers are:</p>
<ul>
<li><strong><code>std::vector</code></strong></li>
<li><strong><code>std::deque</code></strong></li>
<li><strong><code>std::list</code></strong></li>
</ul>
<h4 id="std-vector"><a href="#std-vector" class="headerlink" title="std::vector"></a><code>std::vector</code></h4><p>A dynamic array that can resize itself. It provides fast random access to elements.</p>
<p><strong>Example:</strong></p>
<pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;

int main() &#123;
    std::vector&lt;int&gt; numbers = &#123;1, 2, 3, 4, 5&#125;;

    numbers.push_back(6); // Adding an element
    numbers.pop_back();   // Removing the last element

    for (const auto&amp; num : numbers) &#123;
        std::cout &lt;&lt; num &lt;&lt; &quot; &quot;; // Outputs: 1 2 3 4 5
    &#125;
    std::cout &lt;&lt; std::endl;

    return 0;
&#125;
</code></pre>
<h4 id="std-deque"><a href="#std-deque" class="headerlink" title="std::deque"></a><code>std::deque</code></h4><p>A double-ended queue that allows fast insertion and deletion at both ends.</p>
<p><strong>Example:</strong></p>
<pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;deque&gt;

int main() &#123;
    std::deque&lt;int&gt; d = &#123;1, 2, 3&#125;;

    d.push_front(0); // Add to the front
    d.push_back(4);  // Add to the back

    for (const auto&amp; num : d) &#123;
        std::cout &lt;&lt; num &lt;&lt; &quot; &quot;; // Outputs: 0 1 2 3 4
    &#125;
    std::cout &lt;&lt; std::endl;

    return 0;
&#125;
</code></pre>
<h4 id="std-list"><a href="#std-list" class="headerlink" title="std::list"></a><code>std::list</code></h4><p>A doubly linked list that allows fast insertion and deletion from any position.</p>
<p><strong>Example:</strong></p>
<pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;list&gt;

int main() &#123;
    std::list&lt;int&gt; l = &#123;1, 2, 3&#125;;

    l.push_back(4); // Add to the back
    l.push_front(0); // Add to the front

    for (const auto&amp; num : l) &#123;
        std::cout &lt;&lt; num &lt;&lt; &quot; &quot;; // Outputs: 0 1 2 3 4
    &#125;
    std::cout &lt;&lt; std::endl;

    return 0;
&#125;
</code></pre>
<h3 id="Associative-Containers"><a href="#Associative-Containers" class="headerlink" title="Associative Containers"></a>Associative Containers</h3><p>Associative containers store elements in a way that allows for fast retrieval based on keys. The primary associative containers are:</p>
<ul>
<li><strong><code>std::set</code></strong></li>
<li><strong><code>std::map</code></strong></li>
<li><strong><code>std::multiset</code></strong></li>
<li><strong><code>std::multimap</code></strong></li>
</ul>
<h4 id="std-set"><a href="#std-set" class="headerlink" title="std::set"></a><code>std::set</code></h4><p>A collection of unique elements stored in a specific order.</p>
<p><strong>Example:</strong></p>
<pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;set&gt;

int main() &#123;
    std::set&lt;int&gt; s = &#123;3, 1, 4, 2&#125;;

    s.insert(5); // Adding an element
    s.erase(2);  // Removing an element

    for (const auto&amp; num : s) &#123;
        std::cout &lt;&lt; num &lt;&lt; &quot; &quot;; // Outputs: 1 3 4 5
    &#125;
    std::cout &lt;&lt; std::endl;

    return 0;
&#125;
</code></pre>
<h4 id="std-map"><a href="#std-map" class="headerlink" title="std::map"></a><code>std::map</code></h4><p>A collection of key-value pairs, where keys are unique and stored in a specific order.</p>
<p><strong>Example:</strong></p>
<pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;map&gt;

int main() &#123;
    std::map&lt;std::string, int&gt; age;
    age[&quot;Alice&quot;] = 30;
    age[&quot;Bob&quot;] = 25;

    for (const auto&amp; [name, ageValue] : age) &#123;
        std::cout &lt;&lt; name &lt;&lt; &quot;: &quot; &lt;&lt; ageValue &lt;&lt; std::endl; // Outputs: Alice: 30, Bob: 25
    &#125;

    return 0;
&#125;
</code></pre>
<h3 id="Unordered-Containers"><a href="#Unordered-Containers" class="headerlink" title="Unordered Containers"></a>Unordered Containers</h3><p>Unordered containers allow for fast retrieval but do not maintain any particular order. The primary unordered containers are:</p>
<ul>
<li><strong><code>std::unordered_set</code></strong></li>
<li><strong><code>std::unordered_map</code></strong></li>
</ul>
<h4 id="std-unordered-set"><a href="#std-unordered-set" class="headerlink" title="std::unordered_set"></a><code>std::unordered_set</code></h4><p>A collection of unique elements with no specific order.</p>
<p><strong>Example:</strong></p>
<pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;unordered_set&gt;

int main() &#123;
    std::unordered_set&lt;int&gt; us = &#123;1, 2, 3&#125;;

    us.insert(4); // Adding an element
    us.erase(1);  // Removing an element

    for (const auto&amp; num : us) &#123;
        std::cout &lt;&lt; num &lt;&lt; &quot; &quot;; // Outputs: 2 3 4 (order may vary)
    &#125;
    std::cout &lt;&lt; std::endl;

    return 0;
&#125;
</code></pre>
<h4 id="std-unordered-map"><a href="#std-unordered-map" class="headerlink" title="std::unordered_map"></a><code>std::unordered_map</code></h4><p>A collection of key-value pairs with no specific order.</p>
<p><strong>Example:</strong></p>
<pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;unordered_map&gt;

int main() &#123;
    std::unordered_map&lt;std::string, int&gt; um;
    um[&quot;Alice&quot;] = 30;
    um[&quot;Bob&quot;] = 25;

    for (const auto&amp; [name, ageValue] : um) &#123;
        std::cout &lt;&lt; name &lt;&lt; &quot;: &quot; &lt;&lt; ageValue &lt;&lt; std::endl; // Outputs: Alice: 30, Bob: 25 (order may vary)
    &#125;

    return 0;
&#125;
</code></pre>
<h3 id="Container-Adaptors"><a href="#Container-Adaptors" class="headerlink" title="Container Adaptors"></a>Container Adaptors</h3><p>Container adaptors provide a different interface for existing containers. The primary adaptors are:</p>
<ul>
<li><strong><code>std::stack</code></strong></li>
<li><strong><code>std::queue</code></strong></li>
<li><strong><code>std::priority_queue</code></strong></li>
</ul>
<h4 id="std-stack"><a href="#std-stack" class="headerlink" title="std::stack"></a><code>std::stack</code></h4><p>A last-in-first-out (LIFO) data structure.</p>
<p><strong>Example:</strong></p>
<pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;stack&gt;

int main() &#123;
    std::stack&lt;int&gt; s;

    s.push(1);
    s.push(2);
    s.push(3);

    while (!s.empty()) &#123;
        std::cout &lt;&lt; s.top() &lt;&lt; &quot; &quot;; // Outputs: 3 2 1
        s.pop();
    &#125;
    std::cout &lt;&lt; std::endl;

    return 0;
&#125;
</code></pre>
<h4 id="std-queue"><a href="#std-queue" class="headerlink" title="std::queue"></a><code>std::queue</code></h4><p>A first-in-first-out (FIFO) data structure.</p>
<p><strong>Example:</strong></p>
<pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;queue&gt;

int main() &#123;
    std::queue&lt;int&gt; q;

    q.push(1);
    q.push(2);
    q.push(3);

    while (!q.empty()) &#123;
        std::cout &lt;&lt; q.front() &lt;&lt; &quot; &quot;; // Outputs: 1 2 3
        q.pop();
    &#125;
    std::cout &lt;&lt; std::endl;

    return 0;
&#125;
</code></pre>
<h4 id="std-priority-queue"><a href="#std-priority-queue" class="headerlink" title="std::priority_queue"></a><code>std::priority_queue</code></h4><p>A queue where the highest priority elements are served before others.</p>
<p><strong>Example:</strong></p>
<pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;queue&gt;

int main() &#123;
    std::priority_queue&lt;int&gt; pq;

    pq.push(3);
    pq.push(5);
    pq.push(1);

    while (!pq.empty()) &#123;
        std::cout &lt;&lt; pq.top() &lt;&lt; &quot; &quot;; // Outputs: 5 3 1 (highest priority first)
        pq.pop();
    &#125;
    std::cout &lt;&lt; std::endl;

    return 0;
&#125;
</code></pre>
<h2 id="Iterators"><a href="#Iterators" class="headerlink" title="Iterators"></a>Iterators</h2><p>Iterators are used to traverse the elements of a container. They provide a uniform interface to access the elements in different types of containers.</p>
<h3 id="Types-of-Iterators"><a href="#Types-of-Iterators" class="headerlink" title="Types of Iterators"></a>Types of Iterators</h3><ul>
<li><strong>Input Iterators</strong>: Can read data in a single-pass.</li>
<li><strong>Output Iterators</strong>: Can write data in a single-pass.</li>
<li><strong>Forward Iterators</strong>: Can read&#x2F;write data and can be used in multiple passes.</li>
<li><strong>Bidirectional Iterators</strong>: Can move in both directions.</li>
<li><strong>Random Access Iterators</strong>: Can access elements with arbitrary index.</li>
</ul>
<h3 id="Example"><a href="#Example" class="headerlink" title="Example:"></a>Example:</h3><pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;

int main() &#123;
    std::vector&lt;int&gt; numbers = &#123;1, 2, 3, 4, 5&#125;;

    // Using an iterator to traverse the vector
    for (auto it = numbers.begin(); it != numbers.end(); ++it) &#123;
        std::cout &lt;&lt; *it &lt;&lt; &quot; &quot;; // Outputs: 1 2 3 4 5
    &#125;
    std::cout &lt;&lt; std::endl;

    return 0;
&#125;
</code></pre>
<h2 id="Algorithms"><a href="#Algorithms" class="headerlink" title="Algorithms"></a>Algorithms</h2><p>STL provides a rich set of algorithms for operations like searching, sorting, and manipulating data. Common algorithms include:</p>
<ul>
<li><strong>Sorting</strong>: <code>std::sort</code></li>
<li><strong>Searching</strong>: <code>std::find</code>, <code>std::binary_search</code></li>
<li><strong>Transforming</strong>: <code>std::transform</code></li>
<li><strong>Manipulating</strong>: <code>std::for_each</code>, <code>std::count_if</code></li>
</ul>
<h3 id="Example-Sorting-and-Searching"><a href="#Example-Sorting-and-Searching" class="headerlink" title="Example: Sorting and Searching"></a>Example: Sorting and Searching</h3><pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;

int main() &#123;
    std::vector&lt;int&gt; numbers = &#123;5, 3, 1, 4, 2&#125;;

    // Sorting the vector
    std::sort(numbers.begin(), numbers.end());

    // Searching for an element
    if (std::find(numbers.begin(), numbers.end(), 3) != numbers.end()) &#123;
        std::cout &lt;&lt; &quot;3 is found in the vector.&quot; &lt;&lt; std::endl

;
    &#125;

    for (const auto&amp; num : numbers) &#123;
        std::cout &lt;&lt; num &lt;&lt; &quot; &quot;; // Outputs: 1 2 3 4 5
    &#125;
    std::cout &lt;&lt; std::endl;

    return 0;
&#125;
</code></pre>
<h2 id="Function-Objects-Functors"><a href="#Function-Objects-Functors" class="headerlink" title="Function Objects (Functors)"></a>Function Objects (Functors)</h2><p>Function objects, or functors, are objects that can be called as if they were functions. They can store state and be passed to algorithms as parameters.</p>
<h3 id="Example-1"><a href="#Example-1" class="headerlink" title="Example:"></a>Example:</h3><pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;

class GreaterThan &#123;
public:
    GreaterThan(int value) : value_(value) &#123;&#125;

    bool operator()(int num) const &#123;
        return num &gt; value_;
    &#125;

private:
    int value_;
&#125;;

int main() &#123;
    std::vector&lt;int&gt; numbers = &#123;1, 2, 3, 4, 5&#125;;

    int count = std::count_if(numbers.begin(), numbers.end(), GreaterThan(2));
    std::cout &lt;&lt; &quot;Count of numbers greater than 2: &quot; &lt;&lt; count &lt;&lt; std::endl; // Outputs: 3

    return 0;
&#125;
</code></pre>
<h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><p>In this chapter, you learned about the Standard Template Library (STL), which provides a wealth of powerful tools for managing data in C++. We covered:</p>
<ul>
<li><strong>Containers</strong>: Different types of data structures for storing elements, including sequence, associative, unordered containers, and container adaptors.</li>
<li><strong>Iterators</strong>: A uniform interface for traversing containers.</li>
<li><strong>Algorithms</strong>: A rich set of functions for manipulating data.</li>
<li><strong>Function Objects (Functors)</strong>: Objects that can be called as functions, allowing for more flexible programming.</li>
</ul>
<p>In the next chapter, we will explore <strong>Error Handling and Exceptions</strong>, where you will learn how to manage errors gracefully in your C++ programs.</p>
<p>Next chapter: <a href="/2024/09/27/cpp-unleash/02h-excpt">Exception Handling</a></p>

            
        </div>
    </div>
    <div class="post-tags">
        
        <span class="icon">
            <i class="fa-solid fa-tags fa-fw"></i>
        </span>
        
        
        
        <span class="tag">
            
            <a href="/tags/c-cpp/" style="color: #03a9f4">c-cpp</a>
        </span>
        
        <span class="tag">
            
            <a href="/tags/modern-cpp/" style="color: #ff7d73">modern-cpp</a>
        </span>
        
        <span class="tag">
            
            <a href="/tags/cpp-unleash/" style="color: #03a9f4">cpp-unleash</a>
        </span>
        
        <span class="tag">
            
            <a href="/tags/02Hero/" style="color: #00bcd4">02Hero</a>
        </span>
        
    </div>
    <a href="/2024/09/27/cpp-unleash/02h-stl/" class="go-post">阅读全文</a>
</div>

<div class="post">
    <a href="/2024/09/27/cpp-unleash/02h-mdncppftr/">
        <h2 class="post-title">C++ Unleashed: Modern C++ Features</h2>
    </a>
    <div class="category-and-date">
        
        <span class="category">
            <a href="/categories/tutor/">
                <span class="icon">
                    <i class="fa-solid fa-bookmark fa-fw"></i>
                </span>
                tutor
            </a>
        </span>
        
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2024/9/27
        </span>
        
        
    </div>
    <div class="description">
        <div class="content" v-pre>
            
            <p><em><strong>C++ Unleashed: From Zero to Hero</strong></em></p>
<p>Previous chapter: <a href="/2024/09/27/cpp-unleash/02h-tplgenpgm">Templates and Generic Programming</a></p>
<p><a href="/2024/09/26/cpp-unleash/02h-menu">Go to Table of Contents</a></p>
<h1 id="Modern-C-Features"><a href="#Modern-C-Features" class="headerlink" title="Modern C++ Features"></a>Modern C++ Features</h1><p>Modern C++ (C++11 and later) introduced a range of features that enhance the language’s expressiveness, performance, and safety. This chapter will cover some of the most important features that you should know to write effective C++ code today.</p>
<p>In this chapter, we’ll discuss:</p>
<ul>
<li>Type Inference with <code>auto</code></li>
<li>Range-Based for Loops</li>
<li>Smart Pointers</li>
<li>Lambda Expressions</li>
<li><code>nullptr</code></li>
<li><code>constexpr</code></li>
<li>Move Semantics</li>
<li>The <code>std::optional</code> Class</li>
</ul>
<h2 id="Type-Inference-with-auto"><a href="#Type-Inference-with-auto" class="headerlink" title="Type Inference with auto"></a>Type Inference with <code>auto</code></h2><p>The <code>auto</code> keyword allows the compiler to automatically deduce the type of a variable at compile time, simplifying code and improving readability.</p>
<h3 id="Example"><a href="#Example" class="headerlink" title="Example:"></a>Example:</h3><pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;

int main() &#123;
    auto x = 42; // x is int
    auto y = 3.14; // y is double
    auto str = &quot;Hello, World!&quot;; // str is const char*

    std::vector&lt;int&gt; vec = &#123;1, 2, 3, 4, 5&#125;;
    auto it = vec.begin(); // it is std::vector&lt;int&gt;::iterator

    std::cout &lt;&lt; &quot;x: &quot; &lt;&lt; x &lt;&lt; &quot;, y: &quot; &lt;&lt; y &lt;&lt; &quot;, str: &quot; &lt;&lt; str &lt;&lt; std::endl;

    return 0;
&#125;
</code></pre>
<h2 id="Range-Based-for-Loops"><a href="#Range-Based-for-Loops" class="headerlink" title="Range-Based for Loops"></a>Range-Based for Loops</h2><p>Range-based for loops provide a more readable way to iterate through containers, eliminating the need for iterators and index-based loops.</p>
<h3 id="Example-1"><a href="#Example-1" class="headerlink" title="Example:"></a>Example:</h3><pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;

int main() &#123;
    std::vector&lt;int&gt; numbers = &#123;1, 2, 3, 4, 5&#125;;

    for (const auto&amp; num : numbers) &#123;
        std::cout &lt;&lt; num &lt;&lt; &quot; &quot;; // Outputs: 1 2 3 4 5
    &#125;
    std::cout &lt;&lt; std::endl;

    return 0;
&#125;
</code></pre>
<h2 id="Smart-Pointers"><a href="#Smart-Pointers" class="headerlink" title="Smart Pointers"></a>Smart Pointers</h2><p>Smart pointers manage the memory of dynamically allocated objects, reducing the risk of memory leaks and dangling pointers. The three main types are:</p>
<ul>
<li><code>std::unique_ptr</code></li>
<li><code>std::shared_ptr</code></li>
<li><code>std::weak_ptr</code></li>
</ul>
<h3 id="Example-std-unique-ptr"><a href="#Example-std-unique-ptr" class="headerlink" title="Example: std::unique_ptr"></a>Example: <code>std::unique_ptr</code></h3><pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;memory&gt;

class MyClass &#123;
public:
    MyClass() &#123; std::cout &lt;&lt; &quot;Constructor&quot; &lt;&lt; std::endl; &#125;
    ~MyClass() &#123; std::cout &lt;&lt; &quot;Destructor&quot; &lt;&lt; std::endl; &#125;
&#125;;

int main() &#123;
    std::unique_ptr&lt;MyClass&gt; ptr = std::make_unique&lt;MyClass&gt;();
    // No need to manually delete; memory is automatically managed

    return 0;
&#125;
</code></pre>
<h3 id="Example-std-shared-ptr"><a href="#Example-std-shared-ptr" class="headerlink" title="Example: std::shared_ptr"></a>Example: <code>std::shared_ptr</code></h3><pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;memory&gt;

class MyClass &#123;
public:
    MyClass() &#123; std::cout &lt;&lt; &quot;Constructor&quot; &lt;&lt; std::endl; &#125;
    ~MyClass() &#123; std::cout &lt;&lt; &quot;Destructor&quot; &lt;&lt; std::endl; &#125;
&#125;;

int main() &#123;
    std::shared_ptr&lt;MyClass&gt; ptr1 = std::make_shared&lt;MyClass&gt;();
    &#123;
        std::shared_ptr&lt;MyClass&gt; ptr2 = ptr1; // Both share ownership
    &#125; // Destructor called when ptr2 goes out of scope

    return 0;
&#125;
</code></pre>
<h2 id="Lambda-Expressions"><a href="#Lambda-Expressions" class="headerlink" title="Lambda Expressions"></a>Lambda Expressions</h2><p>Lambda expressions provide a concise way to define anonymous functions directly within your code, enabling inline function definitions.</p>
<h3 id="Syntax"><a href="#Syntax" class="headerlink" title="Syntax:"></a>Syntax:</h3><pre><code class="cpp">[capture](parameters) -&gt; return_type &#123;
    // Function body
&#125;
</code></pre>
<h3 id="Example-2"><a href="#Example-2" class="headerlink" title="Example:"></a>Example:</h3><pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;

int main() &#123;
    std::vector&lt;int&gt; numbers = &#123;1, 2, 3, 4, 5&#125;;

    // Lambda to print each number
    std::for_each(numbers.begin(), numbers.end(), [](int n) &#123;
        std::cout &lt;&lt; n &lt;&lt; &quot; &quot;;
    &#125;);
    std::cout &lt;&lt; std::endl;

    // Lambda to filter even numbers
    auto is_even = [](int n) &#123; return n % 2 == 0; &#125;;
    auto count = std::count_if(numbers.begin(), numbers.end(), is_even);
    std::cout &lt;&lt; &quot;Count of even numbers: &quot; &lt;&lt; count &lt;&lt; std::endl;

    return 0;
&#125;
</code></pre>
<h2 id="nullptr"><a href="#nullptr" class="headerlink" title="nullptr"></a><code>nullptr</code></h2><p><code>nullptr</code> is a null pointer constant introduced in C++11, replacing the old <code>NULL</code> macro. It provides a type-safe way to represent null pointers.</p>
<h3 id="Example-3"><a href="#Example-3" class="headerlink" title="Example:"></a>Example:</h3><pre><code class="cpp">#include &lt;iostream&gt;

void func(int* ptr) &#123;
    if (ptr == nullptr) &#123;
        std::cout &lt;&lt; &quot;Pointer is null.&quot; &lt;&lt; std::endl;
    &#125;
&#125;

int main() &#123;
    int* p = nullptr; // Safe null pointer
    func(p);

    return 0;
&#125;
</code></pre>
<h2 id="constexpr"><a href="#constexpr" class="headerlink" title="constexpr"></a><code>constexpr</code></h2><p>The <code>constexpr</code> keyword allows you to define functions and variables that can be evaluated at compile time, improving performance and enabling more powerful compile-time computations.</p>
<h3 id="Example-4"><a href="#Example-4" class="headerlink" title="Example:"></a>Example:</h3><pre><code class="cpp">#include &lt;iostream&gt;

constexpr int square(int x) &#123;
    return x * x;
&#125;

int main() &#123;
    constexpr int result = square(5); // Computed at compile time
    std::cout &lt;&lt; &quot;Square of 5 is: &quot; &lt;&lt; result &lt;&lt; std::endl;

    return 0;
&#125;
</code></pre>
<h2 id="Move-Semantics"><a href="#Move-Semantics" class="headerlink" title="Move Semantics"></a>Move Semantics</h2><p>Move semantics allow the resources of temporary objects to be transferred rather than copied, enhancing performance. This is particularly useful for objects with dynamic memory allocation.</p>
<h3 id="Example-5"><a href="#Example-5" class="headerlink" title="Example:"></a>Example:</h3><pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;

class MyVector &#123;
private:
    std::vector&lt;int&gt; data;

public:
    MyVector(std::initializer_list&lt;int&gt; init) : data(init) &#123;&#125;

    // Move constructor
    MyVector(MyVector&amp;&amp; other) noexcept : data(std::move(other.data)) &#123;&#125;

    void display() const &#123;
        for (const auto&amp; val : data) &#123;
            std::cout &lt;&lt; val &lt;&lt; &quot; &quot;;
        &#125;
        std::cout &lt;&lt; std::endl;
    &#125;
&#125;;

int main() &#123;
    MyVector v1 = &#123;1, 2, 3, 4, 5&#125;;
    MyVector v2 = std::move(v1); // Move v1 into v2

    v2.display(); // Outputs: 1 2 3 4 5
    return 0;
&#125;
</code></pre>
<h2 id="The-std-optional-Class"><a href="#The-std-optional-Class" class="headerlink" title="The std::optional Class"></a>The <code>std::optional</code> Class</h2><p><code>std::optional</code> is a utility that represents an optional value that may or may not be present, offering a safer alternative to using pointers or other methods to signify optionality.</p>
<h3 id="Example-6"><a href="#Example-6" class="headerlink" title="Example:"></a>Example:</h3><pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;optional&gt;

std::optional&lt;int&gt; findValue(bool shouldFind) &#123;
    if (shouldFind) &#123;
        return 42; // Optional value is present
    &#125;
    return std::nullopt; // No value present
&#125;

int main() &#123;
    auto value = findValue(true);
    if (value) &#123;
        std::cout &lt;&lt; &quot;Found value: &quot; &lt;&lt; *value &lt;&lt; std::endl; // Dereference
    &#125; else &#123;
        std::cout &lt;&lt; &quot;No value found.&quot; &lt;&lt; std::endl;
    &#125;

    return 0;
&#125;
</code></pre>
<h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><p>In this chapter, you learned about important features introduced in modern C++:</p>
<ul>
<li><strong>Type Inference with <code>auto</code>:</strong> Automatically deducing variable types.</li>
<li><strong>Range-Based for Loops:</strong> Simplifying iterations over containers.</li>
<li><strong>Smart Pointers:</strong> Managing memory safely and efficiently.</li>
<li><strong>Lambda Expressions:</strong> Defining anonymous functions inline.</li>
<li><strong><code>nullptr</code>:</strong> A type-safe null pointer constant.</li>
<li><strong><code>constexpr</code>:</strong> Enabling compile-time computation for functions and variables.</li>
<li><strong>Move Semantics:</strong> Optimizing resource management for temporary objects.</li>
<li><strong><code>std::optional</code>:</strong> Representing values that may or may not be present.</li>
</ul>
<p>These features make modern C++ more powerful, expressive, and safer, helping you write better code with less risk of errors. In the next chapter, we will delve into <strong>Standard Template Library (STL)</strong>, exploring its containers, algorithms, and iterators.</p>
<p>Next chapter: <a href="/2024/09/27/cpp-unleash/02h-stl">Standard Template Library (STL)</a></p>

            
        </div>
    </div>
    <div class="post-tags">
        
        <span class="icon">
            <i class="fa-solid fa-tags fa-fw"></i>
        </span>
        
        
        
        <span class="tag">
            
            <a href="/tags/c-cpp/" style="color: #00a596">c-cpp</a>
        </span>
        
        <span class="tag">
            
            <a href="/tags/modern-cpp/" style="color: #ffa2c4">modern-cpp</a>
        </span>
        
        <span class="tag">
            
            <a href="/tags/cpp-unleash/" style="color: #ff7d73">cpp-unleash</a>
        </span>
        
        <span class="tag">
            
            <a href="/tags/02Hero/" style="color: #ffa2c4">02Hero</a>
        </span>
        
    </div>
    <a href="/2024/09/27/cpp-unleash/02h-mdncppftr/" class="go-post">阅读全文</a>
</div>

<div class="post">
    <a href="/2024/09/27/cpp-unleash/02h-tplgenpgm/">
        <h2 class="post-title">C++ Unleashed: Templates and Generic Programming</h2>
    </a>
    <div class="category-and-date">
        
        <span class="category">
            <a href="/categories/tutor/">
                <span class="icon">
                    <i class="fa-solid fa-bookmark fa-fw"></i>
                </span>
                tutor
            </a>
        </span>
        
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2024/9/27
        </span>
        
        
    </div>
    <div class="description">
        <div class="content" v-pre>
            
            <p><em><strong>C++ Unleashed: From Zero to Hero</strong></em></p>
<p>Previous chapter: <a href="/2024/09/27/cpp-unleash/02h-oop">Object-Oriented Programming</a></p>
<p><a href="/2024/09/26/cpp-unleash/02h-menu">Go to Table of Contents</a></p>
<h1 id="Templates-and-Generic-Programming"><a href="#Templates-and-Generic-Programming" class="headerlink" title="Templates and Generic Programming"></a>Templates and Generic Programming</h1><p>Templates and generic programming are powerful features in C++ that allow you to write flexible and reusable code. Templates enable functions and classes to operate with generic types, making your programs more abstract and adaptable.</p>
<p>In this chapter, we’ll cover:</p>
<ul>
<li>Function Templates</li>
<li>Class Templates</li>
<li>Template Specialization</li>
<li>Variadic Templates</li>
<li>Concepts (C++20)</li>
</ul>
<h2 id="Function-Templates"><a href="#Function-Templates" class="headerlink" title="Function Templates"></a>Function Templates</h2><p>Function templates allow you to write a single function that works with any data type.</p>
<h3 id="Basic-Syntax"><a href="#Basic-Syntax" class="headerlink" title="Basic Syntax"></a>Basic Syntax</h3><pre><code class="cpp">template &lt;typename T&gt;
ReturnType FunctionName(T parameter) &#123;
    // Function body
&#125;
</code></pre>
<ul>
<li><strong><code>template &lt;typename T&gt;</code></strong>: Introduces a template parameter <code>T</code>.</li>
<li><strong><code>T</code></strong>: Represents a generic data type.</li>
</ul>
<h3 id="Example-Generic-Swap-Function"><a href="#Example-Generic-Swap-Function" class="headerlink" title="Example: Generic Swap Function"></a>Example: Generic Swap Function</h3><pre><code class="cpp">template &lt;typename T&gt;
void swapValues(T&amp; a, T&amp; b) &#123;
    T temp = a;
    a = b;
    b = temp;
&#125;
</code></pre>
<p><strong>Usage:</strong></p>
<pre><code class="cpp">int main() &#123;
    int x = 10, y = 20;
    swapValues(x, y);

    double a = 1.5, b = 2.5;
    swapValues(a, b);

    return 0;
&#125;
</code></pre>
<h3 id="Function-Templates-with-Multiple-Parameters"><a href="#Function-Templates-with-Multiple-Parameters" class="headerlink" title="Function Templates with Multiple Parameters"></a>Function Templates with Multiple Parameters</h3><p>You can have multiple template parameters.</p>
<pre><code class="cpp">template &lt;typename T1, typename T2&gt;
auto add(T1 a, T2 b) -&gt; decltype(a + b) &#123;
    return a + b;
&#125;
</code></pre>
<p><strong>Usage:</strong></p>
<pre><code class="cpp">int main() &#123;
    auto result = add(5, 3.2); // result is of type double
    return 0;
&#125;
</code></pre>
<h3 id="Template-Argument-Deduction"><a href="#Template-Argument-Deduction" class="headerlink" title="Template Argument Deduction"></a>Template Argument Deduction</h3><p>The compiler automatically deduces the template arguments based on the function arguments.</p>
<p><strong>Explicit Template Arguments:</strong></p>
<pre><code class="cpp">swapValues&lt;int&gt;(x, y);
</code></pre>
<ul>
<li>Usually not necessary unless deduction fails.</li>
</ul>
<h2 id="Class-Templates"><a href="#Class-Templates" class="headerlink" title="Class Templates"></a>Class Templates</h2><p>Class templates allow you to define a class with generic types.</p>
<h3 id="Basic-Syntax-1"><a href="#Basic-Syntax-1" class="headerlink" title="Basic Syntax"></a>Basic Syntax</h3><pre><code class="cpp">template &lt;typename T&gt;
class ClassName &#123;
public:
    // Member functions and variables using T
&#125;;
</code></pre>
<h3 id="Example-Generic-Array-Class"><a href="#Example-Generic-Array-Class" class="headerlink" title="Example: Generic Array Class"></a>Example: Generic Array Class</h3><pre><code class="cpp">template &lt;typename T, size_t N&gt;
class Array &#123;
private:
    T data[N];

public:
    void set(size_t index, const T&amp; value) &#123;
        if (index &lt; N) &#123;
            data[index] = value;
        &#125;
    &#125;

    T&amp; get(size_t index) &#123;
        if (index &lt; N) &#123;
            return data[index];
        &#125;
        throw std::out_of_range(&quot;Index out of range&quot;);
    &#125;

    size_t size() const &#123;
        return N;
    &#125;
&#125;;
</code></pre>
<p><strong>Usage:</strong></p>
<pre><code class="cpp">int main() &#123;
    Array&lt;int, 5&gt; intArray;
    intArray.set(0, 10);
    intArray.set(1, 20);

    std::cout &lt;&lt; intArray.get(0) &lt;&lt; std::endl; // Outputs 10
    std::cout &lt;&lt; intArray.get(1) &lt;&lt; std::endl; // Outputs 20

    return 0;
&#125;
</code></pre>
<h3 id="Member-Function-Definitions-Outside-the-Class"><a href="#Member-Function-Definitions-Outside-the-Class" class="headerlink" title="Member Function Definitions Outside the Class"></a>Member Function Definitions Outside the Class</h3><p>When defining member functions outside the class, include the template parameters.</p>
<pre><code class="cpp">template &lt;typename T, size_t N&gt;
void Array&lt;T, N&gt;::set(size_t index, const T&amp; value) &#123;
    // Function body
&#125;
</code></pre>
<h2 id="Template-Specialization"><a href="#Template-Specialization" class="headerlink" title="Template Specialization"></a>Template Specialization</h2><p>Template specialization allows you to define a custom implementation of a template for a specific type.</p>
<h3 id="Full-Specialization"><a href="#Full-Specialization" class="headerlink" title="Full Specialization"></a>Full Specialization</h3><p>Providing a completely different implementation for a specific type.</p>
<p><strong>Example:</strong></p>
<pre><code class="cpp">template &lt;typename T&gt;
class TypeInfo &#123;
public:
    static std::string name() &#123;
        return &quot;Unknown&quot;;
    &#125;
&#125;;

// Specialization for int
template &lt;&gt;
class TypeInfo&lt;int&gt; &#123;
public:
    static std::string name() &#123;
        return &quot;Integer&quot;;
    &#125;
&#125;;

// Specialization for double
template &lt;&gt;
class TypeInfo&lt;double&gt; &#123;
public:
    static std::string name() &#123;
        return &quot;Double&quot;;
    &#125;
&#125;;
</code></pre>
<p><strong>Usage:</strong></p>
<pre><code class="cpp">int main() &#123;
    std::cout &lt;&lt; TypeInfo&lt;char&gt;::name() &lt;&lt; std::endl;    // Outputs &quot;Unknown&quot;
    std::cout &lt;&lt; TypeInfo&lt;int&gt;::name() &lt;&lt; std::endl;     // Outputs &quot;Integer&quot;
    std::cout &lt;&lt; TypeInfo&lt;double&gt;::name() &lt;&lt; std::endl;  // Outputs &quot;Double&quot;

    return 0;
&#125;
</code></pre>
<h3 id="Partial-Specialization"><a href="#Partial-Specialization" class="headerlink" title="Partial Specialization"></a>Partial Specialization</h3><p>Specializing a template for a subset of types.</p>
<p><strong>Example:</strong></p>
<pre><code class="cpp">template &lt;typename T, typename U&gt;
class Pair &#123;
public:
    T first;
    U second;
&#125;;

// Partial specialization when both types are the same
template &lt;typename T&gt;
class Pair&lt;T, T&gt; &#123;
public:
    T first;
    T second;

    void display() &#123;
        std::cout &lt;&lt; &quot;Pair of &quot; &lt;&lt; typeid(T).name() &lt;&lt; std::endl;
    &#125;
&#125;;
</code></pre>
<p><strong>Usage:</strong></p>
<pre><code class="cpp">int main() &#123;
    Pair&lt;int, double&gt; p1;
    Pair&lt;int, int&gt; p2;
    p2.display(); // Uses the specialized version

    return 0;
&#125;
</code></pre>
<h2 id="Variadic-Templates"><a href="#Variadic-Templates" class="headerlink" title="Variadic Templates"></a>Variadic Templates</h2><p>Variadic templates allow functions and classes to accept an arbitrary number of template parameters.</p>
<h3 id="Function-Variadic-Templates"><a href="#Function-Variadic-Templates" class="headerlink" title="Function Variadic Templates"></a>Function Variadic Templates</h3><p><strong>Example: Print Function</strong></p>
<pre><code class="cpp">void print() &#123;
    std::cout &lt;&lt; std::endl;
&#125;

template &lt;typename T, typename... Args&gt;
void print(T first, Args... args) &#123;
    std::cout &lt;&lt; first &lt;&lt; &quot; &quot;;
    print(args...);
&#125;
</code></pre>
<p><strong>Usage:</strong></p>
<pre><code class="cpp">int main() &#123;
    print(1, 2.5, &quot;Hello&quot;, &#39;A&#39;); // Outputs: 1 2.5 Hello A

    return 0;
&#125;
</code></pre>
<p><strong>Explanation:</strong></p>
<ul>
<li>The <code>print</code> function recursively unpacks the arguments.</li>
<li>The base case is the <code>print()</code> function with no parameters.</li>
</ul>
<h3 id="Class-Variadic-Templates"><a href="#Class-Variadic-Templates" class="headerlink" title="Class Variadic Templates"></a>Class Variadic Templates</h3><p><strong>Example: Tuple Class</strong></p>
<pre><code class="cpp">template &lt;typename... Types&gt;
class Tuple &#123;
    // Implementation
&#125;;
</code></pre>
<p><strong>Using <code>std::tuple</code></strong></p>
<p>The Standard Library provides <code>std::tuple</code>, a variadic template class.</p>
<pre><code class="cpp">#include &lt;tuple&gt;

int main() &#123;
    std::tuple&lt;int, double, std::string&gt; t(1, 2.5, &quot;Hello&quot;);

    int i = std::get&lt;0&gt;(t);
    double d = std::get&lt;1&gt;(t);
    std::string s = std::get&lt;2&gt;(t);

    return 0;
&#125;
</code></pre>
<h2 id="Concepts-C-20"><a href="#Concepts-C-20" class="headerlink" title="Concepts (C++20)"></a>Concepts (C++20)</h2><p>Concepts provide a way to specify template requirements, improving readability and error messages.</p>
<h3 id="Basic-Syntax-2"><a href="#Basic-Syntax-2" class="headerlink" title="Basic Syntax"></a>Basic Syntax</h3><pre><code class="cpp">template &lt;typename T&gt;
concept ConceptName = requires(T a) &#123;
    // Expressions and requirements
&#125;;
</code></pre>
<h3 id="Example-Numeric-Concept"><a href="#Example-Numeric-Concept" class="headerlink" title="Example: Numeric Concept"></a>Example: Numeric Concept</h3><pre><code class="cpp">#include &lt;concepts&gt;

template &lt;typename T&gt;
concept Numeric = std::is_arithmetic_v&lt;T&gt;;

template &lt;Numeric T&gt;
T add(T a, T b) &#123;
    return a + b;
&#125;
</code></pre>
<p><strong>Usage:</strong></p>
<pre><code class="cpp">int main() &#123;
    int result = add(5, 10);       // OK
    // std::string s = add(&quot;a&quot;, &quot;b&quot;); // Error: std::string is not Numeric

    return 0;
&#125;
</code></pre>
<h3 id="Using-requires-Clauses"><a href="#Using-requires-Clauses" class="headerlink" title="Using requires Clauses"></a>Using <code>requires</code> Clauses</h3><pre><code class="cpp">template &lt;typename T&gt;
requires std::is_integral_v&lt;T&gt;
T factorial(T n) &#123;
    return (n &lt;= 1) ? 1 : n * factorial(n - 1);
&#125;
</code></pre>
<h3 id="Standard-Library-Concepts"><a href="#Standard-Library-Concepts" class="headerlink" title="Standard Library Concepts"></a>Standard Library Concepts</h3><ul>
<li><strong><code>std::integral</code></strong></li>
<li><strong><code>std::floating_point</code></strong></li>
<li><strong><code>std::signed_integral</code></strong></li>
<li><strong><code>std::unsigned_integral</code></strong></li>
<li><strong><code>std::default_initializable</code></strong></li>
</ul>
<p><strong>Example:</strong></p>
<pre><code class="cpp">#include &lt;concepts&gt;

template &lt;std::integral T&gt;
T gcd(T a, T b) &#123;
    while (b != 0) &#123;
        T temp = b;
        b = a % b;
        a = temp;
    &#125;
    return a;
&#125;
</code></pre>
<h2 id="Practical-Example-Generic-Sorting-Function"><a href="#Practical-Example-Generic-Sorting-Function" class="headerlink" title="Practical Example: Generic Sorting Function"></a>Practical Example: Generic Sorting Function</h2><p>Let’s create a generic sorting function using templates.</p>
<pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;

template &lt;typename T&gt;
void sortVector(std::vector&lt;T&gt;&amp; vec) &#123;
    std::sort(vec.begin(), vec.end());
&#125;

int main() &#123;
    std::vector&lt;int&gt; intVec = &#123;5, 2, 9, 1, 5&#125;;
    sortVector(intVec);

    for (const auto&amp; val : intVec) &#123;
        std::cout &lt;&lt; val &lt;&lt; &quot; &quot;; // Outputs: 1 2 5 5 9
    &#125;
    std::cout &lt;&lt; std::endl;

    std::vector&lt;std::string&gt; strVec = &#123;&quot;apple&quot;, &quot;orange&quot;, &quot;banana&quot;&#125;;
    sortVector(strVec);

    for (const auto&amp; val : strVec) &#123;
        std::cout &lt;&lt; val &lt;&lt; &quot; &quot;; // Outputs: apple banana orange
    &#125;
    std::cout &lt;&lt; std::endl;

    return 0;
&#125;
</code></pre>
<h2 id="Exercises"><a href="#Exercises" class="headerlink" title="Exercises"></a>Exercises</h2><ol>
<li><p><strong>Generic Max Function</strong></p>
<p>Write a function template <code>maxValue</code> that returns the maximum of two values.</p>
<pre><code class="cpp">template &lt;typename T&gt;
T maxValue(const T&amp; a, const T&amp; b) &#123;
    return (a &gt; b) ? a : b;
&#125;
</code></pre>
</li>
<li><p><strong>Stack Class Template</strong></p>
<p>Implement a simple stack class template.</p>
<pre><code class="cpp">template &lt;typename T&gt;
class Stack &#123;
private:
    std::vector&lt;T&gt; elements;

public:
    void push(const T&amp; item) &#123;
        elements.push_back(item);
    &#125;

    void pop() &#123;
        if (!elements.empty()) &#123;
            elements.pop_back();
        &#125;
    &#125;

    T&amp; top() &#123;
        return elements.back();
    &#125;

    bool isEmpty() const &#123;
        return elements.empty();
    &#125;
&#125;;
</code></pre>
<p><strong>Usage:</strong></p>
<pre><code class="cpp">int main() &#123;
    Stack&lt;int&gt; intStack;
    intStack.push(1);
    intStack.push(2);
    intStack.push(3);

    while (!intStack.isEmpty()) &#123;
        std::cout &lt;&lt; intStack.top() &lt;&lt; &quot; &quot;;
        intStack.pop();
    &#125;
    // Outputs: 3 2 1

    return 0;
&#125;
</code></pre>
</li>
<li><p><strong>Function Variadic Template</strong></p>
<p>Create a variadic template function <code>sum</code> that calculates the sum of all its arguments.</p>
<pre><code class="cpp">template &lt;typename T&gt;
T sum(T value) &#123;
    return value;
&#125;

template &lt;typename T, typename... Args&gt;
T sum(T first, Args... args) &#123;
    return first + sum(args...);
&#125;
</code></pre>
<p><strong>Usage:</strong></p>
<pre><code class="cpp">int main() &#123;
    auto result = sum(1, 2, 3, 4, 5); // result = 15

    std::cout &lt;&lt; &quot;Sum: &quot; &lt;&lt; result &lt;&lt; std::endl;

    return 0;
&#125;
</code></pre>
</li>
</ol>
<h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><p>In this chapter, you’ve learned about:</p>
<ul>
<li><p><strong>Function Templates:</strong></p>
<ul>
<li>Writing generic functions that work with any data type.</li>
<li>Template argument deduction and multiple template parameters.</li>
</ul>
</li>
<li><p><strong>Class Templates:</strong></p>
<ul>
<li>Creating generic classes to handle data of any type.</li>
<li>Implementing member functions inside and outside the class.</li>
</ul>
</li>
<li><p><strong>Template Specialization:</strong></p>
<ul>
<li>Customizing templates for specific types using full and partial specialization.</li>
</ul>
</li>
<li><p><strong>Variadic Templates:</strong></p>
<ul>
<li>Writing functions and classes that accept an arbitrary number of template arguments.</li>
<li>Implementing recursive functions to process variadic arguments.</li>
</ul>
</li>
<li><p><strong>Concepts (C++20):</strong></p>
<ul>
<li>Defining template requirements using concepts.</li>
<li>Using standard library concepts and <code>requires</code> clauses for constraints.</li>
</ul>
</li>
</ul>
<p>Templates and generic programming enable you to write flexible and reusable code, reducing redundancy and improving maintainability. Mastery of these features allows you to create powerful abstractions and efficient libraries.</p>
<hr>
<p>In the next chapter, we’ll explore <strong>Modern C++ Features</strong>, including type deduction, range-based loops, and other enhancements that make C++ programming more expressive and safer.</p>
<p>Next chapter: <a href="/2024/09/27/cpp-unleash/02h-mdncppftr">Modern C++ Features</a></p>

            
        </div>
    </div>
    <div class="post-tags">
        
        <span class="icon">
            <i class="fa-solid fa-tags fa-fw"></i>
        </span>
        
        
        
        <span class="tag">
            
            <a href="/tags/c-cpp/" style="color: #ff7d73">c-cpp</a>
        </span>
        
        <span class="tag">
            
            <a href="/tags/modern-cpp/" style="color: #03a9f4">modern-cpp</a>
        </span>
        
        <span class="tag">
            
            <a href="/tags/cpp-unleash/" style="color: #00a596">cpp-unleash</a>
        </span>
        
        <span class="tag">
            
            <a href="/tags/02Hero/" style="color: #03a9f4">02Hero</a>
        </span>
        
    </div>
    <a href="/2024/09/27/cpp-unleash/02h-tplgenpgm/" class="go-post">阅读全文</a>
</div>

<div class="post">
    <a href="/2024/09/27/cpp-unleash/02h-oop/">
        <h2 class="post-title">C++ Unleashed: Object-Oriented Programming</h2>
    </a>
    <div class="category-and-date">
        
        <span class="category">
            <a href="/categories/tutor/">
                <span class="icon">
                    <i class="fa-solid fa-bookmark fa-fw"></i>
                </span>
                tutor
            </a>
        </span>
        
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2024/9/27
        </span>
        
        
    </div>
    <div class="description">
        <div class="content" v-pre>
            
            <p><em><strong>C++ Unleashed: From Zero to Hero</strong></em></p>
<p>Previous chapter: <a href="/2024/09/26/cpp-unleash/02h-arystr">Pointers and References</a></p>
<p><a href="/2024/09/26/cpp-unleash/02h-menu">Go to Table of Contents</a></p>
<h1 id="Object-Oriented-Programming"><a href="#Object-Oriented-Programming" class="headerlink" title="Object-Oriented Programming"></a>Object-Oriented Programming</h1><p><strong>Object-Oriented Programming (OOP)</strong> is a cornerstone of C++ programming, enabling developers to model complex systems through classes and objects. This chapter delves into the essential principles of OOP, providing a solid foundation for building robust and maintainable applications.</p>
<h2 id="Table-of-Contents-for-This-Chapter"><a href="#Table-of-Contents-for-This-Chapter" class="headerlink" title="Table of Contents for This Chapter"></a>Table of Contents for This Chapter</h2><ol>
<li><a href="#classes-and-objects">Classes and Objects</a></li>
<li><a href="#constructors-and-destructors">Constructors and Destructors</a></li>
<li><a href="#copy-and-move-semantics">Copy and Move Semantics</a></li>
<li><a href="#inheritance-and-polymorphism">Inheritance and Polymorphism</a></li>
<li><a href="#operator-overloading">Operator Overloading</a></li>
<li><a href="#union-and-struct-as-special-classes">Union and Struct as Special Classes</a></li>
<li><a href="#type-conversions">Type Conversions</a></li>
<li><a href="#variable-modifiers-const-static-mutable-volatile">Variable Modifiers (<code>const</code>, <code>static</code>, <code>mutable</code>, <code>volatile</code>)</a></li>
<li><a href="#virtual-functions-and-abstract-classes">Virtual Functions and Abstract Classes</a></li>
</ol>
<hr>
<h2 id="Classes-and-Objects"><a href="#Classes-and-Objects" class="headerlink" title="Classes and Objects"></a>Classes and Objects</h2><h3 id="What-Are-Classes-and-Objects"><a href="#What-Are-Classes-and-Objects" class="headerlink" title="What Are Classes and Objects?"></a>What Are Classes and Objects?</h3><ul>
<li><strong>Class</strong>: A blueprint for creating objects. It encapsulates data for the object and methods to manipulate that data.</li>
<li><strong>Object</strong>: An instance of a class. It represents a specific entity with its own state and behavior as defined by the class.</li>
</ul>
<h3 id="Defining-a-Class"><a href="#Defining-a-Class" class="headerlink" title="Defining a Class"></a>Defining a Class</h3><p>To define a class in C++, use the <code>class</code> keyword followed by the class name and a pair of curly braces <code>&#123;&#125;</code> enclosing its members.</p>
<p><strong>Syntax:</strong></p>
<pre><code class="cpp">class ClassName &#123;
public:
    // Public members
private:
    // Private members
protected:
    // Protected members
&#125;;
</code></pre>
<h3 id="Example-Defining-and-Using-a-Class"><a href="#Example-Defining-and-Using-a-Class" class="headerlink" title="Example: Defining and Using a Class"></a>Example: Defining and Using a Class</h3><pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;string&gt;

// Definition of the Person class
class Person &#123;
public:
    // Public member variables
    std::string name;
    int age;

    // Public member function
    void introduce() const &#123;
        std::cout &lt;&lt; &quot;Hello, my name is &quot; &lt;&lt; name 
                  &lt;&lt; &quot; and I am &quot; &lt;&lt; age &lt;&lt; &quot; years old.&quot; &lt;&lt; std::endl;
    &#125;

private:
    // Private member variable
    std::string secret;
&#125;;

int main() &#123;
    // Creating an object of the Person class
    Person person1;
    person1.name = &quot;Alice&quot;;
    person1.age = 30;
    
    // Calling a member function
    person1.introduce();

    return 0;
&#125;
</code></pre>
<p><strong>Output:</strong></p>
<pre><code>Hello, my name is Alice and I am 30 years old.
</code></pre>
<h3 id="Access-Specifiers"><a href="#Access-Specifiers" class="headerlink" title="Access Specifiers"></a>Access Specifiers</h3><ul>
<li><strong>public</strong>: Members are accessible from outside the class.</li>
<li><strong>private</strong>: Members are accessible only within the class.</li>
<li><strong>protected</strong>: Members are accessible within the class and by derived classes.</li>
</ul>
<p><strong>Example:</strong></p>
<pre><code class="cpp">class Example &#123;
public:
    int publicVar; // Accessible from anywhere

private:
    int privateVar; // Accessible only within the class

protected:
    int protectedVar; // Accessible within the class and derived classes
&#125;;
</code></pre>
<hr>
<h2 id="Constructors-and-Destructors"><a href="#Constructors-and-Destructors" class="headerlink" title="Constructors and Destructors"></a>Constructors and Destructors</h2><h3 id="Constructors"><a href="#Constructors" class="headerlink" title="Constructors"></a>Constructors</h3><p>Constructors are special member functions that are called when an object is created. They initialize the object’s data members and allocate resources if necessary.</p>
<p><strong>Types of Constructors:</strong></p>
<ol>
<li><strong>Default Constructor</strong>: Takes no arguments.</li>
<li><strong>Parameterized Constructor</strong>: Takes parameters to initialize the object.</li>
<li><strong>Copy Constructor</strong>: Creates a new object as a copy of an existing object.</li>
<li><strong>Move Constructor</strong>: Transfers resources from a temporary object to a new object.</li>
</ol>
<p><strong>Example:</strong></p>
<pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;string&gt;

class Person &#123;
public:
    // Default constructor
    Person() : name(&quot;Unknown&quot;), age(0) &#123;
        std::cout &lt;&lt; &quot;Default constructor called.&quot; &lt;&lt; std::endl;
    &#125;

    // Parameterized constructor
    Person(const std::string&amp; personName, int personAge) 
        : name(personName), age(personAge) &#123;
        std::cout &lt;&lt; &quot;Parameterized constructor called.&quot; &lt;&lt; std::endl;
    &#125;

    // Copy constructor
    Person(const Person&amp; other) 
        : name(other.name), age(other.age) &#123;
        std::cout &lt;&lt; &quot;Copy constructor called.&quot; &lt;&lt; std::endl;
    &#125;

    // Move constructor
    Person(Person&amp;&amp; other) noexcept 
        : name(std::move(other.name)), age(other.age) &#123;
        std::cout &lt;&lt; &quot;Move constructor called.&quot; &lt;&lt; std::endl;
    &#125;

    // Display information
    void display() const &#123;
        std::cout &lt;&lt; &quot;Name: &quot; &lt;&lt; name &lt;&lt; &quot;, Age: &quot; &lt;&lt; age &lt;&lt; std::endl;
    &#125;

private:
    std::string name;
    int age;
&#125;;

int main() &#123;
    Person p1; // Default constructor
    p1.display();

    Person p2(&quot;Alice&quot;, 30); // Parameterized constructor
    p2.display();

    Person p3 = p2; // Copy constructor
    p3.display();

    Person p4 = std::move(p2); // Move constructor
    p4.display();

    return 0;
&#125;
</code></pre>
<p><strong>Output:</strong></p>
<pre><code>Default constructor called.
Name: Unknown, Age: 0
Parameterized constructor called.
Name: Alice, Age: 30
Copy constructor called.
Name: Alice, Age: 30
Move constructor called.
Name: Alice, Age: 30
</code></pre>
<h3 id="Destructors"><a href="#Destructors" class="headerlink" title="Destructors"></a>Destructors</h3><p>Destructors are special member functions that are called when an object is destroyed. They are used to release resources allocated to the object and perform any necessary cleanup.</p>
<p><strong>Syntax:</strong></p>
<pre><code class="cpp">~ClassName() &#123;
    // Cleanup code
&#125;
</code></pre>
<p><strong>Example:</strong></p>
<pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;string&gt;

class Resource &#123;
public:
    // Constructor
    Resource(const std::string&amp; resourceName) : name(resourceName) &#123;
        std::cout &lt;&lt; &quot;Resource &quot; &lt;&lt; name &lt;&lt; &quot; acquired.&quot; &lt;&lt; std::endl;
    &#125;

    // Destructor
    ~Resource() &#123;
        std::cout &lt;&lt; &quot;Resource &quot; &lt;&lt; name &lt;&lt; &quot; released.&quot; &lt;&lt; std::endl;
    &#125;

private:
    std::string name;
&#125;;

int main() &#123;
    &#123;
        Resource res1(&quot;FileHandle&quot;);
        Resource res2(&quot;NetworkSocket&quot;);
    &#125; // res1 and res2 go out of scope here

    return 0;
&#125;
</code></pre>
<p><strong>Output:</strong></p>
<pre><code>Resource FileHandle acquired.
Resource NetworkSocket acquired.
Resource NetworkSocket released.
Resource FileHandle released.
</code></pre>
<hr>
<h2 id="Copy-and-Move-Semantics"><a href="#Copy-and-Move-Semantics" class="headerlink" title="Copy and Move Semantics"></a>Copy and Move Semantics</h2><h3 id="Copy-Semantics"><a href="#Copy-Semantics" class="headerlink" title="Copy Semantics"></a>Copy Semantics</h3><p>Copy semantics involve creating a new object as a copy of an existing object. This is typically handled by the copy constructor and copy assignment operator.</p>
<p><strong>Copy Constructor:</strong></p>
<pre><code class="cpp">ClassName(const ClassName&amp; other);
</code></pre>
<p><strong>Copy Assignment Operator:</strong></p>
<pre><code class="cpp">ClassName&amp; operator=(const ClassName&amp; other);
</code></pre>
<p><strong>Example:</strong></p>
<pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;string&gt;

class Box &#123;
public:
    // Parameterized constructor
    Box(double w, double h, double d) : width(w), height(h), depth(d) &#123;&#125;

    // Copy constructor
    Box(const Box&amp; other) 
        : width(other.width), height(other.height), depth(other.depth) &#123;
        std::cout &lt;&lt; &quot;Copy constructor called.&quot; &lt;&lt; std::endl;
    &#125;

    // Display dimensions
    void display() const &#123;
        std::cout &lt;&lt; &quot;Box(&quot; &lt;&lt; width &lt;&lt; &quot; x &quot; 
                  &lt;&lt; height &lt;&lt; &quot; x &quot; &lt;&lt; depth &lt;&lt; &quot;)&quot; &lt;&lt; std::endl;
    &#125;

private:
    double width;
    double height;
    double depth;
&#125;;

int main() &#123;
    Box box1(3.0, 4.0, 5.0);
    box1.display();

    Box box2 = box1; // Invokes copy constructor
    box2.display();

    return 0;
&#125;
</code></pre>
<p><strong>Output:</strong></p>
<pre><code>Box(3 x 4 x 5)
Copy constructor called.
Box(3 x 4 x 5)
</code></pre>
<h3 id="Move-Semantics"><a href="#Move-Semantics" class="headerlink" title="Move Semantics"></a>Move Semantics</h3><p>Move semantics allow the resources of a temporary object to be transferred rather than copied, enhancing performance, especially for objects with dynamic memory allocation.</p>
<p><strong>Move Constructor:</strong></p>
<pre><code class="cpp">ClassName(ClassName&amp;&amp; other) noexcept;
</code></pre>
<p><strong>Move Assignment Operator:</strong></p>
<pre><code class="cpp">ClassName&amp; operator=(ClassName&amp;&amp; other) noexcept;
</code></pre>
<p><strong>Example:</strong></p>
<pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;string&gt;

class Buffer &#123;
public:
    // Default constructor
    Buffer() : data(nullptr), size(0) &#123;&#125;

    // Parameterized constructor
    Buffer(size_t sz) : size(sz) &#123;
        data = new int[size];
        std::cout &lt;&lt; &quot;Buffer of size &quot; &lt;&lt; size &lt;&lt; &quot; created.&quot; &lt;&lt; std::endl;
    &#125;

    // Copy constructor
    Buffer(const Buffer&amp; other) : size(other.size) &#123;
        data = new int[size];
        std::copy(other.data, other.data + size, data);
        std::cout &lt;&lt; &quot;Buffer copied.&quot; &lt;&lt; std::endl;
    &#125;

    // Move constructor
    Buffer(Buffer&amp;&amp; other) noexcept : data(other.data), size(other.size) &#123;
        other.data = nullptr;
        other.size = 0;
        std::cout &lt;&lt; &quot;Buffer moved.&quot; &lt;&lt; std::endl;
    &#125;

    // Destructor
    ~Buffer() &#123;
        delete[] data;
        if (size &gt; 0) &#123;
            std::cout &lt;&lt; &quot;Buffer of size &quot; &lt;&lt; size &lt;&lt; &quot; destroyed.&quot; &lt;&lt; std::endl;
        &#125;
    &#125;

    // Display buffer info
    void display() const &#123;
        std::cout &lt;&lt; &quot;Buffer size: &quot; &lt;&lt; size &lt;&lt; &quot;, Data pointer: &quot; 
                  &lt;&lt; data &lt;&lt; std::endl;
    &#125;

private:
    int* data;
    size_t size;
&#125;;

int main() &#123;
    Buffer buf1(10);
    buf1.display();

    Buffer buf2 = std::move(buf1); // Invokes move constructor
    buf2.display();
    buf1.display(); // buf1 is now in a valid but unspecified state

    return 0;
&#125;
</code></pre>
<p><strong>Output:</strong></p>
<pre><code>Buffer of size 10 created.
Buffer size: 10, Data pointer: 0x7ffeefbff5c0
Buffer moved.
Buffer size: 10, Data pointer: 0x7ffeefbff5c0
Buffer size: 0, Data pointer: 0
Buffer of size 10 destroyed.
</code></pre>
<p><strong>Explanation:</strong></p>
<ul>
<li><strong>Move Constructor</strong>: Transfers ownership of resources from <code>buf1</code> to <code>buf2</code>. After the move, <code>buf1</code> no longer owns the data.</li>
<li><strong>Performance Benefit</strong>: Avoids unnecessary deep copies, especially beneficial for large or resource-intensive objects.</li>
</ul>
<hr>
<h2 id="Inheritance-and-Polymorphism"><a href="#Inheritance-and-Polymorphism" class="headerlink" title="Inheritance and Polymorphism"></a>Inheritance and Polymorphism</h2><h3 id="Inheritance"><a href="#Inheritance" class="headerlink" title="Inheritance"></a>Inheritance</h3><p>Inheritance allows a class (derived class) to inherit properties and behaviors from another class (base class). This promotes code reuse and establishes a hierarchical relationship between classes.</p>
<p><strong>Syntax:</strong></p>
<pre><code class="cpp">class BaseClass &#123;
public:
    void baseFunction() &#123;
        // Base class function
    &#125;
&#125;;

class DerivedClass : public BaseClass &#123;
public:
    void derivedFunction() &#123;
        // Derived class function
    &#125;
&#125;;
</code></pre>
<p><strong>Example:</strong></p>
<pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;string&gt;

// Base class
class Animal &#123;
public:
    void eat() const &#123;
        std::cout &lt;&lt; &quot;This animal eats food.&quot; &lt;&lt; std::endl;
    &#125;
&#125;;

// Derived class
class Dog : public Animal &#123;
public:
    void bark() const &#123;
        std::cout &lt;&lt; &quot;The dog barks.&quot; &lt;&lt; std::endl;
    &#125;
&#125;;

int main() &#123;
    Dog myDog;
    myDog.eat();   // Inherited from Animal
    myDog.bark();  // Defined in Dog

    return 0;
&#125;
</code></pre>
<p><strong>Output:</strong></p>
<pre><code>This animal eats food.
The dog barks.
</code></pre>
<h3 id="Polymorphism"><a href="#Polymorphism" class="headerlink" title="Polymorphism"></a>Polymorphism</h3><p>Polymorphism allows objects of different classes to be treated as objects of a common base class. It enables one interface to be used for a general class of actions, with specific actions determined by the exact nature of the situation.</p>
<p>There are two types of polymorphism in C++:</p>
<ol>
<li><strong>Compile-Time Polymorphism</strong>: Achieved through function overloading and templates.</li>
<li><strong>Run-Time Polymorphism</strong>: Achieved through inheritance and virtual functions.</li>
</ol>
<h4 id="Virtual-Functions"><a href="#Virtual-Functions" class="headerlink" title="Virtual Functions"></a>Virtual Functions</h4><p>A virtual function is a member function that you expect to be redefined in derived classes. When you refer to a derived class object using a pointer or a reference to the base class, you can call a virtual function for that object and execute the derived class’s version of the function.</p>
<p><strong>Example:</strong></p>
<pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;string&gt;

// Base class
class Shape &#123;
public:
    virtual void draw() const &#123; // Virtual function
        std::cout &lt;&lt; &quot;Drawing a generic shape.&quot; &lt;&lt; std::endl;
    &#125;
&#125;;

// Derived class
class Circle : public Shape &#123;
public:
    void draw() const override &#123; // Override keyword for clarity
        std::cout &lt;&lt; &quot;Drawing a circle.&quot; &lt;&lt; std::endl;
    &#125;
&#125;;

// Another derived class
class Square : public Shape &#123;
public:
    void draw() const override &#123;
        std::cout &lt;&lt; &quot;Drawing a square.&quot; &lt;&lt; std::endl;
    &#125;
&#125;;

int main() &#123;
    Shape* shape1 = new Circle();
    Shape* shape2 = new Square();

    shape1-&gt;draw(); // Outputs: Drawing a circle.
    shape2-&gt;draw(); // Outputs: Drawing a square.

    delete shape1;
    delete shape2;

    return 0;
&#125;
</code></pre>
<p><strong>Output:</strong></p>
<pre><code>Drawing a circle.
Drawing a square.
</code></pre>
<h4 id="Abstract-Classes"><a href="#Abstract-Classes" class="headerlink" title="Abstract Classes"></a>Abstract Classes</h4><p>An abstract class is a class that cannot be instantiated and is designed to be subclassed. It typically contains at least one pure virtual function, which must be overridden by derived classes.</p>
<p><strong>Syntax:</strong></p>
<pre><code class="cpp">class AbstractClass &#123;
public:
    virtual void pureVirtualFunction() = 0; // Pure virtual function
&#125;;
</code></pre>
<p><strong>Example:</strong></p>
<pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;string&gt;

// Abstract base class
class Vehicle &#123;
public:
    virtual void move() const = 0; // Pure virtual function
&#125;;

// Derived class
class Car : public Vehicle &#123;
public:
    void move() const override &#123;
        std::cout &lt;&lt; &quot;The car drives on the road.&quot; &lt;&lt; std::endl;
    &#125;
&#125;;

// Another derived class
class Boat : public Vehicle &#123;
public:
    void move() const override &#123;
        std::cout &lt;&lt; &quot;The boat sails on the water.&quot; &lt;&lt; std::endl;
    &#125;
&#125;;

int main() &#123;
    // Vehicle v; // Error: Cannot instantiate abstract class

    Vehicle* car = new Car();
    Vehicle* boat = new Boat();

    car-&gt;move();   // Outputs: The car drives on the road.
    boat-&gt;move();  // Outputs: The boat sails on the water.

    delete car;
    delete boat;

    return 0;
&#125;
</code></pre>
<p><strong>Output:</strong></p>
<pre><code>The car drives on the road.
The boat sails on the water.
</code></pre>
<p><strong>Explanation:</strong></p>
<ul>
<li><strong>Abstract Class (<code>Vehicle</code>)</strong>: Defines a common interface (<code>move</code>) for all vehicles.</li>
<li><strong>Derived Classes (<code>Car</code>, <code>Boat</code>)</strong>: Provide specific implementations of the <code>move</code> function.</li>
<li><strong>Polymorphism</strong>: Allows treating different vehicles uniformly through base class pointers.</li>
</ul>
<hr>
<h2 id="Operator-Overloading"><a href="#Operator-Overloading" class="headerlink" title="Operator Overloading"></a>Operator Overloading</h2><p>Operator overloading allows you to redefine the way operators work for user-defined types (classes and structs). This enhances the readability and intuitiveness of your classes by enabling natural syntax for operations.</p>
<h3 id="Why-Overload-Operators"><a href="#Why-Overload-Operators" class="headerlink" title="Why Overload Operators?"></a>Why Overload Operators?</h3><ul>
<li><strong>Intuitiveness</strong>: Makes objects behave like built-in types.</li>
<li><strong>Readability</strong>: Simplifies code by allowing concise expressions.</li>
<li><strong>Functionality</strong>: Enables complex operations to be performed seamlessly.</li>
</ul>
<h3 id="How-to-Overload-Operators"><a href="#How-to-Overload-Operators" class="headerlink" title="How to Overload Operators"></a>How to Overload Operators</h3><p>Operators can be overloaded as member functions or as friend functions. Not all operators can be overloaded, and care must be taken to maintain code clarity.</p>
<p><strong>Syntax:</strong></p>
<pre><code class="cpp">// Member function
ReturnType operatorOp(Parameters) &#123;
    // Implementation
&#125;

// Friend function
friend ReturnType operatorOp(const ClassName&amp; lhs, const ClassName&amp; rhs) &#123;
    // Implementation
&#125;
</code></pre>
<h3 id="Example-Overloading-the-Operator"><a href="#Example-Overloading-the-Operator" class="headerlink" title="Example: Overloading the + Operator"></a>Example: Overloading the <code>+</code> Operator</h3><pre><code class="cpp">#include &lt;iostream&gt;

class Vector &#123;
public:
    Vector(int x, int y) : x_(x), y_(y) &#123;&#125;

    // Overload the + operator as a member function
    Vector operator+(const Vector&amp; other) const &#123;
        return Vector(x_ + other.x_, y_ + other.y_);
    &#125;

    // Display vector components
    void display() const &#123;
        std::cout &lt;&lt; &quot;(&quot; &lt;&lt; x_ &lt;&lt; &quot;, &quot; &lt;&lt; y_ &lt;&lt; &quot;)&quot; &lt;&lt; std::endl;
    &#125;

private:
    int x_;
    int y_;
&#125;;

int main() &#123;
    Vector v1(1, 2);
    Vector v2(3, 4);
    Vector v3 = v1 + v2; // Uses overloaded + operator

    v3.display(); // Outputs: (4, 6)

    return 0;
&#125;
</code></pre>
<p><strong>Output:</strong></p>
<pre><code>(4, 6)
</code></pre>
<h3 id="Example-Overloading-the"><a href="#Example-Overloading-the" class="headerlink" title="Example: Overloading the &lt;&lt; Operator for Output"></a>Example: Overloading the <code>&lt;&lt;</code> Operator for Output</h3><pre><code class="cpp">#include &lt;iostream&gt;

class Point &#123;
public:
    Point(int x, int y) : x_(x), y_(y) &#123;&#125;

    // Overload the &lt;&lt; operator as a friend function
    friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const Point&amp; pt) &#123;
        os &lt;&lt; &quot;(&quot; &lt;&lt; pt.x_ &lt;&lt; &quot;, &quot; &lt;&lt; pt.y_ &lt;&lt; &quot;)&quot;;
        return os;
    &#125;

private:
    int x_;
    int y_;
&#125;;

int main() &#123;
    Point p(5, 10);
    std::cout &lt;&lt; &quot;Point p: &quot; &lt;&lt; p &lt;&lt; std::endl; // Uses overloaded &lt;&lt; operator
    return 0;
&#125;
</code></pre>
<p><strong>Output:</strong></p>
<pre><code>Point p: (5, 10)
</code></pre>
<h3 id="Best-Practices-for-Operator-Overloading"><a href="#Best-Practices-for-Operator-Overloading" class="headerlink" title="Best Practices for Operator Overloading"></a>Best Practices for Operator Overloading</h3><ol>
<li><strong>Maintain Intuitive Behavior</strong>: Overloaded operators should behave as expected to avoid confusing users.</li>
<li><strong>Consistency</strong>: Ensure that operator overloads are consistent with their traditional meanings.</li>
<li><strong>Avoid Overloading Unrelated Operators</strong>: Only overload operators that make logical sense for the class.</li>
<li><strong>Prefer Member Functions for Symmetric Operators</strong>: For operators like <code>+</code>, member functions are often more appropriate.</li>
<li><strong>Use Friend Functions When Necessary</strong>: For operators that require access to private members of multiple classes.</li>
</ol>
<hr>
<h2 id="Union-and-Struct-as-Special-Classes"><a href="#Union-and-Struct-as-Special-Classes" class="headerlink" title="Union and Struct as Special Classes"></a>Union and Struct as Special Classes</h2><p>In C++, <code>struct</code> and <code>union</code> are special types of classes with unique characteristics and use cases.</p>
<h3 id="Structs"><a href="#Structs" class="headerlink" title="Structs"></a>Structs</h3><p>A <code>struct</code> is similar to a <code>class</code> but has default public access specifiers. It is primarily used for passive objects that carry data.</p>
<p><strong>Syntax:</strong></p>
<pre><code class="cpp">struct StructName &#123;
    // Public members by default
    int member1;
    double member2;

    void display() const &#123;
        std::cout &lt;&lt; &quot;Member1: &quot; &lt;&lt; member1 
                  &lt;&lt; &quot;, Member2: &quot; &lt;&lt; member2 &lt;&lt; std::endl;
    &#125;
&#125;;
</code></pre>
<p><strong>Example:</strong></p>
<pre><code class="cpp">#include &lt;iostream&gt;

struct Point &#123;
    int x;
    int y;

    void display() const &#123;
        std::cout &lt;&lt; &quot;Point(&quot; &lt;&lt; x &lt;&lt; &quot;, &quot; &lt;&lt; y &lt;&lt; &quot;)&quot; &lt;&lt; std::endl;
    &#125;
&#125;;

int main() &#123;
    Point p = &#123;10, 20&#125;;
    p.display(); // Outputs: Point(10, 20)
    return 0;
&#125;
</code></pre>
<h3 id="Unions"><a href="#Unions" class="headerlink" title="Unions"></a>Unions</h3><p>A <code>union</code> allows storing different data types in the same memory location. Only one member can hold a value at any given time.</p>
<p><strong>Syntax:</strong></p>
<pre><code class="cpp">union UnionName &#123;
    int intVal;
    float floatVal;
    char charVal;
&#125;;
</code></pre>
<p><strong>Example:</strong></p>
<pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;cstring&gt;

union Data &#123;
    int intVal;
    float floatVal;
    char charVal;
&#125;;

int main() &#123;
    Data data;
    data.intVal = 100;
    std::cout &lt;&lt; &quot;data.intVal: &quot; &lt;&lt; data.intVal &lt;&lt; std::endl;

    data.floatVal = 98.6f;
    std::cout &lt;&lt; &quot;data.floatVal: &quot; &lt;&lt; data.floatVal &lt;&lt; std::endl;

    data.charVal = &#39;A&#39;;
    std::cout &lt;&lt; &quot;data.charVal: &quot; &lt;&lt; data.charVal &lt;&lt; std::endl;

    return 0;
&#125;
</code></pre>
<p><strong>Output:</strong></p>
<pre><code>data.intVal: 100
data.floatVal: 98.6
data.charVal: A
</code></pre>
<p><strong>Note:</strong> Assigning to one member overwrites the others since all members share the same memory.</p>
<hr>
<h2 id="Type-Conversions"><a href="#Type-Conversions" class="headerlink" title="Type Conversions"></a>Type Conversions</h2><p>Type conversions, also known as type casting, allow you to convert a value from one data type to another. Understanding type conversions is crucial for operations involving different data types, function calls, and more, especially within the context of OOP.</p>
<h3 id="Implicit-Type-Conversion"><a href="#Implicit-Type-Conversion" class="headerlink" title="Implicit Type Conversion"></a>Implicit Type Conversion</h3><p>Implicit type conversion occurs automatically when converting from a smaller to a larger type or between compatible types. The compiler handles this conversion without explicit instructions.</p>
<p><strong>Example:</strong></p>
<pre><code class="cpp">#include &lt;iostream&gt;

int main() &#123;
    int a = 10;
    double b = a; // Implicitly converts int to double
    std::cout &lt;&lt; &quot;b = &quot; &lt;&lt; b &lt;&lt; std::endl; // Outputs: b = 10.0
    return 0;
&#125;
</code></pre>
<p><strong>Key Points:</strong></p>
<ul>
<li>Safe and lossless when converting to a type that can represent all possible values of the original type.</li>
<li>Can lead to precision loss when converting from a floating-point to an integer type.</li>
</ul>
<h3 id="Explicit-Type-Conversion"><a href="#Explicit-Type-Conversion" class="headerlink" title="Explicit Type Conversion"></a>Explicit Type Conversion</h3><p>Explicit type conversion, or casting, is performed manually using casting operators. It is necessary when implicit conversion is not possible or could lead to data loss.</p>
<p><strong>C++ Casting Operators:</strong></p>
<ol>
<li><strong><code>static_cast</code></strong></li>
<li><strong><code>dynamic_cast</code></strong></li>
<li><strong><code>const_cast</code></strong></li>
<li><strong><code>reinterpret_cast</code></strong></li>
</ol>
<h4 id="static-cast"><a href="#static-cast" class="headerlink" title="static_cast"></a><code>static_cast</code></h4><p>Used for well-defined and safe conversions, such as between numeric types or upcasting in inheritance hierarchies.</p>
<p><strong>Example:</strong></p>
<pre><code class="cpp">#include &lt;iostream&gt;

int main() &#123;
    double pi = 3.14159;
    int intPi = static_cast&lt;int&gt;(pi); // Explicitly converts double to int
    std::cout &lt;&lt; &quot;intPi = &quot; &lt;&lt; intPi &lt;&lt; std::endl; // Outputs: intPi = 3
    return 0;
&#125;
</code></pre>
<h4 id="dynamic-cast"><a href="#dynamic-cast" class="headerlink" title="dynamic_cast"></a><code>dynamic_cast</code></h4><p>Used primarily for downcasting in inheritance hierarchies, ensuring that the cast is safe at runtime. Requires the base class to have at least one virtual function.</p>
<p><strong>Example:</strong></p>
<pre><code class="cpp">#include &lt;iostream&gt;

class Base &#123;
public:
    virtual void speak() const &#123; std::cout &lt;&lt; &quot;Base speaking.&quot; &lt;&lt; std::endl; &#125;
&#125;;

class Derived : public Base &#123;
public:
    void speak() const override &#123; std::cout &lt;&lt; &quot;Derived speaking.&quot; &lt;&lt; std::endl; &#125;
&#125;;

int main() &#123;
    Base* basePtr = new Derived();
    Derived* derivedPtr = dynamic_cast&lt;Derived*&gt;(basePtr);
    
    if (derivedPtr) &#123;
        derivedPtr-&gt;speak(); // Outputs: Derived speaking.
    &#125; else &#123;
        std::cout &lt;&lt; &quot;Cast failed.&quot; &lt;&lt; std::endl;
    &#125;

    delete basePtr;
    return 0;
&#125;
</code></pre>
<h4 id="const-cast"><a href="#const-cast" class="headerlink" title="const_cast"></a><code>const_cast</code></h4><p>Used to add or remove the <code>const</code> qualifier from a variable. It should be used cautiously, as modifying a <code>const</code> variable after removing <code>const</code> can lead to undefined behavior.</p>
<p><strong>Example:</strong></p>
<pre><code class="cpp">#include &lt;iostream&gt;

void printNumber(const int* num) &#123;
    int* modifiableNum = const_cast&lt;int*&gt;(num);
    *modifiableNum = 20; // Undefined behavior if num was originally const
    std::cout &lt;&lt; &quot;Number: &quot; &lt;&lt; *modifiableNum &lt;&lt; std::endl;
&#125;

int main() &#123;
    int value = 10;
    printNumber(&amp;value); // Outputs: Number: 20
    return 0;
&#125;
</code></pre>
<h4 id="reinterpret-cast"><a href="#reinterpret-cast" class="headerlink" title="reinterpret_cast"></a><code>reinterpret_cast</code></h4><p>Used for low-level, unsafe conversions, such as converting between pointer types or between pointers and integers. It should be used sparingly and only when absolutely necessary.</p>
<p><strong>Example:</strong></p>
<pre><code class="cpp">#include &lt;iostream&gt;

int main() &#123;
    int a = 65;
    char* charPtr = reinterpret_cast&lt;char*&gt;(&amp;a);
    std::cout &lt;&lt; &quot;Character: &quot; &lt;&lt; *charPtr &lt;&lt; std::endl; // May output: &#39;A&#39;
    return 0;
&#125;
</code></pre>
<p><strong>Caution:</strong> <code>reinterpret_cast</code> can lead to platform-dependent behavior and should be avoided unless you have a clear understanding of the implications.</p>
<h3 id="Best-Practices-for-Type-Conversion"><a href="#Best-Practices-for-Type-Conversion" class="headerlink" title="Best Practices for Type Conversion"></a>Best Practices for Type Conversion</h3><ol>
<li><p><strong>Prefer Implicit Conversions When Safe:</strong></p>
<ul>
<li>Use implicit conversions when they are safe and do not lead to data loss or unexpected behavior.</li>
</ul>
</li>
<li><p><strong>Use <code>static_cast</code> for Clear Intentions:</strong></p>
<ul>
<li>When you need to convert between compatible types, <code>static_cast</code> makes your intentions explicit.</li>
</ul>
</li>
<li><p><strong>Minimize the Use of <code>reinterpret_cast</code>:</strong></p>
<ul>
<li>Avoid <code>reinterpret_cast</code> unless absolutely necessary due to its unsafe nature.</li>
</ul>
</li>
<li><p><strong>Ensure Safe Downcasting with <code>dynamic_cast</code>:</strong></p>
<ul>
<li>When downcasting in an inheritance hierarchy, use <code>dynamic_cast</code> to ensure the cast is valid at runtime.</li>
</ul>
</li>
<li><p><strong>Maintain Const-Correctness:</strong></p>
<ul>
<li>Use <code>const_cast</code> judiciously to maintain the integrity of <code>const</code> variables.</li>
</ul>
</li>
<li><p><strong>Avoid Unnecessary Casts:</strong></p>
<ul>
<li>Unnecessary type casts can make code harder to read and maintain. Only cast when required.</li>
</ul>
</li>
</ol>
<h3 id="Using-Type-Conversions-in-Code"><a href="#Using-Type-Conversions-in-Code" class="headerlink" title="Using Type Conversions in Code"></a>Using Type Conversions in Code</h3><p>Understanding when and how to perform type conversions is essential for writing flexible and error-free C++ programs. Let’s modify our program to include examples of type conversions.</p>
<h4 id="Step-1-Update-main-cpp"><a href="#Step-1-Update-main-cpp" class="headerlink" title="Step 1: Update main.cpp"></a>Step 1: Update <code>main.cpp</code></h4><p>Open <code>src/main.cpp</code> and replace its contents with the following code:</p>
<pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;string&gt;

int main() &#123;
    // Implicit Type Conversion
    int integer = 42;
    double floating = integer; // Implicitly converts int to double
    std::cout &lt;&lt; &quot;Floating: &quot; &lt;&lt; floating &lt;&lt; std::endl; // Outputs: Floating: 42.0

    // Explicit Type Conversion using static_cast
    double pi = 3.14159;
    int intPi = static_cast&lt;int&gt;(pi); // Explicitly converts double to int
    std::cout &lt;&lt; &quot;intPi: &quot; &lt;&lt; intPi &lt;&lt; std::endl; // Outputs: intPi: 3

    // Explicit Type Conversion using reinterpret_cast
    int a = 65;
    char* charPtr = reinterpret_cast&lt;char*&gt;(&amp;a);
    std::cout &lt;&lt; &quot;Character: &quot; &lt;&lt; *charPtr &lt;&lt; std::endl; // May output: Character: &#39;A&#39;

    // Using const_cast
    const int value = 100;
    int* modifiableValue = const_cast&lt;int*&gt;(&amp;value);
    *modifiableValue = 200; // Undefined behavior if value was originally const
    std::cout &lt;&lt; &quot;Modified Value: &quot; &lt;&lt; value &lt;&lt; std::endl; // Outputs: Modified Value: 200

    return 0;
&#125;
</code></pre>
<h4 id="Step-2-Build-and-Run-the-Program"><a href="#Step-2-Build-and-Run-the-Program" class="headerlink" title="Step 2: Build and Run the Program"></a>Step 2: Build and Run the Program</h4><p>In the terminal, build the project:</p>
<pre><code class="bash">xmake
</code></pre>
<p>Run the program:</p>
<pre><code class="bash">xmake run
</code></pre>
<h4 id="Expected-Output"><a href="#Expected-Output" class="headerlink" title="Expected Output"></a>Expected Output</h4><pre><code>Floating: 42
intPi: 3
Character: A
Modified Value: 200
</code></pre>
<p><strong>Note:</strong> Modifying a <code>const</code> variable using <code>const_cast</code> leads to undefined behavior if the original variable was declared as <code>const</code>. In this example, <code>value</code> is modified after being cast, which is generally unsafe and should be avoided in real-world applications.</p>
<h4 id="Explanation"><a href="#Explanation" class="headerlink" title="Explanation"></a>Explanation</h4><ul>
<li><p><strong>Implicit Conversion:</strong></p>
<ul>
<li><code>int</code> to <code>double</code> is performed automatically without explicit casting.</li>
</ul>
</li>
<li><p><strong>Explicit Conversion (<code>static_cast</code>):</strong></p>
<ul>
<li>Converts <code>double</code> to <code>int</code>, truncating the decimal part.</li>
</ul>
</li>
<li><p><strong>Explicit Conversion (<code>reinterpret_cast</code>):</strong></p>
<ul>
<li>Treats the memory address of an <code>int</code> as a <code>char*</code> to access individual bytes. This is useful for low-level programming but should be used with caution.</li>
</ul>
</li>
<li><p><strong>Explicit Conversion (<code>const_cast</code>):</strong></p>
<ul>
<li>Removes the <code>const</code> qualifier from a variable, allowing modification. This can lead to undefined behavior if not used carefully.</li>
</ul>
</li>
</ul>
<hr>
<h2 id="Operator-Overloading-1"><a href="#Operator-Overloading-1" class="headerlink" title="Operator Overloading"></a>Operator Overloading</h2><p>Operator overloading allows you to redefine the way operators work for user-defined types (classes and structs). This enhances the readability and intuitiveness of your classes by enabling natural syntax for operations.</p>
<h3 id="Why-Overload-Operators-1"><a href="#Why-Overload-Operators-1" class="headerlink" title="Why Overload Operators?"></a>Why Overload Operators?</h3><ul>
<li><strong>Intuitiveness</strong>: Makes objects behave like built-in types.</li>
<li><strong>Readability</strong>: Simplifies code by allowing concise expressions.</li>
<li><strong>Functionality</strong>: Enables complex operations to be performed seamlessly.</li>
</ul>
<h3 id="How-to-Overload-Operators-1"><a href="#How-to-Overload-Operators-1" class="headerlink" title="How to Overload Operators"></a>How to Overload Operators</h3><p>Operators can be overloaded as member functions or as friend functions. Not all operators can be overloaded, and care must be taken to maintain code clarity.</p>
<p><strong>Syntax:</strong></p>
<pre><code class="cpp">// Member function
ReturnType operatorOp(Parameters) &#123;
    // Implementation
&#125;

// Friend function
friend ReturnType operatorOp(const ClassName&amp; lhs, const ClassName&amp; rhs) &#123;
    // Implementation
&#125;
</code></pre>
<h3 id="Example-Overloading-the-Operator-1"><a href="#Example-Overloading-the-Operator-1" class="headerlink" title="Example: Overloading the + Operator"></a>Example: Overloading the <code>+</code> Operator</h3><pre><code class="cpp">#include &lt;iostream&gt;

class Vector &#123;
public:
    Vector(int x, int y) : x_(x), y_(y) &#123;&#125;

    // Overload the + operator as a member function
    Vector operator+(const Vector&amp; other) const &#123;
        return Vector(x_ + other.x_, y_ + other.y_);
    &#125;

    // Display vector components
    void display() const &#123;
        std::cout &lt;&lt; &quot;(&quot; &lt;&lt; x_ &lt;&lt; &quot;, &quot; &lt;&lt; y_ &lt;&lt; &quot;)&quot; &lt;&lt; std::endl;
    &#125;

private:
    int x_;
    int y_;
&#125;;

int main() &#123;
    Vector v1(1, 2);
    Vector v2(3, 4);
    Vector v3 = v1 + v2; // Uses overloaded + operator

    v3.display(); // Outputs: (4, 6)

    return 0;
&#125;
</code></pre>
<p><strong>Output:</strong></p>
<pre><code>(4, 6)
</code></pre>
<h3 id="Example-Overloading-the-1"><a href="#Example-Overloading-the-1" class="headerlink" title="Example: Overloading the &lt;&lt; Operator for Output"></a>Example: Overloading the <code>&lt;&lt;</code> Operator for Output</h3><pre><code class="cpp">#include &lt;iostream&gt;

class Point &#123;
public:
    Point(int x, int y) : x_(x), y_(y) &#123;&#125;

    // Overload the &lt;&lt; operator as a friend function
    friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const Point&amp; pt) &#123;
        os &lt;&lt; &quot;(&quot; &lt;&lt; pt.x_ &lt;&lt; &quot;, &quot; &lt;&lt; pt.y_ &lt;&lt; &quot;)&quot;;
        return os;
    &#125;

private:
    int x_;
    int y_;
&#125;;

int main() &#123;
    Point p(5, 10);
    std::cout &lt;&lt; &quot;Point p: &quot; &lt;&lt; p &lt;&lt; std::endl; // Uses overloaded &lt;&lt; operator
    return 0;
&#125;
</code></pre>
<p><strong>Output:</strong></p>
<pre><code>Point p: (5, 10)
</code></pre>
<h3 id="Best-Practices-for-Operator-Overloading-1"><a href="#Best-Practices-for-Operator-Overloading-1" class="headerlink" title="Best Practices for Operator Overloading"></a>Best Practices for Operator Overloading</h3><ol>
<li><strong>Maintain Intuitive Behavior</strong>: Overloaded operators should behave as expected to avoid confusing users.</li>
<li><strong>Consistency</strong>: Ensure that operator overloads are consistent with their traditional meanings.</li>
<li><strong>Avoid Overloading Unrelated Operators</strong>: Only overload operators that make logical sense for the class.</li>
<li><strong>Prefer Member Functions for Symmetric Operators</strong>: For operators like <code>+</code>, member functions are often more appropriate.</li>
<li><strong>Use Friend Functions When Necessary</strong>: For operators that require access to private members of multiple classes.</li>
</ol>
<hr>
<h2 id="Union-and-Struct-as-Special-Classes-1"><a href="#Union-and-Struct-as-Special-Classes-1" class="headerlink" title="Union and Struct as Special Classes"></a>Union and Struct as Special Classes</h2><p>In C++, <code>struct</code> and <code>union</code> are special types of classes with unique characteristics and use cases.</p>
<h3 id="Structs-1"><a href="#Structs-1" class="headerlink" title="Structs"></a>Structs</h3><p>A <code>struct</code> is similar to a <code>class</code> but has default public access specifiers. It is primarily used for passive objects that carry data.</p>
<p><strong>Syntax:</strong></p>
<pre><code class="cpp">struct StructName &#123;
    // Public members by default
    int member1;
    double member2;

    void display() const &#123;
        std::cout &lt;&lt; &quot;Member1: &quot; &lt;&lt; member1 
                  &lt;&lt; &quot;, Member2: &quot; &lt;&lt; member2 &lt;&lt; std::endl;
    &#125;
&#125;;
</code></pre>
<p><strong>Example:</strong></p>
<pre><code class="cpp">#include &lt;iostream&gt;

struct Point &#123;
    int x;
    int y;

    void display() const &#123;
        std::cout &lt;&lt; &quot;Point(&quot; &lt;&lt; x &lt;&lt; &quot;, &quot; &lt;&lt; y &lt;&lt; &quot;)&quot; &lt;&lt; std::endl;
    &#125;
&#125;;

int main() &#123;
    Point p = &#123;10, 20&#125;;
    p.display(); // Outputs: Point(10, 20)
    return 0;
&#125;
</code></pre>
<h3 id="Unions-1"><a href="#Unions-1" class="headerlink" title="Unions"></a>Unions</h3><p>A <code>union</code> allows storing different data types in the same memory location. Only one member can hold a value at any given time.</p>
<p><strong>Syntax:</strong></p>
<pre><code class="cpp">union UnionName &#123;
    int intVal;
    float floatVal;
    char charVal;
&#125;;
</code></pre>
<p><strong>Example:</strong></p>
<pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;cstring&gt;

union Data &#123;
    int intVal;
    float floatVal;
    char charVal;
&#125;;

int main() &#123;
    Data data;
    data.intVal = 100;
    std::cout &lt;&lt; &quot;data.intVal: &quot; &lt;&lt; data.intVal &lt;&lt; std::endl;

    data.floatVal = 98.6f;
    std::cout &lt;&lt; &quot;data.floatVal: &quot; &lt;&lt; data.floatVal &lt;&lt; std::endl;

    data.charVal = &#39;A&#39;;
    std::cout &lt;&lt; &quot;data.charVal: &quot; &lt;&lt; data.charVal &lt;&lt; std::endl;

    return 0;
&#125;
</code></pre>
<p><strong>Output:</strong></p>
<pre><code>data.intVal: 100
data.floatVal: 98.6
data.charVal: A
</code></pre>
<p><strong>Note:</strong> Assigning to one member overwrites the others since all members share the same memory.</p>
<hr>
<h2 id="Type-Conversions-1"><a href="#Type-Conversions-1" class="headerlink" title="Type Conversions"></a>Type Conversions</h2><p>Type conversions, also known as type casting, allow you to convert a value from one data type to another. Understanding type conversions is crucial for operations involving different data types, function calls, and more, especially within the context of OOP.</p>
<h3 id="Implicit-Type-Conversion-1"><a href="#Implicit-Type-Conversion-1" class="headerlink" title="Implicit Type Conversion"></a>Implicit Type Conversion</h3><p>Implicit type conversion occurs automatically when converting from a smaller to a larger type or between compatible types. The compiler handles this conversion without explicit instructions.</p>
<p><strong>Example:</strong></p>
<pre><code class="cpp">#include &lt;iostream&gt;

int main() &#123;
    int a = 10;
    double b = a; // Implicitly converts int to double
    std::cout &lt;&lt; &quot;b = &quot; &lt;&lt; b &lt;&lt; std::endl; // Outputs: b = 10.0
    return 0;
&#125;
</code></pre>
<p><strong>Key Points:</strong></p>
<ul>
<li>Safe and lossless when converting to a type that can represent all possible values of the original type.</li>
<li>Can lead to precision loss when converting from a floating-point to an integer type.</li>
</ul>
<h3 id="Explicit-Type-Conversion-1"><a href="#Explicit-Type-Conversion-1" class="headerlink" title="Explicit Type Conversion"></a>Explicit Type Conversion</h3><p>Explicit type conversion, or casting, is performed manually using casting operators. It is necessary when implicit conversion is not possible or could lead to data loss.</p>
<p><strong>C++ Casting Operators:</strong></p>
<ol>
<li><strong><code>static_cast</code></strong></li>
<li><strong><code>dynamic_cast</code></strong></li>
<li><strong><code>const_cast</code></strong></li>
<li><strong><code>reinterpret_cast</code></strong></li>
</ol>
<h4 id="static-cast-1"><a href="#static-cast-1" class="headerlink" title="static_cast"></a><code>static_cast</code></h4><p>Used for well-defined and safe conversions, such as between numeric types or upcasting in inheritance hierarchies.</p>
<p><strong>Example:</strong></p>
<pre><code class="cpp">#include &lt;iostream&gt;

int main() &#123;
    double pi = 3.14159;
    int intPi = static_cast&lt;int&gt;(pi); // Explicitly converts double to int
    std::cout &lt;&lt; &quot;intPi = &quot; &lt;&lt; intPi &lt;&lt; std::endl; // Outputs: intPi = 3
    return 0;
&#125;
</code></pre>
<h4 id="dynamic-cast-1"><a href="#dynamic-cast-1" class="headerlink" title="dynamic_cast"></a><code>dynamic_cast</code></h4><p>Used primarily for downcasting in inheritance hierarchies, ensuring that the cast is safe at runtime. Requires the base class to have at least one virtual function.</p>
<p><strong>Example:</strong></p>
<pre><code class="cpp">#include &lt;iostream&gt;

class Base &#123;
public:
    virtual void speak() const &#123; std::cout &lt;&lt; &quot;Base speaking.&quot; &lt;&lt; std::endl; &#125;
&#125;;

class Derived : public Base &#123;
public:
    void speak() const override &#123; std::cout &lt;&lt; &quot;Derived speaking.&quot; &lt;&lt; std::endl; &#125;
&#125;;

int main() &#123;
    Base* basePtr = new Derived();
    Derived* derivedPtr = dynamic_cast&lt;Derived*&gt;(basePtr);
    
    if (derivedPtr) &#123;
        derivedPtr-&gt;speak(); // Outputs: Derived speaking.
    &#125; else &#123;
        std::cout &lt;&lt; &quot;Cast failed.&quot; &lt;&lt; std::endl;
    &#125;

    delete basePtr;
    return 0;
&#125;
</code></pre>
<h4 id="const-cast-1"><a href="#const-cast-1" class="headerlink" title="const_cast"></a><code>const_cast</code></h4><p>Used to add or remove the <code>const</code> qualifier from a variable. It should be used cautiously, as modifying a <code>const</code> variable after removing <code>const</code> can lead to undefined behavior.</p>
<p><strong>Example:</strong></p>
<pre><code class="cpp">#include &lt;iostream&gt;

void printNumber(const int* num) &#123;
    int* modifiableNum = const_cast&lt;int*&gt;(num);
    *modifiableNum = 20; // Undefined behavior if num was originally const
    std::cout &lt;&lt; &quot;Number: &quot; &lt;&lt; *modifiableNum &lt;&lt; std::endl;
&#125;

int main() &#123;
    int value = 10;
    printNumber(&amp;value); // Outputs: Number: 20
    return 0;
&#125;
</code></pre>
<h4 id="reinterpret-cast-1"><a href="#reinterpret-cast-1" class="headerlink" title="reinterpret_cast"></a><code>reinterpret_cast</code></h4><p>Used for low-level, unsafe conversions, such as converting between pointer types or between pointers and integers. It should be used sparingly and only when absolutely necessary.</p>
<p><strong>Example:</strong></p>
<pre><code class="cpp">#include &lt;iostream&gt;

int main() &#123;
    int a = 65;
    char* charPtr = reinterpret_cast&lt;char*&gt;(&amp;a);
    std::cout &lt;&lt; &quot;Character: &quot; &lt;&lt; *charPtr &lt;&lt; std::endl; // May output: &#39;A&#39;
    return 0;
&#125;
</code></pre>
<p><strong>Caution:</strong> <code>reinterpret_cast</code> can lead to platform-dependent behavior and should be avoided unless you have a clear understanding of the implications.</p>
<h3 id="Best-Practices-for-Type-Conversion-1"><a href="#Best-Practices-for-Type-Conversion-1" class="headerlink" title="Best Practices for Type Conversion"></a>Best Practices for Type Conversion</h3><ol>
<li><p><strong>Prefer Implicit Conversions When Safe:</strong></p>
<ul>
<li>Use implicit conversions when they are safe and do not lead to data loss or unexpected behavior.</li>
</ul>
</li>
<li><p><strong>Use <code>static_cast</code> for Clear Intentions:</strong></p>
<ul>
<li>When you need to convert between compatible types, <code>static_cast</code> makes your intentions explicit.</li>
</ul>
</li>
<li><p><strong>Minimize the Use of <code>reinterpret_cast</code>:</strong></p>
<ul>
<li>Avoid <code>reinterpret_cast</code> unless absolutely necessary due to its unsafe nature.</li>
</ul>
</li>
<li><p><strong>Ensure Safe Downcasting with <code>dynamic_cast</code>:</strong></p>
<ul>
<li>When downcasting in an inheritance hierarchy, use <code>dynamic_cast</code> to ensure the cast is valid at runtime.</li>
</ul>
</li>
<li><p><strong>Maintain Const-Correctness:</strong></p>
<ul>
<li>Use <code>const_cast</code> judiciously to maintain the integrity of <code>const</code> variables.</li>
</ul>
</li>
<li><p><strong>Avoid Unnecessary Casts:</strong></p>
<ul>
<li>Unnecessary type casts can make code harder to read and maintain. Only cast when required.</li>
</ul>
</li>
</ol>
<h3 id="Using-Type-Conversions-in-Code-1"><a href="#Using-Type-Conversions-in-Code-1" class="headerlink" title="Using Type Conversions in Code"></a>Using Type Conversions in Code</h3><p>Understanding when and how to perform type conversions is essential for writing flexible and error-free C++ programs. Let’s modify our program to include examples of type conversions.</p>
<h4 id="Step-1-Update-main-cpp-1"><a href="#Step-1-Update-main-cpp-1" class="headerlink" title="Step 1: Update main.cpp"></a>Step 1: Update <code>main.cpp</code></h4><p>Open <code>src/main.cpp</code> and replace its contents with the following code:</p>
<pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;string&gt;

int main() &#123;
    // Implicit Type Conversion
    int integer = 42;
    double floating = integer; // Implicitly converts int to double
    std::cout &lt;&lt; &quot;Floating: &quot; &lt;&lt; floating &lt;&lt; std::endl; // Outputs: Floating: 42.0

    // Explicit Type Conversion using static_cast
    double pi = 3.14159;
    int intPi = static_cast&lt;int&gt;(pi); // Explicitly converts double to int
    std::cout &lt;&lt; &quot;intPi: &quot; &lt;&lt; intPi &lt;&lt; std::endl; // Outputs: intPi: 3

    // Explicit Type Conversion using reinterpret_cast
    int a = 65;
    char* charPtr = reinterpret_cast&lt;char*&gt;(&amp;a);
    std::cout &lt;&lt; &quot;Character: &quot; &lt;&lt; *charPtr &lt;&lt; std::endl; // May output: Character: &#39;A&#39;

    // Using const_cast
    const int value = 100;
    int* modifiableValue = const_cast&lt;int*&gt;(&amp;value);
    *modifiableValue = 200; // Undefined behavior if value was originally const
    std::cout &lt;&lt; &quot;Modified Value: &quot; &lt;&lt; value &lt;&lt; std::endl; // Outputs: Modified Value: 200

    return 0;
&#125;
</code></pre>
<h4 id="Step-2-Build-and-Run-the-Program-1"><a href="#Step-2-Build-and-Run-the-Program-1" class="headerlink" title="Step 2: Build and Run the Program"></a>Step 2: Build and Run the Program</h4><p>In the terminal, build the project:</p>
<pre><code class="bash">xmake
</code></pre>
<p>Run the program:</p>
<pre><code class="bash">xmake run
</code></pre>
<h4 id="Expected-Output-1"><a href="#Expected-Output-1" class="headerlink" title="Expected Output"></a>Expected Output</h4><pre><code>Floating: 42
intPi: 3
Character: A
Modified Value: 200
</code></pre>
<p><strong>Note:</strong> Modifying a <code>const</code> variable using <code>const_cast</code> leads to undefined behavior if the original variable was declared as <code>const</code>. In this example, <code>value</code> is modified after being cast, which is generally unsafe and should be avoided in real-world applications.</p>
<h4 id="Explanation-1"><a href="#Explanation-1" class="headerlink" title="Explanation"></a>Explanation</h4><ul>
<li><p><strong>Implicit Conversion:</strong></p>
<ul>
<li><code>int</code> to <code>double</code> is performed automatically without explicit casting.</li>
</ul>
</li>
<li><p><strong>Explicit Conversion (<code>static_cast</code>):</strong></p>
<ul>
<li>Converts <code>double</code> to <code>int</code>, truncating the decimal part.</li>
</ul>
</li>
<li><p><strong>Explicit Conversion (<code>reinterpret_cast</code>):</strong></p>
<ul>
<li>Treats the memory address of an <code>int</code> as a <code>char*</code> to access individual bytes. This is useful for low-level programming but should be used with caution.</li>
</ul>
</li>
<li><p><strong>Explicit Conversion (<code>const_cast</code>):</strong></p>
<ul>
<li>Removes the <code>const</code> qualifier from a variable, allowing modification. This can lead to undefined behavior if not used carefully.</li>
</ul>
</li>
</ul>
<hr>
<h2 id="Variable-Modifiers-const-static-mutable-volatile"><a href="#Variable-Modifiers-const-static-mutable-volatile" class="headerlink" title="Variable Modifiers (const, static, mutable, volatile)"></a>Variable Modifiers (<code>const</code>, <code>static</code>, <code>mutable</code>, <code>volatile</code>)</h2><p>Variable modifiers in C++ alter the behavior or characteristics of variables. Within the context of OOP, these modifiers are often used to control access, manage memory, and enforce const-correctness.</p>
<h3 id="const"><a href="#const" class="headerlink" title="const"></a><code>const</code></h3><p>The <code>const</code> keyword makes a variable read-only after its initialization. Attempting to modify a <code>const</code> variable will result in a compile-time error.</p>
<p><strong>Usage in Classes:</strong></p>
<ul>
<li><p><strong>Constant Member Functions</strong>: Functions that do not modify the state of the object.</p>
<pre><code class="cpp">class Rectangle &#123;
public:
    Rectangle(double w, double h) : width(w), height(h) &#123;&#125;

    double area() const &#123; // const member function
        return width * height;
    &#125;

private:
    double width;
    double height;
&#125;;
</code></pre>
</li>
<li><p><strong>Constant Data Members</strong>: Data members that cannot be modified after initialization.</p>
<pre><code class="cpp">class Circle &#123;
public:
    Circle(double r) : radius(r) &#123;&#125;

    double getRadius() const &#123;
        return radius;
    &#125;

private:
    const double radius; // Constant data member
&#125;;
</code></pre>
</li>
</ul>
<h3 id="static"><a href="#static" class="headerlink" title="static"></a><code>static</code></h3><p>The <code>static</code> keyword has different meanings depending on the context within a class:</p>
<ul>
<li><p><strong>Static Data Members</strong>: Shared among all instances of the class. They are not tied to any specific object.</p>
<pre><code class="cpp">class Counter &#123;
public:
    Counter() &#123; ++count; &#125;
    static int getCount() &#123; return count; &#125;

private:
    static int count; // Declaration
&#125;;

// Definition and initialization
int Counter::count = 0;

int main() &#123;
    Counter c1;
    Counter c2;
    std::cout &lt;&lt; &quot;Number of Counter instances: &quot; &lt;&lt; Counter::getCount() &lt;&lt; std::endl; // Outputs: 2
    return 0;
&#125;
</code></pre>
</li>
<li><p><strong>Static Member Functions</strong>: Can be called without creating an instance of the class. They can only access static data members.</p>
<pre><code class="cpp">class MathUtils &#123;
public:
    static double pi() &#123;
        return 3.14159;
    &#125;
&#125;;

int main() &#123;
    std::cout &lt;&lt; &quot;Pi: &quot; &lt;&lt; MathUtils::pi() &lt;&lt; std::endl; // Outputs: Pi: 3.14159
    return 0;
&#125;
</code></pre>
</li>
</ul>
<h3 id="mutable"><a href="#mutable" class="headerlink" title="mutable"></a><code>mutable</code></h3><p>The <code>mutable</code> keyword allows a member of an object to be modified even if the object is declared as <code>const</code>. This is useful for fields that are logically not part of the object’s state, such as caching or logging information.</p>
<p><strong>Example:</strong></p>
<pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;string&gt;

class Logger &#123;
public:
    Logger(const std::string&amp; msg) : message(msg), logCount(0) &#123;&#125;

    void log() const &#123;
        ++logCount; // Allowed because logCount is mutable
        std::cout &lt;&lt; &quot;Log: &quot; &lt;&lt; message &lt;&lt; &quot; (Log Count: &quot; &lt;&lt; logCount &lt;&lt; &quot;)&quot; &lt;&lt; std::endl;
    &#125;

private:
    std::string message;
    mutable int logCount; // Mutable member
&#125;;

int main() &#123;
    const Logger logger(&quot;Starting application&quot;);
    logger.log(); // Log Count: 1
    logger.log(); // Log Count: 2

    return 0;
&#125;
</code></pre>
<p><strong>Output:</strong></p>
<pre><code>Log: Starting application (Log Count: 1)
Log: Starting application (Log Count: 2)
</code></pre>
<h3 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a><code>volatile</code></h3><p>The <code>volatile</code> keyword indicates that a variable’s value may be changed by something outside the control of the program, such as hardware or a different thread. It prevents the compiler from applying certain optimizations that assume values do not change unexpectedly.</p>
<p><strong>Usage in Classes:</strong></p>
<ul>
<li><p><strong>Volatile Member Variables</strong>: Useful in scenarios where variables can be modified by external factors, such as memory-mapped hardware registers or signal handlers.</p>
<pre><code class="cpp">class HardwareRegister &#123;
public:
    volatile int status; // Status register that can change unexpectedly

    HardwareRegister() : status(0) &#123;&#125;

    void updateStatus(int newStatus) &#123;
        status = newStatus;
    &#125;

    void checkStatus() const &#123;
        if (status &amp; 0x1) &#123;
            std::cout &lt;&lt; &quot;Status bit 0 is set.&quot; &lt;&lt; std::endl;
        &#125;
    &#125;
&#125;;

int main() &#123;
    HardwareRegister reg;
    reg.updateStatus(1);
    reg.checkStatus(); // Outputs: Status bit 0 is set.

    return 0;
&#125;
</code></pre>
</li>
</ul>
<p><strong>Important Considerations:</strong></p>
<ul>
<li><strong>Limited Use Cases</strong>: The <code>volatile</code> keyword has specific use cases and is not commonly needed in typical application development.</li>
<li><strong>Not a Substitute for Synchronization</strong>: <code>volatile</code> does not provide any thread synchronization or memory ordering guarantees. For multithreading, prefer using atomic types and synchronization primitives from <code>&lt;atomic&gt;</code> and <code>&lt;mutex&gt;</code>.</li>
</ul>
<p><strong>Example with Multithreading:</strong></p>
<pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;thread&gt;
#include &lt;atomic&gt;

class SharedCounter &#123;
public:
    SharedCounter() : count(0) &#123;&#125;

    void increment() &#123;
        ++count; // Atomic operation
    &#125;

    int getCount() const &#123;
        return count.load();
    &#125;

private:
    std::atomic&lt;int&gt; count; // Atomic variable for thread-safe operations
&#125;;

int main() &#123;
    SharedCounter counter;
    std::thread t1([&amp;counter]() &#123;
        for(int i = 0; i &lt; 1000; ++i) &#123;
            counter.increment();
        &#125;
    &#125;);

    std::thread t2([&amp;counter]() &#123;
        for(int i = 0; i &lt; 1000; ++i) &#123;
            counter.increment();
        &#125;
    &#125;);

    t1.join();
    t2.join();

    std::cout &lt;&lt; &quot;Final count: &quot; &lt;&lt; counter.getCount() &lt;&lt; std::endl; // Outputs: Final count: 2000

    return 0;
&#125;
</code></pre>
<p>In this example, using <code>std::atomic&lt;int&gt;</code> ensures that increments are thread-safe without needing the <code>volatile</code> keyword.</p>
<hr>
<h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><p>In this chapter, you’ve explored the foundational principles of <strong>Object-Oriented Programming (OOP)</strong> in C++:</p>
<ul>
<li><strong>Classes and Objects</strong>: Learned how to define classes as blueprints for objects and create instances from them.</li>
<li><strong>Constructors and Destructors</strong>: Gained insights into object initialization and cleanup through various types of constructors and destructors.</li>
<li><strong>Copy and Move Semantics</strong>: Learned how to efficiently copy and move objects, optimizing performance and resource management.</li>
<li><strong>Inheritance and Polymorphism</strong>: Discovered how to create hierarchical relationships between classes and enable run-time polymorphism using virtual functions.</li>
<li><strong>Operator Overloading</strong>: Understood how to redefine operators for user-defined types to enhance code readability and intuitiveness.</li>
<li><strong>Union and Struct as Special Classes</strong>: Explored the unique characteristics and use cases of <code>union</code> and <code>struct</code> in C++.</li>
<li><strong>Type Conversions</strong>: Mastered implicit and explicit type conversions, utilizing casting operators to ensure safe and efficient type handling.</li>
<li><strong>Variable Modifiers (<code>const</code>, <code>static</code>, <code>mutable</code>, <code>volatile</code>)</strong>: Understood how these modifiers control variable behavior within classes.</li>
<li><strong>Virtual Functions and Abstract Classes</strong>: Delved into creating abstract interfaces and leveraging polymorphism for flexible and reusable code.</li>
</ul>
<p>Mastering these OOP concepts is crucial for building complex, maintainable, and scalable C++ applications. As you progress, you’ll apply these principles to design robust software systems that effectively model real-world scenarios.</p>
<hr>
<p>Now you’re ready to move on to <strong>Templates and Generic Programming</strong> where you’ll learn how to create flexible and reusable code components using templates.</p>
<p>Next chapter: <a href="/2024/09/27/cpp-unleash/02h-tplgenpgm">Templates and Generic Programming</a></p>

            
        </div>
    </div>
    <div class="post-tags">
        
        <span class="icon">
            <i class="fa-solid fa-tags fa-fw"></i>
        </span>
        
        
        
        <span class="tag">
            
            <a href="/tags/c-cpp/" style="color: #00a596">c-cpp</a>
        </span>
        
        <span class="tag">
            
            <a href="/tags/modern-cpp/" style="color: #03a9f4">modern-cpp</a>
        </span>
        
        <span class="tag">
            
            <a href="/tags/cpp-unleash/" style="color: #ff7d73">cpp-unleash</a>
        </span>
        
        <span class="tag">
            
            <a href="/tags/02Hero/" style="color: #03a9f4">02Hero</a>
        </span>
        
    </div>
    <a href="/2024/09/27/cpp-unleash/02h-oop/" class="go-post">阅读全文</a>
</div>

<div class="post">
    <a href="/2024/09/26/cpp-unleash/02h-ptrref/">
        <h2 class="post-title">C++ Unleashed: Pointers and References</h2>
    </a>
    <div class="category-and-date">
        
        <span class="category">
            <a href="/categories/tutor/">
                <span class="icon">
                    <i class="fa-solid fa-bookmark fa-fw"></i>
                </span>
                tutor
            </a>
        </span>
        
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2024/9/26
        </span>
        
        
    </div>
    <div class="description">
        <div class="content" v-pre>
            
            <p><em><strong>C++ Unleashed: From Zero to Hero</strong></em></p>
<p>Previous chapter: <a href="/2024/09/26/cpp-unleash/02h-arystr">Arrays and Strings</a></p>
<p><a href="/2024/09/26/cpp-unleash/02h-menu">Go to Table of Contents</a></p>
<h1 id="Pointers-and-References"><a href="#Pointers-and-References" class="headerlink" title="Pointers and References"></a>Pointers and References</h1><p>Pointers and references are fundamental concepts in C++ that provide powerful ways to manipulate memory and data. They are essential for understanding how variables are stored and accessed, enabling efficient programming techniques such as dynamic memory allocation, passing large objects without copying, and implementing data structures like linked lists and trees.</p>
<p>In this chapter, we’ll cover:</p>
<ul>
<li>Basics of Pointers<ul>
<li>Pointer Declaration and Initialization</li>
<li>Dereferencing and Pointer Arithmetic</li>
<li>Null Pointers</li>
</ul>
</li>
<li>References and Their Uses<ul>
<li>Reference Declaration and Initialization</li>
<li>Differences Between Pointers and References</li>
</ul>
</li>
<li>Dynamic Memory Allocation<ul>
<li><code>new</code> and <code>delete</code></li>
<li>Arrays and Dynamic Allocation</li>
</ul>
</li>
<li>Smart Pointers (<code>unique_ptr</code>, <code>shared_ptr</code>, <code>weak_ptr</code>)<ul>
<li>Introduction to Smart Pointers</li>
<li>Using <code>std::unique_ptr</code></li>
<li>Using <code>std::shared_ptr</code> and <code>std::weak_ptr</code></li>
</ul>
</li>
<li>Practical Examples<ul>
<li>Swapping Variables Using Pointers and References</li>
<li>Implementing a Simple Dynamic Array</li>
</ul>
</li>
</ul>
<h2 id="Basics-of-Pointers"><a href="#Basics-of-Pointers" class="headerlink" title="Basics of Pointers"></a>Basics of Pointers</h2><p>A <strong>pointer</strong> is a variable that holds the memory address of another variable. Pointers provide direct access to memory and allow for powerful programming techniques.</p>
<h3 id="Pointer-Declaration-and-Initialization"><a href="#Pointer-Declaration-and-Initialization" class="headerlink" title="Pointer Declaration and Initialization"></a>Pointer Declaration and Initialization</h3><h4 id="Syntax"><a href="#Syntax" class="headerlink" title="Syntax"></a>Syntax</h4><pre><code class="cpp">data_type* pointer_name;
</code></pre>
<ul>
<li><strong>data_type</strong>: The type of the variable the pointer will point to.</li>
<li><strong>pointer_name</strong>: The name of the pointer variable.</li>
</ul>
<h4 id="Examples"><a href="#Examples" class="headerlink" title="Examples"></a>Examples</h4><p><strong>Declaration without Initialization:</strong></p>
<pre><code class="cpp">int* ptr; // Pointer to an integer
</code></pre>
<p><strong>Declaration with Initialization:</strong></p>
<pre><code class="cpp">int value = 42;
int* ptr = &amp;value; // ptr holds the address of value
</code></pre>
<ul>
<li>The <code>&amp;</code> operator is the <strong>address-of</strong> operator, which gives the memory address of a variable.</li>
</ul>
<h3 id="Dereferencing-Pointers"><a href="#Dereferencing-Pointers" class="headerlink" title="Dereferencing Pointers"></a>Dereferencing Pointers</h3><p>The <strong>dereference</strong> operator <code>*</code> is used to access or modify the value at the memory address the pointer points to.</p>
<p><strong>Example:</strong></p>
<pre><code class="cpp">int value = 42;
int* ptr = &amp;value;

std::cout &lt;&lt; &quot;Value: &quot; &lt;&lt; value &lt;&lt; std::endl;       // Outputs 42
std::cout &lt;&lt; &quot;Pointer Address: &quot; &lt;&lt; ptr &lt;&lt; std::endl; // Outputs the memory address
std::cout &lt;&lt; &quot;Dereferenced Value: &quot; &lt;&lt; *ptr &lt;&lt; std::endl; // Outputs 42

// Modifying the value via the pointer
*ptr = 100;
std::cout &lt;&lt; &quot;Modified Value: &quot; &lt;&lt; value &lt;&lt; std::endl; // Outputs 100
</code></pre>
<h3 id="Pointer-Arithmetic"><a href="#Pointer-Arithmetic" class="headerlink" title="Pointer Arithmetic"></a>Pointer Arithmetic</h3><p>Pointers can be incremented or decremented to traverse arrays.</p>
<p><strong>Example:</strong></p>
<pre><code class="cpp">int arr[] = &#123;10, 20, 30, 40, 50&#125;;
int* ptr = arr; // Points to the first element

for (int i = 0; i &lt; 5; ++i) &#123;
    std::cout &lt;&lt; &quot;Element &quot; &lt;&lt; i &lt;&lt; &quot;: &quot; &lt;&lt; *(ptr + i) &lt;&lt; std::endl;
&#125;
</code></pre>
<ul>
<li>When you add <code>i</code> to a pointer, it moves <code>i</code> elements forward, considering the size of the data type it points to.</li>
</ul>
<h3 id="Null-Pointers"><a href="#Null-Pointers" class="headerlink" title="Null Pointers"></a>Null Pointers</h3><p>A null pointer is a pointer that doesn’t point to any valid memory address.</p>
<h4 id="Declaration"><a href="#Declaration" class="headerlink" title="Declaration"></a>Declaration</h4><pre><code class="cpp">int* ptr = nullptr; // C++11 and later
</code></pre>
<ul>
<li><code>nullptr</code> is a keyword introduced in C++11 to represent a null pointer.</li>
</ul>
<p><strong>Pre-C++11:</strong></p>
<pre><code class="cpp">int* ptr = 0;
int* ptr = NULL; // Requires including &lt;cstddef&gt;
</code></pre>
<h4 id="Checking-for-Null-Pointers"><a href="#Checking-for-Null-Pointers" class="headerlink" title="Checking for Null Pointers"></a>Checking for Null Pointers</h4><p>Always check if a pointer is null before dereferencing to avoid undefined behavior.</p>
<pre><code class="cpp">if (ptr != nullptr) &#123;
    // Safe to dereference ptr
&#125;
</code></pre>
<h2 id="References-and-Their-Uses"><a href="#References-and-Their-Uses" class="headerlink" title="References and Their Uses"></a>References and Their Uses</h2><p>A <strong>reference</strong> is an alias for another variable. Once a reference is initialized to a variable, it cannot be changed to refer to another variable.</p>
<h3 id="Reference-Declaration-and-Initialization"><a href="#Reference-Declaration-and-Initialization" class="headerlink" title="Reference Declaration and Initialization"></a>Reference Declaration and Initialization</h3><h4 id="Syntax-1"><a href="#Syntax-1" class="headerlink" title="Syntax"></a>Syntax</h4><pre><code class="cpp">data_type&amp; reference_name = variable_name;
</code></pre>
<ul>
<li><strong>data_type</strong>: The type of the variable.</li>
<li><strong>reference_name</strong>: The name of the reference.</li>
<li><strong>variable_name</strong>: The variable being referenced.</li>
</ul>
<h4 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h4><pre><code class="cpp">int value = 42;
int&amp; ref = value; // ref is a reference to value

std::cout &lt;&lt; &quot;Value: &quot; &lt;&lt; value &lt;&lt; std::endl; // Outputs 42
std::cout &lt;&lt; &quot;Reference: &quot; &lt;&lt; ref &lt;&lt; std::endl; // Outputs 42

// Modifying the value via the reference
ref = 100;
std::cout &lt;&lt; &quot;Modified Value: &quot; &lt;&lt; value &lt;&lt; std::endl; // Outputs 100
</code></pre>
<h3 id="References-as-Function-Parameters"><a href="#References-as-Function-Parameters" class="headerlink" title="References as Function Parameters"></a>References as Function Parameters</h3><p>References are commonly used to pass variables to functions without copying.</p>
<p><strong>Example:</strong></p>
<pre><code class="cpp">void increment(int&amp; num) &#123;
    num += 1;
&#125;

int main() &#123;
    int number = 5;
    increment(number);
    std::cout &lt;&lt; &quot;Number: &quot; &lt;&lt; number &lt;&lt; std::endl; // Outputs 6
    return 0;
&#125;
</code></pre>
<h3 id="Differences-Between-Pointers-and-References"><a href="#Differences-Between-Pointers-and-References" class="headerlink" title="Differences Between Pointers and References"></a>Differences Between Pointers and References</h3><ul>
<li><strong>Nullability:</strong><ul>
<li>Pointers can be null; references must be bound to a valid object upon initialization.</li>
</ul>
</li>
<li><strong>Reassignment:</strong><ul>
<li>Pointers can be reassigned to point to different objects; references cannot be reseated.</li>
</ul>
</li>
<li><strong>Syntax:</strong><ul>
<li>Accessing the value pointed to by a pointer requires dereferencing (<code>*ptr</code>); references can be used directly as the variable.</li>
</ul>
</li>
<li><strong>Memory Address:</strong><ul>
<li>A pointer holds a memory address; a reference is an alias for an existing variable.</li>
</ul>
</li>
</ul>
<p><strong>Example of Pointer Reassignment:</strong></p>
<pre><code class="cpp">int a = 10;
int b = 20;
int* ptr = &amp;a;
ptr = &amp;b; // Now ptr points to b
</code></pre>
<p><strong>References Cannot Be Reassigned:</strong></p>
<pre><code class="cpp">int a = 10;
int b = 20;
int&amp; ref = a;
// ref = &amp;b; // Error: Cannot rebind a reference
ref = b; // Assigns the value of b to a
</code></pre>
<h2 id="Dynamic-Memory-Allocation"><a href="#Dynamic-Memory-Allocation" class="headerlink" title="Dynamic Memory Allocation"></a>Dynamic Memory Allocation</h2><p>Dynamic memory allocation allows you to allocate memory at runtime, which is essential when the size of data structures cannot be determined at compile-time.</p>
<h3 id="new-and-delete"><a href="#new-and-delete" class="headerlink" title="new and delete"></a><code>new</code> and <code>delete</code></h3><ul>
<li><strong><code>new</code> Operator:</strong> Allocates memory on the heap and returns a pointer to it.</li>
<li><strong><code>delete</code> Operator:</strong> Deallocates memory previously allocated with <code>new</code>.</li>
</ul>
<h4 id="Allocating-and-Deallocating-Single-Variables"><a href="#Allocating-and-Deallocating-Single-Variables" class="headerlink" title="Allocating and Deallocating Single Variables"></a>Allocating and Deallocating Single Variables</h4><p><strong>Allocation:</strong></p>
<pre><code class="cpp">int* ptr = new int;       // Allocates an integer
*ptr = 42;

int* ptrWithValue = new int(42); // Allocates and initializes an integer
</code></pre>
<p><strong>Deallocation:</strong></p>
<pre><code class="cpp">delete ptr;
</code></pre>
<h4 id="Allocating-and-Deallocating-Arrays"><a href="#Allocating-and-Deallocating-Arrays" class="headerlink" title="Allocating and Deallocating Arrays"></a>Allocating and Deallocating Arrays</h4><p><strong>Allocation:</strong></p>
<pre><code class="cpp">int* arr = new int[5]; // Allocates an array of 5 integers
</code></pre>
<p><strong>Deallocation:</strong></p>
<pre><code class="cpp">delete[] arr;
</code></pre>
<ul>
<li><strong>Important:</strong> Use <code>delete[]</code> when deallocating memory allocated with <code>new[]</code>.</li>
</ul>
<h4 id="Example-1"><a href="#Example-1" class="headerlink" title="Example"></a>Example</h4><pre><code class="cpp">int main() &#123;
    int* numbers = new int[5];
    for (int i = 0; i &lt; 5; ++i) &#123;
        numbers[i] = i * 10;
    &#125;

    for (int i = 0; i &lt; 5; ++i) &#123;
        std::cout &lt;&lt; numbers[i] &lt;&lt; &quot; &quot;;
    &#125;
    std::cout &lt;&lt; std::endl;

    delete[] numbers; // Free the allocated memory
    return 0;
&#125;
</code></pre>
<h3 id="Memory-Leaks"><a href="#Memory-Leaks" class="headerlink" title="Memory Leaks"></a>Memory Leaks</h3><p>Failing to deallocate memory with <code>delete</code> or <code>delete[]</code> leads to memory leaks, which can exhaust system memory over time.</p>
<p><strong>Example of Memory Leak:</strong></p>
<pre><code class="cpp">void leakMemory() &#123;
    int* ptr = new int(42);
    // Forgot to delete ptr
&#125;
</code></pre>
<h2 id="Smart-Pointers"><a href="#Smart-Pointers" class="headerlink" title="Smart Pointers"></a>Smart Pointers</h2><p>Manual memory management with <code>new</code> and <code>delete</code> is error-prone. C++ provides smart pointers in the <code>&lt;memory&gt;</code> header to automate memory management.</p>
<h3 id="Introduction-to-Smart-Pointers"><a href="#Introduction-to-Smart-Pointers" class="headerlink" title="Introduction to Smart Pointers"></a>Introduction to Smart Pointers</h3><p>Smart pointers are classes that behave like pointers but manage the memory automatically.</p>
<ul>
<li><strong><code>std::unique_ptr</code>:</strong> Owns an object exclusively.</li>
<li><strong><code>std::shared_ptr</code>:</strong> Allows multiple pointers to share ownership of an object.</li>
<li><strong><code>std::weak_ptr</code>:</strong> Holds a non-owning reference to an object managed by <code>std::shared_ptr</code>.</li>
</ul>
<h3 id="Using-std-unique-ptr"><a href="#Using-std-unique-ptr" class="headerlink" title="Using std::unique_ptr"></a>Using <code>std::unique_ptr</code></h3><ul>
<li>Defined in <code>&lt;memory&gt;</code>.</li>
<li>Cannot be copied, only moved.</li>
<li>Automatically deletes the object when it goes out of scope.</li>
</ul>
<h4 id="Syntax-2"><a href="#Syntax-2" class="headerlink" title="Syntax"></a>Syntax</h4><pre><code class="cpp">std::unique_ptr&lt;data_type&gt; ptr(new data_type);
</code></pre>
<p><strong>Example:</strong></p>
<pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;memory&gt;

int main() &#123;
    std::unique_ptr&lt;int&gt; ptr(new int(42));
    std::cout &lt;&lt; &quot;Value: &quot; &lt;&lt; *ptr &lt;&lt; std::endl;

    // No need to delete; ptr will automatically clean up
    return 0;
&#125;
</code></pre>
<p><strong>Prefer <code>make_unique</code> (C++14 and later):</strong></p>
<pre><code class="cpp">auto ptr = std::make_unique&lt;int&gt;(42);
</code></pre>
<h4 id="Transferring-Ownership"><a href="#Transferring-Ownership" class="headerlink" title="Transferring Ownership"></a>Transferring Ownership</h4><pre><code class="cpp">std::unique_ptr&lt;int&gt; ptr1 = std::make_unique&lt;int&gt;(42);
std::unique_ptr&lt;int&gt; ptr2 = std::move(ptr1); // ptr1 is now null
</code></pre>
<h3 id="Using-std-shared-ptr-and-std-weak-ptr"><a href="#Using-std-shared-ptr-and-std-weak-ptr" class="headerlink" title="Using std::shared_ptr and std::weak_ptr"></a>Using <code>std::shared_ptr</code> and <code>std::weak_ptr</code></h3><h4 id="std-shared-ptr"><a href="#std-shared-ptr" class="headerlink" title="std::shared_ptr"></a><code>std::shared_ptr</code></h4><ul>
<li>Allows multiple pointers to own the same object.</li>
<li>The object is deleted when the last <code>std::shared_ptr</code> owning it is destroyed.</li>
</ul>
<p><strong>Example:</strong></p>
<pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;memory&gt;

int main() &#123;
    std::shared_ptr&lt;int&gt; ptr1 = std::make_shared&lt;int&gt;(42);
    &#123;
        std::shared_ptr&lt;int&gt; ptr2 = ptr1;
        std::cout &lt;&lt; &quot;Use count inside block: &quot; &lt;&lt; ptr1.use_count() &lt;&lt; std::endl; // Outputs 2
    &#125;
    std::cout &lt;&lt; &quot;Use count after block: &quot; &lt;&lt; ptr1.use_count() &lt;&lt; std::endl; // Outputs 1

    // Object is deleted when use_count reaches zero
    return 0;
&#125;
</code></pre>
<h4 id="std-weak-ptr"><a href="#std-weak-ptr" class="headerlink" title="std::weak_ptr"></a><code>std::weak_ptr</code></h4><ul>
<li>Provides a weak reference to an object managed by <code>std::shared_ptr</code>.</li>
<li>Does not contribute to the reference count.</li>
<li>Must be converted to <code>std::shared_ptr</code> to access the object.</li>
</ul>
<p><strong>Example:</strong></p>
<pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;memory&gt;

int main() &#123;
    std::shared_ptr&lt;int&gt; sharedPtr = std::make_shared&lt;int&gt;(42);
    std::weak_ptr&lt;int&gt; weakPtr = sharedPtr;

    if (auto lockedPtr = weakPtr.lock()) &#123;
        std::cout &lt;&lt; &quot;Value: &quot; &lt;&lt; *lockedPtr &lt;&lt; std::endl;
    &#125; else &#123;
        std::cout &lt;&lt; &quot;Object has been destroyed.&quot; &lt;&lt; std::endl;
    &#125;

    return 0;
&#125;
</code></pre>
<p><strong>Use Case:</strong> Avoiding cyclic references in data structures.</p>
<h2 id="Practical-Examples"><a href="#Practical-Examples" class="headerlink" title="Practical Examples"></a>Practical Examples</h2><h3 id="Swapping-Variables-Using-Pointers-and-References"><a href="#Swapping-Variables-Using-Pointers-and-References" class="headerlink" title="Swapping Variables Using Pointers and References"></a>Swapping Variables Using Pointers and References</h3><h4 id="Using-Pointers"><a href="#Using-Pointers" class="headerlink" title="Using Pointers"></a>Using Pointers</h4><pre><code class="cpp">void swap(int* a, int* b) &#123;
    if (a &amp;&amp; b) &#123; // Check for null pointers
        int temp = *a;
        *a = *b;
        *b = temp;
    &#125;
&#125;

int main() &#123;
    int x = 10;
    int y = 20;
    swap(&amp;x, &amp;y);
    std::cout &lt;&lt; &quot;x: &quot; &lt;&lt; x &lt;&lt; &quot;, y: &quot; &lt;&lt; y &lt;&lt; std::endl; // Outputs x: 20, y: 10
    return 0;
&#125;
</code></pre>
<h4 id="Using-References"><a href="#Using-References" class="headerlink" title="Using References"></a>Using References</h4><pre><code class="cpp">void swap(int&amp; a, int&amp; b) &#123;
    int temp = a;
    a = b;
    b = temp;
&#125;

int main() &#123;
    int x = 10;
    int y = 20;
    swap(x, y);
    std::cout &lt;&lt; &quot;x: &quot; &lt;&lt; x &lt;&lt; &quot;, y: &quot; &lt;&lt; y &lt;&lt; std::endl; // Outputs x: 20, y: 10
    return 0;
&#125;
</code></pre>
<h3 id="Implementing-a-Simple-Dynamic-Array"><a href="#Implementing-a-Simple-Dynamic-Array" class="headerlink" title="Implementing a Simple Dynamic Array"></a>Implementing a Simple Dynamic Array</h3><p>Let’s create a simple dynamic array class that manages its own memory.</p>
<pre><code class="cpp">#include &lt;iostream&gt;

class DynamicArray &#123;
private:
    int* data;
    size_t size;

public:
    DynamicArray(size_t size) : size(size) &#123;
        data = new int[size];
    &#125;

    ~DynamicArray() &#123;
        delete[] data;
    &#125;

    int&amp; operator[](size_t index) &#123;
        if (index &gt;= size) &#123;
            throw std::out_of_range(&quot;Index out of range&quot;);
        &#125;
        return data[index];
    &#125;

    size_t getSize() const &#123;
        return size;
    &#125;
&#125;;

int main() &#123;
    DynamicArray arr(5);

    for (size_t i = 0; i &lt; arr.getSize(); ++i) &#123;
        arr[i] = static_cast&lt;int&gt;(i * 10);
    &#125;

    for (size_t i = 0; i &lt; arr.getSize(); ++i) &#123;
        std::cout &lt;&lt; &quot;Element &quot; &lt;&lt; i &lt;&lt; &quot;: &quot; &lt;&lt; arr[i] &lt;&lt; std::endl;
    &#125;

    return 0;
&#125;
</code></pre>
<p><strong>Explanation:</strong></p>
<ul>
<li><strong>Constructor:</strong> Allocates memory for the array.</li>
<li><strong>Destructor:</strong> Deallocates memory to prevent memory leaks.</li>
<li><strong>Operator Overloading (<code>operator[]</code>):</strong> Allows array-style access with bounds checking.</li>
<li><strong>Exception Handling:</strong> Throws an exception if the index is out of range.</li>
</ul>
<h2 id="Exercises"><a href="#Exercises" class="headerlink" title="Exercises"></a>Exercises</h2><ol>
<li><p><strong>Pointer Basics</strong></p>
<p>Write a program that declares an integer variable, a pointer to it, and uses the pointer to modify the variable’s value.</p>
<p><strong>Solution:</strong></p>
<pre><code class="cpp">#include &lt;iostream&gt;

int main() &#123;
    int value = 10;
    int* ptr = &amp;value;

    std::cout &lt;&lt; &quot;Original Value: &quot; &lt;&lt; value &lt;&lt; std::endl;

    *ptr = 20;

    std::cout &lt;&lt; &quot;Modified Value: &quot; &lt;&lt; value &lt;&lt; std::endl;

    return 0;
&#125;
</code></pre>
</li>
<li><p><strong>Dynamic Memory Allocation</strong></p>
<p>Create a program that allocates memory for an array of integers at runtime, fills it with values, and then deallocates the memory.</p>
<p><strong>Solution:</strong></p>
<pre><code class="cpp">#include &lt;iostream&gt;

int main() &#123;
    size_t size;

    std::cout &lt;&lt; &quot;Enter the size of the array: &quot;;
    std::cin &gt;&gt; size;

    int* arr = new int[size];

    for (size_t i = 0; i &lt; size; ++i) &#123;
        arr[i] = static_cast&lt;int&gt;(i * i);
    &#125;

    std::cout &lt;&lt; &quot;Array Elements:&quot; &lt;&lt; std::endl;
    for (size_t i = 0; i &lt; size; ++i) &#123;
        std::cout &lt;&lt; arr[i] &lt;&lt; &quot; &quot;;
    &#125;
    std::cout &lt;&lt; std::endl;

    delete[] arr;

    return 0;
&#125;
</code></pre>
</li>
<li><p><strong>Using Smart Pointers</strong></p>
<p>Modify the previous program to use <code>std::unique_ptr</code> instead of raw pointers.</p>
<p><strong>Solution:</strong></p>
<pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;memory&gt;

int main() &#123;
    size_t size;

    std::cout &lt;&lt; &quot;Enter the size of the array: &quot;;
    std::cin &gt;&gt; size;

    std::unique_ptr&lt;int[]&gt; arr(new int[size]);

    for (size_t i = 0; i &lt; size; ++i) &#123;
        arr[i] = static_cast&lt;int&gt;(i * i);
    &#125;

    std::cout &lt;&lt; &quot;Array Elements:&quot; &lt;&lt; std::endl;
    for (size_t i = 0; i &lt; size; ++i) &#123;
        std::cout &lt;&lt; arr[i] &lt;&lt; &quot; &quot;;
    &#125;
    std::cout &lt;&lt; std::endl;

    // Memory is automatically deallocated

    return 0;
&#125;
</code></pre>
</li>
<li><p><strong>Reference Parameters</strong></p>
<p>Write a function that calculates the area and perimeter of a rectangle and returns the results via reference parameters.</p>
<p><strong>Solution:</strong></p>
<pre><code class="cpp">#include &lt;iostream&gt;

void calculateRectangle(double width, double height, double&amp; area, double&amp; perimeter) &#123;
    area = width * height;
    perimeter = 2 * (width + height);
&#125;

int main() &#123;
    double width = 5.0;
    double height = 3.0;
    double area, perimeter;

    calculateRectangle(width, height, area, perimeter);

    std::cout &lt;&lt; &quot;Area: &quot; &lt;&lt; area &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;Perimeter: &quot; &lt;&lt; perimeter &lt;&lt; std::endl;

    return 0;
&#125;
</code></pre>
</li>
</ol>
<h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><p>In this chapter, you’ve learned about:</p>
<ul>
<li><strong>Pointers:</strong><ul>
<li>How to declare and initialize pointers.</li>
<li>Dereferencing pointers and pointer arithmetic.</li>
<li>Handling null pointers and avoiding undefined behavior.</li>
</ul>
</li>
<li><strong>References:</strong><ul>
<li>Declaring references and using them to alias variables.</li>
<li>Differences between pointers and references.</li>
</ul>
</li>
<li><strong>Dynamic Memory Allocation:</strong><ul>
<li>Using <code>new</code> and <code>delete</code> to manage memory at runtime.</li>
<li>Allocating and deallocating arrays dynamically.</li>
<li>Avoiding memory leaks through proper deallocation.</li>
</ul>
</li>
<li><strong>Smart Pointers:</strong><ul>
<li>Introduction to <code>std::unique_ptr</code>, <code>std::shared_ptr</code>, and <code>std::weak_ptr</code>.</li>
<li>Automating memory management and preventing resource leaks.</li>
</ul>
</li>
<li><strong>Practical Applications:</strong><ul>
<li>Swapping variables using pointers and references.</li>
<li>Implementing a simple dynamic array class.</li>
</ul>
</li>
</ul>
<p>Understanding pointers and references is crucial in C++ programming, as they provide the foundation for dynamic memory management, efficient data manipulation, and advanced programming techniques. Mastery of these concepts will greatly enhance your ability to write robust and efficient C++ programs.</p>
<hr>
<p>In the next chapter, we’ll explore <strong>Object-Oriented Programming</strong>, delving into classes, objects, and the principles that enable modular and reusable code.</p>
<p>Next chapter: <a href="/2024/09/27/cpp-unleash/02h-oop">Object-Oriented Programming</a></p>

            
        </div>
    </div>
    <div class="post-tags">
        
        <span class="icon">
            <i class="fa-solid fa-tags fa-fw"></i>
        </span>
        
        
        
        <span class="tag">
            
            <a href="/tags/c-cpp/" style="color: #00a596">c-cpp</a>
        </span>
        
        <span class="tag">
            
            <a href="/tags/modern-cpp/" style="color: #03a9f4">modern-cpp</a>
        </span>
        
        <span class="tag">
            
            <a href="/tags/cpp-unleash/" style="color: #00bcd4">cpp-unleash</a>
        </span>
        
        <span class="tag">
            
            <a href="/tags/02Hero/" style="color: #ff7d73">02Hero</a>
        </span>
        
    </div>
    <a href="/2024/09/26/cpp-unleash/02h-ptrref/" class="go-post">阅读全文</a>
</div>

<div class="post">
    <a href="/2024/09/26/cpp-unleash/02h-arystr/">
        <h2 class="post-title">C++ Unleashed: Arrays and Strings</h2>
    </a>
    <div class="category-and-date">
        
        <span class="category">
            <a href="/categories/tutor/">
                <span class="icon">
                    <i class="fa-solid fa-bookmark fa-fw"></i>
                </span>
                tutor
            </a>
        </span>
        
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2024/9/26
        </span>
        
        
    </div>
    <div class="description">
        <div class="content" v-pre>
            
            <p><em><strong>C++ Unleashed: From Zero to Hero</strong></em></p>
<p>Previous chapter: <a href="/2024/09/26/cpp-unleash/02h-func">Functions</a></p>
<p><a href="/2024/09/26/cpp-unleash/02h-menu">Go to Table of Contents</a></p>
<h1 id="Arrays-and-Strings"><a href="#Arrays-and-Strings" class="headerlink" title="Arrays and Strings"></a>Arrays and Strings</h1><p>Arrays and strings are fundamental data structures in C++ that allow you to store and manipulate collections of data. Understanding how to work with them is crucial for effective programming.</p>
<p>In this chapter, we’ll cover:</p>
<ul>
<li><strong>Arrays</strong><ul>
<li>C-Style Arrays<ul>
<li>Declaration and Initialization</li>
<li>Accessing Elements</li>
<li>Multidimensional Arrays</li>
<li>Arrays and Functions</li>
<li>Limitations of C-Style Arrays</li>
</ul>
</li>
<li><strong><code>std::array</code></strong><ul>
<li>Introduction</li>
<li>Declaration and Initialization</li>
<li>Accessing Elements</li>
<li>Iterating Over <code>std::array</code></li>
<li>Passing <code>std::array</code> to Functions</li>
</ul>
</li>
</ul>
</li>
<li><strong>C-Style Strings</strong><ul>
<li>Character Arrays</li>
<li>Common Functions</li>
</ul>
</li>
<li><strong>The <code>std::string</code> Class</strong><ul>
<li>Basic Usage</li>
<li>String Operations</li>
<li>Converting Between Strings and Numbers</li>
</ul>
</li>
</ul>
<h2 id="Arrays"><a href="#Arrays" class="headerlink" title="Arrays"></a>Arrays</h2><p>An array is a collection of elements of the same data type stored in contiguous memory locations. Arrays provide a way to store multiple values under a single variable name.</p>
<h3 id="C-Style-Arrays"><a href="#C-Style-Arrays" class="headerlink" title="C-Style Arrays"></a>C-Style Arrays</h3><h4 id="Declaration-and-Initialization"><a href="#Declaration-and-Initialization" class="headerlink" title="Declaration and Initialization"></a>Declaration and Initialization</h4><p><strong>Syntax:</strong></p>
<pre><code class="cpp">data_type array_name[array_size];
</code></pre>
<ul>
<li><strong>data_type</strong>: The type of elements the array will hold.</li>
<li><strong>array_name</strong>: The name of the array.</li>
<li><strong>array_size</strong>: The number of elements in the array.</li>
</ul>
<p><strong>Examples:</strong></p>
<p><strong>Declaration without Initialization:</strong></p>
<pre><code class="cpp">int numbers[5]; // An array of 5 integers
</code></pre>
<p><strong>Declaration with Initialization:</strong></p>
<pre><code class="cpp">int numbers[5] = &#123;1, 2, 3, 4, 5&#125;;
</code></pre>
<p><strong>Omitting the Size:</strong></p>
<pre><code class="cpp">int numbers[] = &#123;1, 2, 3, 4, 5&#125;; // Size deduced from the number of elements
</code></pre>
<p><strong>Partial Initialization:</strong></p>
<pre><code class="cpp">int numbers[5] = &#123;1, 2&#125;; // Remaining elements initialized to 0
</code></pre>
<h4 id="Accessing-Elements"><a href="#Accessing-Elements" class="headerlink" title="Accessing Elements"></a>Accessing Elements</h4><p>Array elements are accessed using zero-based indexing.</p>
<p><strong>Syntax:</strong></p>
<pre><code class="cpp">array_name[index];
</code></pre>
<ul>
<li><strong>index</strong>: An integer representing the position of the element (starting from 0).</li>
</ul>
<p><strong>Example:</strong></p>
<pre><code class="cpp">#include &lt;iostream&gt;

int main() &#123;
    int numbers[] = &#123;10, 20, 30, 40, 50&#125;;

    std::cout &lt;&lt; &quot;First element: &quot; &lt;&lt; numbers[0] &lt;&lt; std::endl; // Outputs 10
    std::cout &lt;&lt; &quot;Third element: &quot; &lt;&lt; numbers[2] &lt;&lt; std::endl; // Outputs 30

    // Modifying an element
    numbers[1] = 25;
    std::cout &lt;&lt; &quot;Modified second element: &quot; &lt;&lt; numbers[1] &lt;&lt; std::endl; // Outputs 25

    return 0;
&#125;
</code></pre>
<h4 id="Iterating-Over-Arrays"><a href="#Iterating-Over-Arrays" class="headerlink" title="Iterating Over Arrays"></a>Iterating Over Arrays</h4><p>You can use loops to iterate over array elements.</p>
<p><strong>Using a <code>for</code> Loop:</strong></p>
<pre><code class="cpp">int numbers[] = &#123;10, 20, 30, 40, 50&#125;;
int size = sizeof(numbers) / sizeof(numbers[0]);

for (int i = 0; i &lt; size; ++i) &#123;
    std::cout &lt;&lt; &quot;Element at index &quot; &lt;&lt; i &lt;&lt; &quot;: &quot; &lt;&lt; numbers[i] &lt;&lt; std::endl;
&#125;
</code></pre>
<p><strong>Using a Range-Based <code>for</code> Loop (C++11 and later):</strong></p>
<p>C-style arrays can be iterated over using range-based for loops.</p>
<pre><code class="cpp">for (int num : numbers) &#123;
    std::cout &lt;&lt; &quot;Element: &quot; &lt;&lt; num &lt;&lt; std::endl;
&#125;
</code></pre>
<h4 id="Multidimensional-Arrays"><a href="#Multidimensional-Arrays" class="headerlink" title="Multidimensional Arrays"></a>Multidimensional Arrays</h4><p>Arrays can have more than one dimension, such as two-dimensional arrays (matrices).</p>
<h5 id="Declaration"><a href="#Declaration" class="headerlink" title="Declaration"></a>Declaration</h5><pre><code class="cpp">data_type array_name[size1][size2];
</code></pre>
<p><strong>Example:</strong></p>
<pre><code class="cpp">int matrix[3][4]; // 3 rows and 4 columns
</code></pre>
<h5 id="Initialization"><a href="#Initialization" class="headerlink" title="Initialization"></a>Initialization</h5><pre><code class="cpp">int matrix[2][3] = &#123;
    &#123;1, 2, 3&#125;,
    &#123;4, 5, 6&#125;
&#125;;
</code></pre>
<h5 id="Accessing-Elements-1"><a href="#Accessing-Elements-1" class="headerlink" title="Accessing Elements"></a>Accessing Elements</h5><pre><code class="cpp">int value = matrix[1][2]; // Accesses element in second row, third column
</code></pre>
<h5 id="Iterating-Over-Multidimensional-Arrays"><a href="#Iterating-Over-Multidimensional-Arrays" class="headerlink" title="Iterating Over Multidimensional Arrays"></a>Iterating Over Multidimensional Arrays</h5><pre><code class="cpp">for (int i = 0; i &lt; 2; ++i) &#123;
    for (int j = 0; j &lt; 3; ++j) &#123;
        std::cout &lt;&lt; &quot;Element at [&quot; &lt;&lt; i &lt;&lt; &quot;][&quot; &lt;&lt; j &lt;&lt; &quot;]: &quot; &lt;&lt; matrix[i][j] &lt;&lt; std::endl;
    &#125;
&#125;
</code></pre>
<h4 id="Arrays-and-Functions"><a href="#Arrays-and-Functions" class="headerlink" title="Arrays and Functions"></a>Arrays and Functions</h4><h5 id="Passing-Arrays-to-Functions"><a href="#Passing-Arrays-to-Functions" class="headerlink" title="Passing Arrays to Functions"></a>Passing Arrays to Functions</h5><p>You can pass arrays to functions by specifying the array parameter.</p>
<p><strong>Example:</strong></p>
<pre><code class="cpp">void printArray(int arr[], int size) &#123;
    for (int i = 0; i &lt; size; ++i) &#123;
        std::cout &lt;&lt; arr[i] &lt;&lt; &quot; &quot;;
    &#125;
    std::cout &lt;&lt; std::endl;
&#125;

int main() &#123;
    int numbers[] = &#123;1, 2, 3, 4, 5&#125;;
    int size = sizeof(numbers) / sizeof(numbers[0]);

    printArray(numbers, size);

    return 0;
&#125;
</code></pre>
<h5 id="Returning-Arrays-from-Functions"><a href="#Returning-Arrays-from-Functions" class="headerlink" title="Returning Arrays from Functions"></a>Returning Arrays from Functions</h5><p>C++ does not allow returning arrays directly from functions, but you can return pointers or use <code>std::array</code> or <code>std::vector</code> (covered later) for safer alternatives.</p>
<h4 id="Limitations-of-C-Style-Arrays"><a href="#Limitations-of-C-Style-Arrays" class="headerlink" title="Limitations of C-Style Arrays"></a>Limitations of C-Style Arrays</h4><ul>
<li><strong>Fixed Size:</strong> The size of C-style arrays must be known at compile-time (unless using dynamic allocation).</li>
<li><strong>No Bounds Checking:</strong> Accessing out-of-bounds elements leads to undefined behavior.</li>
<li><strong>Limited Functionality:</strong> Lacks built-in methods for common operations.</li>
<li><strong>Cannot Be Copied or Assigned Easily:</strong> Assigning one array to another is not straightforward.</li>
</ul>
<p><strong>Note:</strong> Due to these limitations, it’s recommended to use <code>std::array</code> or <code>std::vector</code> from the Standard Library for safer and more flexible array usage.</p>
<h3 id="std-array"><a href="#std-array" class="headerlink" title="std::array"></a><code>std::array</code></h3><p>The <code>std::array</code> class template (defined in the <code>&lt;array&gt;</code> header) provides a fixed-size array with additional functionalities and safety compared to C-style arrays. It is a container that encapsulates fixed-size arrays.</p>
<h4 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h4><ul>
<li><strong>Fixed Size:</strong> The size is fixed at compile-time.</li>
<li><strong>Type Safe:</strong> Strongly typed and supports member functions.</li>
<li><strong>Standard Library Integration:</strong> Works well with other Standard Library components.</li>
</ul>
<h4 id="Declaration-and-Initialization-1"><a href="#Declaration-and-Initialization-1" class="headerlink" title="Declaration and Initialization"></a>Declaration and Initialization</h4><p><strong>Syntax:</strong></p>
<pre><code class="cpp">std::array&lt;data_type, array_size&gt; array_name;
</code></pre>
<ul>
<li><strong>data_type:</strong> The type of elements the array will hold.</li>
<li><strong>array_size:</strong> The number of elements in the array.</li>
</ul>
<p><strong>Examples:</strong></p>
<p><strong>Declaration without Initialization:</strong></p>
<pre><code class="cpp">#include &lt;array&gt;

std::array&lt;int, 5&gt; numbers;
</code></pre>
<p><strong>Declaration with Initialization:</strong></p>
<pre><code class="cpp">std::array&lt;int, 5&gt; numbers = &#123;1, 2, 3, 4, 5&#125;;
</code></pre>
<p><strong>Using Uniform Initialization (C++11 and later):</strong></p>
<pre><code class="cpp">std::array&lt;int, 5&gt; numbers&#123;1, 2, 3, 4, 5&#125;;
</code></pre>
<h4 id="Accessing-Elements-2"><a href="#Accessing-Elements-2" class="headerlink" title="Accessing Elements"></a>Accessing Elements</h4><p>Elements can be accessed similarly to C-style arrays using the subscript operator <code>[]</code>.</p>
<p><strong>Example:</strong></p>
<pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;array&gt;

int main() &#123;
    std::array&lt;int, 5&gt; numbers = &#123;10, 20, 30, 40, 50&#125;;

    std::cout &lt;&lt; &quot;First element: &quot; &lt;&lt; numbers[0] &lt;&lt; std::endl; // Outputs 10
    std::cout &lt;&lt; &quot;Third element: &quot; &lt;&lt; numbers[2] &lt;&lt; std::endl; // Outputs 30

    // Modifying an element
    numbers[1] = 25;
    std::cout &lt;&lt; &quot;Modified second element: &quot; &lt;&lt; numbers[1] &lt;&lt; std::endl; // Outputs 25

    return 0;
&#125;
</code></pre>
<h4 id="Bounds-Checking-with-at"><a href="#Bounds-Checking-with-at" class="headerlink" title="Bounds Checking with at()"></a>Bounds Checking with <code>at()</code></h4><p>Unlike C-style arrays, <code>std::array</code> provides the <code>at()</code> member function that performs bounds checking and throws an exception if the index is out of range.</p>
<p><strong>Example:</strong></p>
<pre><code class="cpp">try &#123;
    int value = numbers.at(10); // Throws std::out_of_range
&#125; catch (const std::out_of_range&amp; e) &#123;
    std::cerr &lt;&lt; &quot;Out of range error: &quot; &lt;&lt; e.what() &lt;&lt; std::endl;
&#125;
</code></pre>
<h4 id="Accessing-Size"><a href="#Accessing-Size" class="headerlink" title="Accessing Size"></a>Accessing Size</h4><p>Use the <code>size()</code> member function to get the number of elements.</p>
<pre><code class="cpp">size_t size = numbers.size(); // Returns 5
</code></pre>
<h4 id="Iterating-Over-std-array"><a href="#Iterating-Over-std-array" class="headerlink" title="Iterating Over std::array"></a>Iterating Over <code>std::array</code></h4><p><strong>Using a Range-Based <code>for</code> Loop:</strong></p>
<pre><code class="cpp">for (int num : numbers) &#123;
    std::cout &lt;&lt; &quot;Element: &quot; &lt;&lt; num &lt;&lt; std::endl;
&#125;
</code></pre>
<p><strong>Using Iterators:</strong></p>
<pre><code class="cpp">for (auto it = numbers.begin(); it != numbers.end(); ++it) &#123;
    std::cout &lt;&lt; &quot;Element: &quot; &lt;&lt; *it &lt;&lt; std::endl;
&#125;
</code></pre>
<h4 id="Passing-std-array-to-Functions"><a href="#Passing-std-array-to-Functions" class="headerlink" title="Passing std::array to Functions"></a>Passing <code>std::array</code> to Functions</h4><p>When passing <code>std::array</code> to functions, you can pass it by reference or value.</p>
<p><strong>Example:</strong></p>
<pre><code class="cpp">void printArray(const std::array&lt;int, 5&gt;&amp; arr) &#123;
    for (int num : arr) &#123;
        std::cout &lt;&lt; num &lt;&lt; &quot; &quot;;
    &#125;
    std::cout &lt;&lt; std::endl;
&#125;

int main() &#123;
    std::array&lt;int, 5&gt; numbers = &#123;1, 2, 3, 4, 5&#125;;
    printArray(numbers);
    return 0;
&#125;
</code></pre>
<h4 id="Multidimensional-std-array"><a href="#Multidimensional-std-array" class="headerlink" title="Multidimensional std::array"></a>Multidimensional <code>std::array</code></h4><p>You can create multidimensional arrays by nesting <code>std::array</code>.</p>
<p><strong>Example:</strong></p>
<pre><code class="cpp">std::array&lt;std::array&lt;int, 3&gt;, 2&gt; matrix = &#123;&#123;
    &#123;1, 2, 3&#125;,
    &#123;4, 5, 6&#125;
&#125;&#125;;
</code></pre>
<p><strong>Accessing Elements:</strong></p>
<pre><code class="cpp">int value = matrix[1][2]; // Accesses element in second row, third column
</code></pre>
<h2 id="C-Style-Strings"><a href="#C-Style-Strings" class="headerlink" title="C-Style Strings"></a>C-Style Strings</h2><p>C-style strings are arrays of characters terminated by a null character <code>&#39;\0&#39;</code>.</p>
<h3 id="Character-Arrays"><a href="#Character-Arrays" class="headerlink" title="Character Arrays"></a>Character Arrays</h3><h4 id="Declaration-and-Initialization-2"><a href="#Declaration-and-Initialization-2" class="headerlink" title="Declaration and Initialization"></a>Declaration and Initialization</h4><pre><code class="cpp">char greeting[] = &quot;Hello&quot;;
</code></pre>
<ul>
<li>The array <code>greeting</code> has 6 elements: <code>&#39;H&#39;</code>, <code>&#39;e&#39;</code>, <code>&#39;l&#39;</code>, <code>&#39;l&#39;</code>, <code>&#39;o&#39;</code>, <code>&#39;\0&#39;</code>.</li>
</ul>
<h4 id="Accessing-Characters"><a href="#Accessing-Characters" class="headerlink" title="Accessing Characters"></a>Accessing Characters</h4><pre><code class="cpp">char firstChar = greeting[0]; // &#39;H&#39;
</code></pre>
<h3 id="Common-Functions"><a href="#Common-Functions" class="headerlink" title="Common Functions"></a>Common Functions</h3><p>Functions for handling C-style strings are in the <code>&lt;cstring&gt;</code> header.</p>
<h4 id="strlen"><a href="#strlen" class="headerlink" title="strlen"></a><code>strlen</code></h4><p>Returns the length of the string (excluding the null terminator).</p>
<pre><code class="cpp">#include &lt;cstring&gt;

size_t length = std::strlen(greeting); // Returns 5
</code></pre>
<h4 id="strcpy"><a href="#strcpy" class="headerlink" title="strcpy"></a><code>strcpy</code></h4><p>Copies one string to another.</p>
<pre><code class="cpp">char source[] = &quot;World&quot;;
char destination[10];

std::strcpy(destination, source); // destination now contains &quot;World&quot;
</code></pre>
<h4 id="strcat"><a href="#strcat" class="headerlink" title="strcat"></a><code>strcat</code></h4><p>Concatenates two strings.</p>
<pre><code class="cpp">char s1[20] = &quot;Hello &quot;;
char s2[] = &quot;World&quot;;

std::strcat(s1, s2); // s1 now contains &quot;Hello World&quot;
</code></pre>
<h4 id="strcmp"><a href="#strcmp" class="headerlink" title="strcmp"></a><code>strcmp</code></h4><p>Compares two strings.</p>
<pre><code class="cpp">if (std::strcmp(s1, s2) == 0) &#123;
    std::cout &lt;&lt; &quot;Strings are equal.&quot; &lt;&lt; std::endl;
&#125;
</code></pre>
<p><strong>Warning:</strong> Be cautious with buffer sizes to avoid overruns. Prefer using safer alternatives like <code>strncpy</code>, <code>strncat</code>, or better yet, <code>std::string</code>.</p>
<h2 id="The-std-string-Class"><a href="#The-std-string-Class" class="headerlink" title="The std::string Class"></a>The <code>std::string</code> Class</h2><p>The <code>std::string</code> class (from the <code>&lt;string&gt;</code> header) provides a safer and more convenient way to work with strings.</p>
<h3 id="Basic-Usage"><a href="#Basic-Usage" class="headerlink" title="Basic Usage"></a>Basic Usage</h3><h4 id="Declaration-and-Initialization-3"><a href="#Declaration-and-Initialization-3" class="headerlink" title="Declaration and Initialization"></a>Declaration and Initialization</h4><pre><code class="cpp">#include &lt;string&gt;

std::string greeting = &quot;Hello&quot;;
</code></pre>
<h4 id="Input-and-Output"><a href="#Input-and-Output" class="headerlink" title="Input and Output"></a>Input and Output</h4><pre><code class="cpp">std::string name;

std::cout &lt;&lt; &quot;Enter your name: &quot;;
std::cin &gt;&gt; name; // Reads input until the first whitespace

std::cout &lt;&lt; &quot;Hello, &quot; &lt;&lt; name &lt;&lt; &quot;!&quot; &lt;&lt; std::endl;
</code></pre>
<p><strong>Reading Full Lines:</strong></p>
<pre><code class="cpp">std::string line;

std::cout &lt;&lt; &quot;Enter a line: &quot;;
std::getline(std::cin, line);

std::cout &lt;&lt; &quot;You entered: &quot; &lt;&lt; line &lt;&lt; std::endl;
</code></pre>
<h3 id="String-Operations"><a href="#String-Operations" class="headerlink" title="String Operations"></a>String Operations</h3><h4 id="Concatenation"><a href="#Concatenation" class="headerlink" title="Concatenation"></a>Concatenation</h4><pre><code class="cpp">std::string s1 = &quot;Hello&quot;;
std::string s2 = &quot;World&quot;;
std::string s3 = s1 + &quot; &quot; + s2; // &quot;Hello World&quot;
</code></pre>
<h4 id="Length"><a href="#Length" class="headerlink" title="Length"></a>Length</h4><pre><code class="cpp">size_t length = s1.length(); // or s1.size()
</code></pre>
<h4 id="Accessing-Characters-1"><a href="#Accessing-Characters-1" class="headerlink" title="Accessing Characters"></a>Accessing Characters</h4><pre><code class="cpp">char firstChar = s1[0]; // &#39;H&#39;
s1[0] = &#39;h&#39;;            // s1 is now &quot;hello&quot;
</code></pre>
<h4 id="Substrings"><a href="#Substrings" class="headerlink" title="Substrings"></a>Substrings</h4><pre><code class="cpp">std::string s = &quot;Hello World&quot;;
std::string sub = s.substr(6, 5); // &quot;World&quot;
</code></pre>
<h4 id="Insertion-and-Erasure"><a href="#Insertion-and-Erasure" class="headerlink" title="Insertion and Erasure"></a>Insertion and Erasure</h4><pre><code class="cpp">s.insert(5, &quot;,&quot;);      // &quot;Hello, World&quot;
s.erase(5, 1);         // &quot;Hello World&quot;
</code></pre>
<h4 id="Finding-Substrings"><a href="#Finding-Substrings" class="headerlink" title="Finding Substrings"></a>Finding Substrings</h4><pre><code class="cpp">size_t pos = s.find(&quot;World&quot;); // Returns index where &quot;World&quot; starts
</code></pre>
<h4 id="Comparison"><a href="#Comparison" class="headerlink" title="Comparison"></a>Comparison</h4><pre><code class="cpp">if (s1 == s2) &#123;
    std::cout &lt;&lt; &quot;Strings are equal.&quot; &lt;&lt; std::endl;
&#125;
</code></pre>
<h3 id="Converting-Between-Strings-and-Numbers"><a href="#Converting-Between-Strings-and-Numbers" class="headerlink" title="Converting Between Strings and Numbers"></a>Converting Between Strings and Numbers</h3><h4 id="String-to-Number"><a href="#String-to-Number" class="headerlink" title="String to Number"></a>String to Number</h4><ul>
<li><strong><code>std::stoi</code></strong>: Convert string to <code>int</code>.</li>
<li><strong><code>std::stod</code></strong>: Convert string to <code>double</code>.</li>
</ul>
<pre><code class="cpp">#include &lt;string&gt;

std::string s = &quot;123&quot;;
int num = std::stoi(s); // num = 123
</code></pre>
<h4 id="Number-to-String"><a href="#Number-to-String" class="headerlink" title="Number to String"></a>Number to String</h4><ul>
<li><strong><code>std::to_string</code></strong>: Convert number to string.</li>
</ul>
<pre><code class="cpp">int num = 456;
std::string s = std::to_string(num); // s = &quot;456&quot;
</code></pre>
<p><strong>Example:</strong></p>
<pre><code class="cpp">double pi = 3.14159;
std::string s = &quot;The value of pi is &quot; + std::to_string(pi);
</code></pre>
<h2 id="Practical-Example-Word-Counter"><a href="#Practical-Example-Word-Counter" class="headerlink" title="Practical Example: Word Counter"></a>Practical Example: Word Counter</h2><p>Let’s create a program that counts the number of words in a sentence entered by the user.</p>
<pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;sstream&gt;

int main() &#123;
    std::string sentence;
    
    std::cout &lt;&lt; &quot;Enter a sentence: &quot;;
    std::getline(std::cin, sentence);

    std::istringstream stream(sentence);
    std::string word;
    int wordCount = 0;

    while (stream &gt;&gt; word) &#123;
        ++wordCount;
    &#125;

    std::cout &lt;&lt; &quot;Number of words: &quot; &lt;&lt; wordCount &lt;&lt; std::endl;

    return 0;
&#125;
</code></pre>
<p><strong>Explanation:</strong></p>
<ul>
<li><strong><code>std::getline</code></strong>: Reads the full line entered by the user.</li>
<li><strong><code>std::istringstream</code></strong>: Allows us to treat the string as a stream to extract words.</li>
<li><strong><code>stream &gt;&gt; word</code></strong>: Extracts words separated by whitespace.</li>
</ul>
<h2 id="Exercises"><a href="#Exercises" class="headerlink" title="Exercises"></a>Exercises</h2><ol>
<li><p><strong>Array Sum with <code>std::array</code></strong></p>
<p>Rewrite the array sum program using <code>std::array</code>.</p>
<p><strong>Solution:</strong></p>
<pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;array&gt;

int main() &#123;
    std::array&lt;int, 5&gt; numbers = &#123;5, 10, 15, 20, 25&#125;;
    int sum = 0;

    for (int num : numbers) &#123;
        sum += num;
    &#125;

    double average = static_cast&lt;double&gt;(sum) / numbers.size();

    std::cout &lt;&lt; &quot;Sum: &quot; &lt;&lt; sum &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;Average: &quot; &lt;&lt; average &lt;&lt; std::endl;

    return 0;
&#125;
</code></pre>
</li>
<li><p><strong>Matrix Addition with <code>std::array</code></strong></p>
<p>Create a program that adds two 2x2 matrices using <code>std::array</code> and displays the result.</p>
<p><strong>Solution:</strong></p>
<pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;array&gt;

int main() &#123;
    std::array&lt;std::array&lt;int, 2&gt;, 2&gt; matrix1 = &#123;&#123;&#123;1, 2&#125;, &#123;3, 4&#125;&#125;&#125;;
    std::array&lt;std::array&lt;int, 2&gt;, 2&gt; matrix2 = &#123;&#123;&#123;5, 6&#125;, &#123;7, 8&#125;&#125;&#125;;
    std::array&lt;std::array&lt;int, 2&gt;, 2&gt; result;

    for (size_t i = 0; i &lt; matrix1.size(); ++i) &#123;
        for (size_t j = 0; j &lt; matrix1[i].size(); ++j) &#123;
            result[i][j] = matrix1[i][j] + matrix2[i][j];
        &#125;
    &#125;

    std::cout &lt;&lt; &quot;Resultant Matrix:&quot; &lt;&lt; std::endl;
    for (const auto&amp; row : result) &#123;
        for (int elem : row) &#123;
            std::cout &lt;&lt; elem &lt;&lt; &quot; &quot;;
        &#125;
        std::cout &lt;&lt; std::endl;
    &#125;

    return 0;
&#125;
</code></pre>
</li>
<li><p><strong>String Reversal</strong></p>
<p>Write a function that reverses a <code>std::string</code>.</p>
<p><strong>Solution:</strong></p>
<pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;algorithm&gt;

std::string reverseString(const std::string&amp; str) &#123;
    std::string reversed = str;
    std::reverse(reversed.begin(), reversed.end());
    return reversed;
&#125;

int main() &#123;
    std::string original = &quot;Hello World&quot;;
    std::string reversed = reverseString(original);

    std::cout &lt;&lt; &quot;Original: &quot; &lt;&lt; original &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;Reversed: &quot; &lt;&lt; reversed &lt;&lt; std::endl;

    return 0;
&#125;
</code></pre>
</li>
<li><p><strong>Palindromic Strings</strong></p>
<p>Modify the palindrome check function from the previous chapter to ignore case and spaces.</p>
<p><strong>Solution:</strong></p>
<pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;algorithm&gt;
#include &lt;cctype&gt;

bool isPalindrome(const std::string&amp; str) &#123;
    std::string filtered;

    // Remove non-alphanumeric characters and convert to lowercase
    for (char ch : str) &#123;
        if (std::isalnum(static_cast&lt;unsigned char&gt;(ch))) &#123;
            filtered += std::tolower(static_cast&lt;unsigned char&gt;(ch));
        &#125;
    &#125;

    std::string reversed = filtered;
    std::reverse(reversed.begin(), reversed.end());

    return filtered == reversed;
&#125;

int main() &#123;
    std::string text = &quot;A man, a plan, a canal, Panama&quot;;
    if (isPalindrome(text)) &#123;
        std::cout &lt;&lt; &quot;\&quot;&quot; &lt;&lt; text &lt;&lt; &quot;\&quot; is a palindrome.&quot; &lt;&lt; std::endl;
    &#125; else &#123;
        std::cout &lt;&lt; &quot;\&quot;&quot; &lt;&lt; text &lt;&lt; &quot;\&quot; is not a palindrome.&quot; &lt;&lt; std::endl;
    &#125;

    return 0;
&#125;
</code></pre>
</li>
</ol>
<h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><p>In this chapter, you’ve learned about:</p>
<ul>
<li><strong>Arrays:</strong><ul>
<li><strong>C-Style Arrays:</strong> How to declare, initialize, and use single and multidimensional arrays.</li>
<li><strong>Limitations of C-Style Arrays:</strong> Fixed size, lack of bounds checking, and limited functionality.</li>
</ul>
</li>
<li><strong><code>std::array</code>:</strong> A safer and more functional alternative to C-style arrays for fixed-size collections.</li>
<li><strong>C-Style Strings:</strong> Working with character arrays and common string functions.</li>
<li><strong><code>std::string</code>:</strong> Utilizing the string class for safer and more efficient string manipulation.</li>
<li><strong>String and Array Operations:</strong> Common techniques for processing and manipulating arrays and strings.</li>
</ul>
<p>Understanding arrays and strings is essential for handling collections of data and text processing in your programs. They are foundational concepts that will recur throughout your programming journey.</p>
<hr>
<p>In the next chapter, we’ll delve into <strong>Pointers and References</strong>, exploring more advanced ways to manage memory and data in C++.</p>
<p>Next chapter: <a href="/2024/09/26/cpp-unleash/02h-ptrref">Pointers and References</a></p>

            
        </div>
    </div>
    <div class="post-tags">
        
        <span class="icon">
            <i class="fa-solid fa-tags fa-fw"></i>
        </span>
        
        
        
        <span class="tag">
            
            <a href="/tags/c-cpp/" style="color: #ff7d73">c-cpp</a>
        </span>
        
        <span class="tag">
            
            <a href="/tags/modern-cpp/" style="color: #ffa2c4">modern-cpp</a>
        </span>
        
        <span class="tag">
            
            <a href="/tags/cpp-unleash/" style="color: #00bcd4">cpp-unleash</a>
        </span>
        
        <span class="tag">
            
            <a href="/tags/02Hero/" style="color: #03a9f4">02Hero</a>
        </span>
        
    </div>
    <a href="/2024/09/26/cpp-unleash/02h-arystr/" class="go-post">阅读全文</a>
</div>

<div class="post">
    <a href="/2024/09/26/cpp-unleash/02h-func/">
        <h2 class="post-title">C++ Unleashed: Functions</h2>
    </a>
    <div class="category-and-date">
        
        <span class="category">
            <a href="/categories/tutor/">
                <span class="icon">
                    <i class="fa-solid fa-bookmark fa-fw"></i>
                </span>
                tutor
            </a>
        </span>
        
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2024/9/26
        </span>
        
        
    </div>
    <div class="description">
        <div class="content" v-pre>
            
            <p><em><strong>C++ Unleashed: From Zero to Hero</strong></em></p>
<p>Previous chapter: <a href="/2024/09/26/cpp-unleash/02h-ctrlstruct">Control Structures</a></p>
<p><a href="/2024/09/26/cpp-unleash/02h-menu">Go to Table of Contents</a></p>
<h1 id="Functions"><a href="#Functions" class="headerlink" title="Functions"></a>Functions</h1><p>Functions are fundamental building blocks in C++ programming that allow you to organize your code into reusable pieces. They help break down complex problems into smaller, manageable tasks, improve code readability, and facilitate code reuse.</p>
<p>In this chapter, we’ll cover:</p>
<ul>
<li>Function Definition and Calls</li>
<li>Parameter Passing</li>
<li>Return Values</li>
<li>Default Arguments</li>
<li>Function Overloading</li>
<li>Recursive Functions</li>
<li>Lambda Expressions</li>
</ul>
<h2 id="Function-Definition-and-Calls"><a href="#Function-Definition-and-Calls" class="headerlink" title="Function Definition and Calls"></a>Function Definition and Calls</h2><p>A function is a block of code that performs a specific task. In C++, you define a function once and can call it multiple times throughout your program.</p>
<h3 id="Function-Syntax"><a href="#Function-Syntax" class="headerlink" title="Function Syntax"></a>Function Syntax</h3><p>The basic syntax for defining a function:</p>
<pre><code class="cpp">return_type function_name(parameter_list) &#123;
    // Function body
&#125;
</code></pre>
<ul>
<li><strong>return_type</strong>: The data type of the value the function returns. Use <code>void</code> if it doesn’t return a value.</li>
<li><strong>function_name</strong>: The name you give to the function.</li>
<li><strong>parameter_list</strong>: A comma-separated list of parameters (can be empty).</li>
</ul>
<h3 id="Example-Simple-Function"><a href="#Example-Simple-Function" class="headerlink" title="Example: Simple Function"></a>Example: Simple Function</h3><p><strong>Definition:</strong></p>
<pre><code class="cpp">// Function that prints a greeting message
void greet() &#123;
    std::cout &lt;&lt; &quot;Hello from the function!&quot; &lt;&lt; std::endl;
&#125;
</code></pre>
<p><strong>Calling the Function:</strong></p>
<pre><code class="cpp">int main() &#123;
    greet(); // Function call
    return 0;
&#125;
</code></pre>
<h3 id="Function-Declaration-vs-Definition"><a href="#Function-Declaration-vs-Definition" class="headerlink" title="Function Declaration vs. Definition"></a>Function Declaration vs. Definition</h3><ul>
<li><strong>Declaration (Prototype):</strong> Tells the compiler about a function’s name, return type, and parameters.</li>
<li><strong>Definition:</strong> Provides the actual body of the function.</li>
</ul>
<p><strong>Example:</strong></p>
<pre><code class="cpp">// Function declaration (prototype)
int add(int a, int b);

// Function definition
int add(int a, int b) &#123;
    return a + b;
&#125;
</code></pre>
<h3 id="Why-Separate-Declaration-and-Definition"><a href="#Why-Separate-Declaration-and-Definition" class="headerlink" title="Why Separate Declaration and Definition?"></a>Why Separate Declaration and Definition?</h3><ul>
<li><strong>Organization:</strong> Declarations are often placed in header files (<code>.h</code>), and definitions in source files (<code>.cpp</code>).</li>
<li><strong>Multiple Files:</strong> Allows functions to be used across multiple files.</li>
</ul>
<h2 id="Parameter-Passing"><a href="#Parameter-Passing" class="headerlink" title="Parameter Passing"></a>Parameter Passing</h2><p>Parameters allow functions to accept inputs, making them more flexible and reusable.</p>
<h3 id="Pass-by-Value"><a href="#Pass-by-Value" class="headerlink" title="Pass by Value"></a>Pass by Value</h3><p>By default, arguments are passed by value, meaning a copy is made.</p>
<p><strong>Example:</strong></p>
<pre><code class="cpp">void increment(int num) &#123;
    num += 1; // This change won&#39;t affect the original variable
&#125;

int main() &#123;
    int number = 5;
    increment(number);
    std::cout &lt;&lt; &quot;Number: &quot; &lt;&lt; number &lt;&lt; std::endl; // Outputs 5
    return 0;
&#125;
</code></pre>
<h3 id="Pass-by-Reference"><a href="#Pass-by-Reference" class="headerlink" title="Pass by Reference"></a>Pass by Reference</h3><p>Passing by reference allows the function to modify the original variable.</p>
<p><strong>Syntax:</strong></p>
<pre><code class="cpp">void function_name(data_type&amp; parameter_name) &#123;
    // Function body
&#125;
</code></pre>
<p><strong>Example:</strong></p>
<pre><code class="cpp">void increment(int&amp; num) &#123;
    num += 1; // This change will affect the original variable
&#125;

int main() &#123;
    int number = 5;
    increment(number);
    std::cout &lt;&lt; &quot;Number: &quot; &lt;&lt; number &lt;&lt; std::endl; // Outputs 6
    return 0;
&#125;
</code></pre>
<h3 id="Pass-by-Pointer"><a href="#Pass-by-Pointer" class="headerlink" title="Pass by Pointer"></a>Pass by Pointer</h3><p>You can also pass arguments by pointer.</p>
<p><strong>Example:</strong></p>
<pre><code class="cpp">void increment(int* num) &#123;
    (*num) += 1;
&#125;

int main() &#123;
    int number = 5;
    increment(&amp;number);
    std::cout &lt;&lt; &quot;Number: &quot; &lt;&lt; number &lt;&lt; std::endl; // Outputs 6
    return 0;
&#125;
</code></pre>
<h3 id="Choosing-Parameter-Passing-Method"><a href="#Choosing-Parameter-Passing-Method" class="headerlink" title="Choosing Parameter Passing Method"></a>Choosing Parameter Passing Method</h3><ul>
<li><strong>Pass by Value:</strong> Use when you don’t need to modify the original data.</li>
<li><strong>Pass by Reference:</strong> Use when you need to modify the original data or for efficiency with large objects.</li>
<li><strong>Pass by Pointer:</strong> Similar to pass by reference but can accept <code>nullptr</code> and can be reassigned within the function.</li>
</ul>
<h2 id="Return-Values"><a href="#Return-Values" class="headerlink" title="Return Values"></a>Return Values</h2><p>Functions can return values to the caller.</p>
<h3 id="Returning-a-Single-Value"><a href="#Returning-a-Single-Value" class="headerlink" title="Returning a Single Value"></a>Returning a Single Value</h3><p><strong>Example:</strong></p>
<pre><code class="cpp">int add(int a, int b) &#123;
    return a + b;
&#125;

int main() &#123;
    int sum = add(5, 3);
    std::cout &lt;&lt; &quot;Sum: &quot; &lt;&lt; sum &lt;&lt; std::endl; // Outputs 8
    return 0;
&#125;
</code></pre>
<h3 id="Returning-Multiple-Values"><a href="#Returning-Multiple-Values" class="headerlink" title="Returning Multiple Values"></a>Returning Multiple Values</h3><p>C++ doesn’t support returning multiple values directly, but you can use several techniques:</p>
<h4 id="Using-References-or-Pointers"><a href="#Using-References-or-Pointers" class="headerlink" title="Using References or Pointers"></a>Using References or Pointers</h4><p>Modify multiple output variables passed by reference or pointer.</p>
<p><strong>Example:</strong></p>
<pre><code class="cpp">void getMinMax(int a, int b, int&amp; min, int&amp; max) &#123;
    if (a &lt; b) &#123;
        min = a;
        max = b;
    &#125; else &#123;
        min = b;
        max = a;
    &#125;
&#125;

int main() &#123;
    int min, max;
    getMinMax(10, 20, min, max);
    std::cout &lt;&lt; &quot;Min: &quot; &lt;&lt; min &lt;&lt; &quot;, Max: &quot; &lt;&lt; max &lt;&lt; std::endl; // Outputs: Min: 10, Max: 20
    return 0;
&#125;
</code></pre>
<h4 id="Using-Structures-or-Classes"><a href="#Using-Structures-or-Classes" class="headerlink" title="Using Structures or Classes"></a>Using Structures or Classes</h4><p>Return a struct or class containing multiple values.</p>
<p><strong>Example:</strong></p>
<pre><code class="cpp">struct MinMax &#123;
    int min;
    int max;
&#125;;

MinMax getMinMax(int a, int b) &#123;
    MinMax result;
    if (a &lt; b) &#123;
        result.min = a;
        result.max = b;
    &#125; else &#123;
        result.min = b;
        result.max = a;
    &#125;
    return result;
&#125;

int main() &#123;
    MinMax result = getMinMax(10, 20);
    std::cout &lt;&lt; &quot;Min: &quot; &lt;&lt; result.min &lt;&lt; &quot;, Max: &quot; &lt;&lt; result.max &lt;&lt; std::endl; // Outputs: Min: 10, Max: 20
    return 0;
&#125;
</code></pre>
<h4 id="Using-std-pair-or-std-tuple"><a href="#Using-std-pair-or-std-tuple" class="headerlink" title="Using std::pair or std::tuple"></a>Using <code>std::pair</code> or <code>std::tuple</code></h4><p>Standard library classes <code>std::pair</code> and <code>std::tuple</code> can be used to return multiple values.</p>
<p><strong>Using <code>std::pair</code>:</strong></p>
<pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;utility&gt; // For std::pair

std::pair&lt;int, int&gt; getMinMax(int a, int b) &#123;
    if (a &lt; b)
        return std::make_pair(a, b);
    else
        return std::make_pair(b, a);
&#125;

int main() &#123;
    std::pair&lt;int, int&gt; result = getMinMax(10, 20);
    std::cout &lt;&lt; &quot;Min: &quot; &lt;&lt; result.first &lt;&lt; &quot;, Max: &quot; &lt;&lt; result.second &lt;&lt; std::endl; // Outputs: Min: 10, Max: 20
    return 0;
&#125;
</code></pre>
<p>Alternatively, with C++17 structured bindings:</p>
<pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;utility&gt; // For std::pair

std::pair&lt;int, int&gt; getMinMax(int a, int b) &#123;
    if (a &lt; b)
        return &#123;a, b&#125;;
    else
        return &#123;b, a&#125;;
&#125;

int main() &#123;
    auto [min, max] = getMinMax(10, 20); // Structured binding (C++17)
    std::cout &lt;&lt; &quot;Min: &quot; &lt;&lt; min &lt;&lt; &quot;, Max: &quot; &lt;&lt; max &lt;&lt; std::endl; // Outputs: Min: 10, Max: 20
    return 0;
&#125;
</code></pre>
<p><strong>Using <code>std::tuple</code>:</strong></p>
<pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;tuple&gt; // For std::tuple

std::tuple&lt;int, int, int&gt; getStats(int a, int b, int c) &#123;
    int min = std::min(&#123;a, b, c&#125;);
    int max = std::max(&#123;a, b, c&#125;);
    int sum = a + b + c;
    return std::make_tuple(min, max, sum);
&#125;

int main() &#123;
    auto [min, max, sum] = getStats(5, 10, 15); // Structured binding (C++17)
    std::cout &lt;&lt; &quot;Min: &quot; &lt;&lt; min &lt;&lt; &quot;, Max: &quot; &lt;&lt; max &lt;&lt; &quot;, Sum: &quot; &lt;&lt; sum &lt;&lt; std::endl; // Outputs: Min: 5, Max: 15, Sum: 30
    return 0;
&#125;
</code></pre>
<p><strong>Note:</strong> Structured bindings require C++17 or newer. If you are using an older standard, you can access tuple elements using <code>std::get</code>.</p>
<p>Example without structured bindings:</p>
<pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;tuple&gt; // For std::tuple

std::tuple&lt;int, int, int&gt; getStats(int a, int b, int c) &#123;
    int min = std::min(&#123;a, b, c&#125;);
    int max = std::max(&#123;a, b, c&#125;);
    int sum = a + b + c;
    return std::make_tuple(min, max, sum);
&#125;

int main() &#123;
    std::tuple&lt;int, int, int&gt; result = getStats(5, 10, 15);
    int min = std::get&lt;0&gt;(result);
    int max = std::get&lt;1&gt;(result);
    int sum = std::get&lt;2&gt;(result);
    std::cout &lt;&lt; &quot;Min: &quot; &lt;&lt; min &lt;&lt; &quot;, Max: &quot; &lt;&lt; max &lt;&lt; &quot;, Sum: &quot; &lt;&lt; sum &lt;&lt; std::endl; // Outputs: Min: 5, Max: 15, Sum: 30
    return 0;
&#125;
</code></pre>
<h2 id="Default-Arguments"><a href="#Default-Arguments" class="headerlink" title="Default Arguments"></a>Default Arguments</h2><p>Functions can have default parameter values, which are used if no argument is provided for that parameter.</p>
<p><strong>Example:</strong></p>
<pre><code class="cpp">void display(int a = 0, int b = 0) &#123;
    std::cout &lt;&lt; &quot;a: &quot; &lt;&lt; a &lt;&lt; &quot;, b: &quot; &lt;&lt; b &lt;&lt; std::endl;
&#125;

int main() &#123;
    display();          // Outputs: a: 0, b: 0
    display(5);         // Outputs: a: 5, b: 0
    display(5, 10);     // Outputs: a: 5, b: 10
    return 0;
&#125;
</code></pre>
<p><strong>Rules:</strong></p>
<ul>
<li>Default values must be specified in the function declaration (prototype), not in the definition if they are separate.</li>
<li>Once a parameter is given a default value, all subsequent parameters must also have default values.</li>
</ul>
<h2 id="Function-Overloading"><a href="#Function-Overloading" class="headerlink" title="Function Overloading"></a>Function Overloading</h2><p>C++ allows multiple functions with the same name but different parameter lists (number or types of parameters). This is called function overloading.</p>
<p><strong>Example:</strong></p>
<pre><code class="cpp">void print(int i) &#123;
    std::cout &lt;&lt; &quot;Integer: &quot; &lt;&lt; i &lt;&lt; std::endl;
&#125;

void print(double f) &#123;
    std::cout &lt;&lt; &quot;Double: &quot; &lt;&lt; f &lt;&lt; std::endl;
&#125;

void print(const std::string&amp; s) &#123;
    std::cout &lt;&lt; &quot;String: &quot; &lt;&lt; s &lt;&lt; std::endl;
&#125;

int main() &#123;
    print(10);            // Calls print(int)
    print(3.14);          // Calls print(double)
    print(&quot;Hello&quot;);       // Calls print(const std::string&amp;)
    return 0;
&#125;
</code></pre>
<h2 id="Recursive-Functions"><a href="#Recursive-Functions" class="headerlink" title="Recursive Functions"></a>Recursive Functions</h2><p>A function that calls itself is known as a recursive function. Recursion is a powerful tool but should be used with care to avoid infinite loops or stack overflows.</p>
<p><strong>Example: Factorial Calculation</strong></p>
<pre><code class="cpp">int factorial(int n) &#123;
    if (n &lt;= 1)
        return 1; // Base case
    else
        return n * factorial(n - 1); // Recursive call
&#125;

int main() &#123;
    int num = 5;
    std::cout &lt;&lt; &quot;Factorial of &quot; &lt;&lt; num &lt;&lt; &quot; is &quot; &lt;&lt; factorial(num) &lt;&lt; std::endl; // Outputs: Factorial of 5 is 120
    return 0;
&#125;
</code></pre>
<p><strong>Note:</strong> Always ensure that there is a base case to terminate recursion.</p>
<h2 id="Lambda-Expressions"><a href="#Lambda-Expressions" class="headerlink" title="Lambda Expressions"></a>Lambda Expressions</h2><p>Lambda expressions (also known as closures) are anonymous functions that you can define in-place. They are useful for short snippets of code, especially when working with algorithms.</p>
<h3 id="Syntax"><a href="#Syntax" class="headerlink" title="Syntax"></a>Syntax</h3><pre><code class="cpp">[capture_list](parameter_list) -&gt; return_type &#123;
    // Function body
&#125;;
</code></pre>
<ul>
<li><strong>capture_list</strong>: Specifies which variables are captured from the surrounding scope.</li>
<li><strong>parameter_list</strong>: Parameters passed to the lambda.</li>
<li><strong>return_type</strong>: (Optional) The return type of the lambda (often deduced automatically).</li>
</ul>
<h3 id="Examples"><a href="#Examples" class="headerlink" title="Examples"></a>Examples</h3><h4 id="Basic-Lambda"><a href="#Basic-Lambda" class="headerlink" title="Basic Lambda"></a>Basic Lambda</h4><pre><code class="cpp">auto greet = []() &#123;
    std::cout &lt;&lt; &quot;Hello from lambda!&quot; &lt;&lt; std::endl;
&#125;;

int main() &#123;
    greet(); // Outputs: Hello from lambda!
    return 0;
&#125;
</code></pre>
<h4 id="Lambda-with-Parameters"><a href="#Lambda-with-Parameters" class="headerlink" title="Lambda with Parameters"></a>Lambda with Parameters</h4><pre><code class="cpp">auto add = [](int a, int b) &#123;
    return a + b;
&#125;;

int main() &#123;
    int sum = add(5, 3);
    std::cout &lt;&lt; &quot;Sum: &quot; &lt;&lt; sum &lt;&lt; std::endl; // Outputs: Sum: 8
    return 0;
&#125;
</code></pre>
<h4 id="Capturing-Variables"><a href="#Capturing-Variables" class="headerlink" title="Capturing Variables"></a>Capturing Variables</h4><pre><code class="cpp">int main() &#123;
    int factor = 2;
    auto multiply = [factor](int x) &#123;
        return x * factor;
    &#125;;

    int result = multiply(5);
    std::cout &lt;&lt; &quot;Result: &quot; &lt;&lt; result &lt;&lt; std::endl; // Outputs: Result: 10
    return 0;
&#125;
</code></pre>
<ul>
<li><strong>Capture by Value (<code>[factor]</code>)</strong>: Captures a copy of <code>factor</code>.</li>
<li><strong>Capture by Reference (<code>[&amp;factor]</code>)</strong>: Captures <code>factor</code> by reference, allowing modification.</li>
<li><strong>Capture All by Value (<code>[=]</code>)</strong>: Captures all automatic variables (local variables) by value.</li>
<li><strong>Capture All by Reference (<code>[&amp;]</code>)</strong>: Captures all automatic variables by reference.</li>
</ul>
<h4 id="Modifying-Captured-Variables"><a href="#Modifying-Captured-Variables" class="headerlink" title="Modifying Captured Variables"></a>Modifying Captured Variables</h4><p>To modify a captured variable in a lambda, you must capture it by reference.</p>
<pre><code class="cpp">int main() &#123;
    int count = 0;
    auto increment = [&amp;count]() &#123;
        count++;
    &#125;;

    increment();
    increment();
    std::cout &lt;&lt; &quot;Count: &quot; &lt;&lt; count &lt;&lt; std::endl; // Outputs: Count: 2
    return 0;
&#125;
</code></pre>
<h3 id="Lambdas-in-Algorithms"><a href="#Lambdas-in-Algorithms" class="headerlink" title="Lambdas in Algorithms"></a>Lambdas in Algorithms</h3><p>Lambdas are often used with Standard Template Library (STL) algorithms.</p>
<pre><code class="cpp">#include &lt;algorithm&gt;
#include &lt;vector&gt;
#include &lt;iostream&gt;

int main() &#123;
    std::vector&lt;int&gt; numbers = &#123;5, 2, 8, 1, 3&#125;;

    // Sort in ascending order using a lambda
    std::sort(numbers.begin(), numbers.end(), [](int a, int b) &#123;
        return a &lt; b;
    &#125;);

    for (int num : numbers) &#123;
        std::cout &lt;&lt; num &lt;&lt; &quot; &quot;; // Outputs: 1 2 3 5 8
    &#125;

    std::cout &lt;&lt; std::endl;
    return 0;
&#125;
</code></pre>
<h2 id="Inline-Functions"><a href="#Inline-Functions" class="headerlink" title="Inline Functions"></a>Inline Functions</h2><p>The <code>inline</code> keyword suggests to the compiler to insert the function’s body where the function call is, potentially reducing the overhead of a function call.</p>
<p><strong>Syntax:</strong></p>
<pre><code class="cpp">inline int add(int a, int b) &#123;
    return a + b;
&#125;
</code></pre>
<p><strong>Note:</strong> Modern compilers optimize function calls efficiently, so the <code>inline</code> keyword is often unnecessary. It is generally used for very small, frequently called functions.</p>
<h2 id="Practical-Example-Calculator-with-Functions"><a href="#Practical-Example-Calculator-with-Functions" class="headerlink" title="Practical Example: Calculator with Functions"></a>Practical Example: Calculator with Functions</h2><p>Let’s refactor the calculator example from the previous chapter using functions.</p>
<pre><code class="cpp">#include &lt;iostream&gt;

double add(double a, double b) &#123;
    return a + b;
&#125;

double subtract(double a, double b) &#123;
    return a - b;
&#125;

double multiply(double a, double b) &#123;
    return a * b;
&#125;

double divide(double a, double b) &#123;
    if (b != 0.0)
        return a / b;
    else &#123;
        std::cerr &lt;&lt; &quot;Error: Division by zero.&quot; &lt;&lt; std::endl;
        return 0.0;
    &#125;
&#125;

int main() &#123;
    double num1, num2;
    char operation;
    bool valid = true;

    std::cout &lt;&lt; &quot;Enter first number: &quot;;
    std::cin &gt;&gt; num1;

    std::cout &lt;&lt; &quot;Enter an operator (+, -, *, /): &quot;;
    std::cin &gt;&gt; operation;

    std::cout &lt;&lt; &quot;Enter second number: &quot;;
    std::cin &gt;&gt; num2;

    double result;

    switch (operation) &#123;
        case &#39;+&#39;:
            result = add(num1, num2);
            break;
        case &#39;-&#39;:
            result = subtract(num1, num2);
            break;
        case &#39;*&#39;:
            result = multiply(num1, num2);
            break;
        case &#39;/&#39;:
            result = divide(num1, num2);
            break;
        default:
            std::cerr &lt;&lt; &quot;Invalid operator.&quot; &lt;&lt; std::endl;
            valid = false;
    &#125;

    if (valid) &#123;
        std::cout &lt;&lt; &quot;Result: &quot; &lt;&lt; result &lt;&lt; std::endl;
    &#125;

    return 0;
&#125;
</code></pre>
<h2 id="Exercises"><a href="#Exercises" class="headerlink" title="Exercises"></a>Exercises</h2><ol>
<li><p><strong>Temperature Conversion</strong></p>
<p>Write functions that convert temperatures between Celsius and Fahrenheit.</p>
<pre><code class="cpp">double toFahrenheit(double celsius);
double toCelsius(double fahrenheit);
</code></pre>
<p><strong>Example Implementation:</strong></p>
<pre><code class="cpp">double toFahrenheit(double celsius) &#123;
    return (celsius * 9.0 / 5.0) + 32.0;
&#125;

double toCelsius(double fahrenheit) &#123;
    return (fahrenheit - 32.0) * 5.0 / 9.0;
&#125;
</code></pre>
</li>
<li><p><strong>Find Maximum</strong></p>
<p>Create a function template <code>maxValue</code> that returns the maximum of two values.</p>
<pre><code class="cpp">template &lt;typename T&gt;
T maxValue(T a, T b) &#123;
    return (a &gt; b) ? a : b;
&#125;
</code></pre>
<p><strong>Example Usage:</strong></p>
<pre><code class="cpp">int main() &#123;
    std::cout &lt;&lt; &quot;Max of 10 and 20 is &quot; &lt;&lt; maxValue(10, 20) &lt;&lt; std::endl; // Outputs: Max of 10 and 20 is 20
    std::cout &lt;&lt; &quot;Max of 3.14 and 2.72 is &quot; &lt;&lt; maxValue(3.14, 2.72) &lt;&lt; std::endl; // Outputs: Max of 3.14 and 2.72 is 3.14
    return 0;
&#125;
</code></pre>
</li>
<li><p><strong>Palindrome Check</strong></p>
<p>Write a function that checks if a given <code>std::string</code> is a palindrome.</p>
<pre><code class="cpp">#include &lt;string&gt;
#include &lt;algorithm&gt;

bool isPalindrome(const std::string&amp; str) &#123;
    std::string reversed = str;
    std::reverse(reversed.begin(), reversed.end());
    return str == reversed;
&#125;

int main() &#123;
    std::string word = &quot;radar&quot;;
    if (isPalindrome(word)) &#123;
        std::cout &lt;&lt; word &lt;&lt; &quot; is a palindrome.&quot; &lt;&lt; std::endl;
    &#125; else &#123;
        std::cout &lt;&lt; word &lt;&lt; &quot; is not a palindrome.&quot; &lt;&lt; std::endl;
    &#125;
    return 0;
&#125;
</code></pre>
</li>
</ol>
<h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><p>In this chapter, you’ve learned about:</p>
<ul>
<li><strong>Function Definition and Calls:</strong> How to define and invoke functions.</li>
<li><strong>Parameter Passing:</strong> The difference between passing by value, reference, and pointer.</li>
<li><strong>Return Values:</strong> Techniques to return single and multiple values from functions.</li>
<li><strong>Default Arguments:</strong> How to use default parameter values.</li>
<li><strong>Function Overloading:</strong> Using the same function name with different parameter lists.</li>
<li><strong>Recursive Functions:</strong> Functions that call themselves.</li>
<li><strong>Lambda Expressions:</strong> Creating and using anonymous functions for concise code.</li>
</ul>
<p>Functions are essential for writing modular, maintainable, and reusable code. Understanding how to effectively use functions will greatly enhance your ability to develop complex applications.</p>
<hr>
<p>Next, we’ll explore <strong>Arrays and Strings</strong>, diving into how to manage collections of data in C++.</p>
<p>Next chapter: <a href="/2024/09/26/cpp-unleash/02h-arystr">Arrays and Strings</a></p>

            
        </div>
    </div>
    <div class="post-tags">
        
        <span class="icon">
            <i class="fa-solid fa-tags fa-fw"></i>
        </span>
        
        
        
        <span class="tag">
            
            <a href="/tags/c-cpp/" style="color: #03a9f4">c-cpp</a>
        </span>
        
        <span class="tag">
            
            <a href="/tags/modern-cpp/" style="color: #00bcd4">modern-cpp</a>
        </span>
        
        <span class="tag">
            
            <a href="/tags/cpp-unleash/" style="color: #ffa2c4">cpp-unleash</a>
        </span>
        
        <span class="tag">
            
            <a href="/tags/02Hero/" style="color: #00a596">02Hero</a>
        </span>
        
    </div>
    <a href="/2024/09/26/cpp-unleash/02h-func/" class="go-post">阅读全文</a>
</div>

<div class="post">
    <a href="/2024/09/26/cpp-unleash/02h-ctrlstruct/">
        <h2 class="post-title">C++ Unleashed: Control Structures</h2>
    </a>
    <div class="category-and-date">
        
        <span class="category">
            <a href="/categories/tutor/">
                <span class="icon">
                    <i class="fa-solid fa-bookmark fa-fw"></i>
                </span>
                tutor
            </a>
        </span>
        
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2024/9/26
        </span>
        
        
    </div>
    <div class="description">
        <div class="content" v-pre>
            
            <p><em><strong>C++ Unleashed: From Zero to Hero</strong></em></p>
<p>Previous chapter: <a href="/2024/09/26/cpp-unleash/02h-getstart">Getting Start</a></p>
<p><a href="/2024/09/26/cpp-unleash/02h-menu">Go to Table of Contents</a></p>
<h1 id="Control-Structures"><a href="#Control-Structures" class="headerlink" title="Control Structures"></a>Control Structures</h1><p>Control structures are fundamental to programming as they dictate the flow of execution within your programs. In C++, control structures allow you to make decisions, repeat actions, and alter the flow based on certain conditions. This chapter covers conditional statements, loops, and jump statements, including the use of <code>goto</code>.</p>
<h2 id="Conditional-Statements"><a href="#Conditional-Statements" class="headerlink" title="Conditional Statements"></a>Conditional Statements</h2><p>Conditional statements allow your program to execute different sections of code based on whether a condition is true or false. The primary conditional statements in C++ are <code>if</code> and <code>switch</code>.</p>
<h3 id="if-Statement"><a href="#if-Statement" class="headerlink" title="if Statement"></a><code>if</code> Statement</h3><p>The <code>if</code> statement executes a block of code if a specified condition is true. You can also include <code>else if</code> and <code>else</code> clauses to handle additional conditions.</p>
<p><strong>Syntax:</strong></p>
<pre><code class="cpp">if (condition) &#123;
    // Code to execute if condition is true
&#125; else if (another_condition) &#123;
    // Code to execute if another_condition is true
&#125; else &#123;
    // Code to execute if none of the above conditions are true
&#125;
</code></pre>
<p><strong>Example:</strong></p>
<pre><code class="cpp">#include &lt;iostream&gt;

int main() &#123;
    int number;
    std::cout &lt;&lt; &quot;Enter a number: &quot;;
    std::cin &gt;&gt; number;

    if (number &gt; 0) &#123;
        std::cout &lt;&lt; &quot;Positive number.&quot; &lt;&lt; std::endl;
    &#125; else if (number &lt; 0) &#123;
        std::cout &lt;&lt; &quot;Negative number.&quot; &lt;&lt; std::endl;
    &#125; else &#123;
        std::cout &lt;&lt; &quot;Zero.&quot; &lt;&lt; std::endl;
    &#125;

    return 0;
&#125;
</code></pre>
<h3 id="switch-Statement"><a href="#switch-Statement" class="headerlink" title="switch Statement"></a><code>switch</code> Statement</h3><p>The <code>switch</code> statement allows multi-way branching based on the value of an integral or enumeration type.</p>
<p><strong>Syntax:</strong></p>
<pre><code class="cpp">switch (expression) &#123;
    case value1:
        // Code to execute if expression == value1
        break;
    case value2:
        // Code to execute if expression == value2
        break;
    // More cases...
    default:
        // Code to execute if none of the cases match
&#125;
</code></pre>
<p><strong>Example:</strong></p>
<pre><code class="cpp">#include &lt;iostream&gt;

int main() &#123;
    char grade;
    std::cout &lt;&lt; &quot;Enter your grade (A, B, C, D, F): &quot;;
    std::cin &gt;&gt; grade;

    switch (grade) &#123;
        case &#39;A&#39;:
            std::cout &lt;&lt; &quot;Excellent!&quot; &lt;&lt; std::endl;
            break;
        case &#39;B&#39;:
            std::cout &lt;&lt; &quot;Good job!&quot; &lt;&lt; std::endl;
            break;
        case &#39;C&#39;:
            std::cout &lt;&lt; &quot;Fair.&quot; &lt;&lt; std::endl;
            break;
        case &#39;D&#39;:
            std::cout &lt;&lt; &quot;Needs improvement.&quot; &lt;&lt; std::endl;
            break;
        case &#39;F&#39;:
            std::cout &lt;&lt; &quot;Fail.&quot; &lt;&lt; std::endl;
            break;
        default:
            std::cout &lt;&lt; &quot;Invalid grade.&quot; &lt;&lt; std::endl;
    &#125;

    return 0;
&#125;
</code></pre>
<h2 id="Loops"><a href="#Loops" class="headerlink" title="Loops"></a>Loops</h2><p>Loops allow you to execute a block of code multiple times. C++ provides several types of loops: <code>for</code>, <code>while</code>, and <code>do-while</code>.</p>
<h3 id="for-Loop"><a href="#for-Loop" class="headerlink" title="for Loop"></a><code>for</code> Loop</h3><p>The <code>for</code> loop is typically used when the number of iterations is known beforehand.</p>
<p><strong>Syntax:</strong></p>
<pre><code class="cpp">for (initialization; condition; increment) &#123;
    // Code to execute each iteration
&#125;
</code></pre>
<p><strong>Example:</strong></p>
<pre><code class="cpp">#include &lt;iostream&gt;

int main() &#123;
    for (int i = 1; i &lt;= 5; ++i) &#123;
        std::cout &lt;&lt; &quot;Iteration &quot; &lt;&lt; i &lt;&lt; std::endl;
    &#125;

    return 0;
&#125;
</code></pre>
<h3 id="while-Loop"><a href="#while-Loop" class="headerlink" title="while Loop"></a><code>while</code> Loop</h3><p>The <code>while</code> loop continues to execute as long as the specified condition remains true. It’s useful when the number of iterations is not known in advance.</p>
<p><strong>Syntax:</strong></p>
<pre><code class="cpp">while (condition) &#123;
    // Code to execute each iteration
&#125;
</code></pre>
<p><strong>Example:</strong></p>
<pre><code class="cpp">#include &lt;iostream&gt;

int main() &#123;
    int count = 1;
    while (count &lt;= 5) &#123;
        std::cout &lt;&lt; &quot;Count: &quot; &lt;&lt; count &lt;&lt; std::endl;
        ++count;
    &#125;

    return 0;
&#125;
</code></pre>
<h3 id="do-while-Loop"><a href="#do-while-Loop" class="headerlink" title="do-while Loop"></a><code>do-while</code> Loop</h3><p>The <code>do-while</code> loop is similar to the <code>while</code> loop, but it guarantees that the loop body is executed at least once, as the condition is checked after the execution of the loop body.</p>
<p><strong>Syntax:</strong></p>
<pre><code class="cpp">do &#123;
    // Code to execute each iteration
&#125; while (condition);
</code></pre>
<p><strong>Example:</strong></p>
<pre><code class="cpp">#include &lt;iostream&gt;

int main() &#123;
    int number;
    do &#123;
        std::cout &lt;&lt; &quot;Enter a positive number (0 to exit): &quot;;
        std::cin &gt;&gt; number;
        std::cout &lt;&lt; &quot;You entered: &quot; &lt;&lt; number &lt;&lt; std::endl;
    &#125; while (number != 0);

    return 0;
&#125;
</code></pre>
<h2 id="Jump-Statements"><a href="#Jump-Statements" class="headerlink" title="Jump Statements"></a>Jump Statements</h2><p>Jump statements allow you to alter the flow of control by jumping to a different part of the program. The primary jump statements in C++ are <code>break</code>, <code>continue</code>, <code>return</code>, and <code>goto</code>.</p>
<h3 id="break"><a href="#break" class="headerlink" title="break"></a><code>break</code></h3><p>The <code>break</code> statement exits the nearest enclosing loop or <code>switch</code> statement.</p>
<p><strong>Example: Exiting a Loop Early</strong></p>
<pre><code class="cpp">#include &lt;iostream&gt;

int main() &#123;
    for (int i = 1; i &lt;= 10; ++i) &#123;
        if (i == 5) &#123;
            break; // Exit the loop when i is 5
        &#125;
        std::cout &lt;&lt; i &lt;&lt; &quot; &quot;;
    &#125;
    // Output: 1 2 3 4
    return 0;
&#125;
</code></pre>
<h3 id="continue"><a href="#continue" class="headerlink" title="continue"></a><code>continue</code></h3><p>The <code>continue</code> statement skips the rest of the current loop iteration and proceeds to the next iteration.</p>
<p><strong>Example: Skipping Odd Numbers</strong></p>
<pre><code class="cpp">#include &lt;iostream&gt;

int main() &#123;
    for (int i = 1; i &lt;= 5; ++i) &#123;
        if (i % 2 != 0) &#123;
            continue; // Skip odd numbers
        &#125;
        std::cout &lt;&lt; i &lt;&lt; &quot; &quot;;
    &#125;
    // Output: 2 4
    return 0;
&#125;
</code></pre>
<h3 id="return"><a href="#return" class="headerlink" title="return"></a><code>return</code></h3><p>The <code>return</code> statement exits a function and optionally returns a value to the caller.</p>
<p><strong>Example: Exiting a Function Early</strong></p>
<pre><code class="cpp">#include &lt;iostream&gt;

int divide(int a, int b) &#123;
    if (b == 0) &#123;
        std::cerr &lt;&lt; &quot;Error: Division by zero!&quot; &lt;&lt; std::endl;
        return 0; // Exit the function early
    &#125;
    return a / b;
&#125;

int main() &#123;
    int result = divide(10, 2);
    std::cout &lt;&lt; &quot;Result: &quot; &lt;&lt; result &lt;&lt; std::endl; // Output: Result: 5

    result = divide(10, 0); // Triggers error message and returns 0
    std::cout &lt;&lt; &quot;Result: &quot; &lt;&lt; result &lt;&lt; std::endl; // Output: Result: 0

    return 0;
&#125;
</code></pre>
<h3 id="goto"><a href="#goto" class="headerlink" title="goto"></a><code>goto</code></h3><p>The <code>goto</code> statement allows you to jump to a labeled statement within the same function. While <code>goto</code> can be used for error handling or breaking out of deeply nested loops, its use is generally discouraged as it can lead to spaghetti code, making programs harder to read and maintain.</p>
<p><strong>Syntax:</strong></p>
<pre><code class="cpp">goto label;

// ...

label:
    // Code to jump to
</code></pre>
<p><strong>Example: Using <code>goto</code> for Error Handling</strong></p>
<pre><code class="cpp">#include &lt;iostream&gt;

int main() &#123;
    int num;
    std::cout &lt;&lt; &quot;Enter a positive number: &quot;;
    std::cin &gt;&gt; num;

    if (num &lt;= 0) &#123;
        std::cerr &lt;&lt; &quot;Invalid input. Number must be positive.&quot; &lt;&lt; std::endl;
        goto end; // Jump to the end label
    &#125;

    std::cout &lt;&lt; &quot;You entered: &quot; &lt;&lt; num &lt;&lt; std::endl;

    end:
        std::cout &lt;&lt; &quot;Program ended.&quot; &lt;&lt; std::endl;
    return 0;
&#125;
</code></pre>
<p><strong>Best Practices:</strong></p>
<ul>
<li><strong>Avoid Using <code>goto</code> When Possible</strong>: Prefer structured control flow constructs (<code>if</code>, <code>for</code>, <code>while</code>, etc.) to maintain code readability.</li>
<li><strong>Use Sparingly and Carefully</strong>: If you must use <code>goto</code>, ensure it’s used in a controlled and understandable manner, such as for error handling in C-style code.</li>
</ul>
<h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><p>In this chapter, you’ve learned about the fundamental control structures in C++ that dictate the flow of your programs:</p>
<ul>
<li><strong>Conditional Statements</strong>: <code>if</code> and <code>switch</code> allow you to execute code based on conditions.</li>
<li><strong>Loops</strong>: <code>for</code>, <code>while</code>, and <code>do-while</code> enable you to repeat actions.</li>
<li><strong>Jump Statements</strong>: <code>break</code>, <code>continue</code>, <code>return</code>, and <code>goto</code> allow you to alter the flow of execution within loops and functions.</li>
</ul>
<p>Understanding and effectively utilizing these control structures is essential for writing dynamic and efficient C++ programs. As you continue, you’ll apply these concepts in more complex scenarios, building robust and responsive applications.</p>
<hr>
<p>Now you’re ready to move on to <strong>Functions</strong>, where you’ll learn how to create reusable blocks of code to perform specific tasks within your programs.</p>
<p>Next chapter: <a href="/2024/09/26/cpp-unleash/02h-func">Functions</a></p>

            
        </div>
    </div>
    <div class="post-tags">
        
        <span class="icon">
            <i class="fa-solid fa-tags fa-fw"></i>
        </span>
        
        
        
        <span class="tag">
            
            <a href="/tags/c-cpp/" style="color: #ffa2c4">c-cpp</a>
        </span>
        
        <span class="tag">
            
            <a href="/tags/modern-cpp/" style="color: #03a9f4">modern-cpp</a>
        </span>
        
        <span class="tag">
            
            <a href="/tags/cpp-unleash/" style="color: #ff7d73">cpp-unleash</a>
        </span>
        
        <span class="tag">
            
            <a href="/tags/02Hero/" style="color: #ffa2c4">02Hero</a>
        </span>
        
    </div>
    <a href="/2024/09/26/cpp-unleash/02h-ctrlstruct/" class="go-post">阅读全文</a>
</div>

<div class="post">
    <a href="/2024/09/26/cpp-unleash/02h-getstart/">
        <h2 class="post-title">C++ Unleashed: Getting Start</h2>
    </a>
    <div class="category-and-date">
        
        <span class="category">
            <a href="/categories/tutor/">
                <span class="icon">
                    <i class="fa-solid fa-bookmark fa-fw"></i>
                </span>
                tutor
            </a>
        </span>
        
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2024/9/26
        </span>
        
        
    </div>
    <div class="description">
        <div class="content" v-pre>
            
            <p><em><strong>C++ Unleashed: From Zero to Hero</strong></em></p>
<p>Previous chapter: <a href="/2024/09/26/cpp-unleash/02h-intro">Introduction</a></p>
<p><a href="/2024/09/26/cpp-unleash/02h-menu">Go to Table of Contents</a></p>
<h1 id="Getting-Started"><a href="#Getting-Started" class="headerlink" title="Getting Started"></a>Getting Started</h1><p>In this chapter, we’ll set up your development environment, create your first C++ program using Visual Studio Code and <code>xmake</code>, explore variables and data types, and learn how to use comments effectively in your code. This foundational knowledge will prepare you for more advanced topics in C++ programming.</p>
<h2 id="Environment-Setup"><a href="#Environment-Setup" class="headerlink" title="Environment Setup"></a>Environment Setup</h2><h3 id="Prerequisites"><a href="#Prerequisites" class="headerlink" title="Prerequisites"></a>Prerequisites</h3><ul>
<li><strong>Visual Studio Code (VSCode)</strong>: A lightweight, cross-platform code editor.</li>
<li><strong>Compiler</strong>:<ul>
<li><strong>Windows</strong>: Microsoft Visual C++ (MSVC)</li>
<li><strong>macOS</strong>: Clang</li>
<li><strong>Linux</strong>: GCC</li>
</ul>
</li>
<li><strong>clangd</strong>: Language server providing smart code completion and error detection.</li>
<li><strong>xmake</strong>: A cross-platform build utility based on Lua.</li>
</ul>
<h3 id="Installation-Steps"><a href="#Installation-Steps" class="headerlink" title="Installation Steps"></a>Installation Steps</h3><h4 id="1-Install-Visual-Studio-Code"><a href="#1-Install-Visual-Studio-Code" class="headerlink" title="1. Install Visual Studio Code"></a>1. Install Visual Studio Code</h4><p>Download and install VSCode from the <a target="_blank" rel="noopener" href="https://code.visualstudio.com/">official website</a>.</p>
<h4 id="2-Install-the-Compiler"><a href="#2-Install-the-Compiler" class="headerlink" title="2. Install the Compiler"></a>2. Install the Compiler</h4><ul>
<li><strong>Windows (MSVC)</strong>:<ul>
<li>Download and install the <a target="_blank" rel="noopener" href="https://visualstudio.microsoft.com/downloads/">Build Tools for Visual Studio</a>. Select the <strong>C++ build tools</strong> workload during installation.</li>
</ul>
</li>
<li><strong>macOS (Clang)</strong>:<ul>
<li>Install Xcode Command Line Tools by running the following command in Terminal:<pre><code class="bash">xcode-select --install
</code></pre>
</li>
</ul>
</li>
<li><strong>Linux (GCC)</strong>:<ul>
<li>Install GCC using your distribution’s package manager. For example, on Debian-based systems:<pre><code class="bash">sudo apt-get update
sudo apt-get install build-essential
</code></pre>
</li>
</ul>
</li>
</ul>
<h4 id="3-Install-clangd"><a href="#3-Install-clangd" class="headerlink" title="3. Install clangd"></a>3. Install clangd</h4><ul>
<li><strong>Windows</strong>:<ul>
<li>Download the LLVM package from the <a target="_blank" rel="noopener" href="https://releases.llvm.org/download.html">official website</a> and follow the installation instructions.</li>
</ul>
</li>
<li><strong>macOS</strong>:<ul>
<li>If you have Homebrew installed, run:<pre><code class="bash">brew install llvm
</code></pre>
</li>
<li>Ensure that <code>clangd</code> is in your PATH.</li>
</ul>
</li>
<li><strong>Linux</strong>:<ul>
<li>Install <code>clangd</code> via your package manager. For example:<pre><code class="bash">sudo apt-get install clangd
</code></pre>
</li>
</ul>
</li>
</ul>
<h4 id="4-Install-xmake"><a href="#4-Install-xmake" class="headerlink" title="4. Install xmake"></a>4. Install xmake</h4><ul>
<li><strong>Windows</strong>:<ul>
<li>Download the installer from the <a target="_blank" rel="noopener" href="https://xmake.io/#/guide/installation">xmake website</a> and run it.</li>
</ul>
</li>
<li><strong>macOS</strong>:<ul>
<li>Install via Homebrew:<pre><code class="bash">brew install xmake
</code></pre>
</li>
</ul>
</li>
<li><strong>Linux</strong>:<ul>
<li>Use the installation script:<pre><code class="bash">curl -fsSL https://xmake.io/shget.text | bash
</code></pre>
</li>
</ul>
</li>
</ul>
<h4 id="5-Configure-VSCode-Extensions"><a href="#5-Configure-VSCode-Extensions" class="headerlink" title="5. Configure VSCode Extensions"></a>5. Configure VSCode Extensions</h4><p>Open VSCode and install the following extensions:</p>
<ul>
<li><strong>C&#x2F;C++</strong> (by Microsoft): Provides basic language support.</li>
<li><strong>clangd</strong>:<ul>
<li>Install the <strong>clangd</strong> extension for enhanced code completion and linting.</li>
</ul>
</li>
<li><strong>xmake</strong>:<ul>
<li>Install the <strong>xmake</strong> extension to integrate xmake into VSCode.</li>
</ul>
</li>
</ul>
<h4 id="6-Configure-clangd-in-VSCode"><a href="#6-Configure-clangd-in-VSCode" class="headerlink" title="6. Configure clangd in VSCode"></a>6. Configure clangd in VSCode</h4><ul>
<li>Go to <strong>File</strong> &gt; <strong>Preferences</strong> &gt; <strong>Settings</strong>.</li>
<li>Search for <code>clangd</code> and set the path if it’s not automatically detected.</li>
</ul>
<h2 id="Your-First-Program-Hello-World"><a href="#Your-First-Program-Hello-World" class="headerlink" title="Your First Program: Hello, World!"></a>Your First Program: Hello, World!</h2><p>Let’s create a simple “Hello, World!” program using <code>xmake</code>.</p>
<h3 id="Step-1-Create-a-New-Project"><a href="#Step-1-Create-a-New-Project" class="headerlink" title="Step 1: Create a New Project"></a>Step 1: Create a New Project</h3><p>Open a terminal and run:</p>
<pre><code class="bash">xmake create -l c++ -t console hello
</code></pre>
<p>Explanation:</p>
<ul>
<li><code>-l c++</code>: Specifies the language as C++.</li>
<li><code>-t console</code>: Creates a console application template.</li>
<li><code>hello</code>: Names the project directory as <code>hello</code>.</li>
</ul>
<h3 id="Step-2-Navigate-to-the-Project-Directory"><a href="#Step-2-Navigate-to-the-Project-Directory" class="headerlink" title="Step 2: Navigate to the Project Directory"></a>Step 2: Navigate to the Project Directory</h3><pre><code class="bash">cd hello
</code></pre>
<h3 id="Step-3-Explore-the-Project-Structure"><a href="#Step-3-Explore-the-Project-Structure" class="headerlink" title="Step 3: Explore the Project Structure"></a>Step 3: Explore the Project Structure</h3><p>Your project should have the following structure:</p>
<pre><code>hello/
├── src/
│   └── main.cpp
└── xmake.lua
</code></pre>
<ul>
<li><code>src/main.cpp</code>: Contains the source code.</li>
<li><code>xmake.lua</code>: The build configuration file.</li>
</ul>
<h3 id="Step-4-Open-the-Project-in-VSCode"><a href="#Step-4-Open-the-Project-in-VSCode" class="headerlink" title="Step 4: Open the Project in VSCode"></a>Step 4: Open the Project in VSCode</h3><ul>
<li>Open VSCode.</li>
<li>Click on <strong>File</strong> &gt; <strong>Open Folder…</strong> and select the <code>hello</code> directory.</li>
</ul>
<h3 id="Step-5-Build-the-Project"><a href="#Step-5-Build-the-Project" class="headerlink" title="Step 5: Build the Project"></a>Step 5: Build the Project</h3><p>In VSCode:</p>
<ul>
<li>Open the integrated terminal (<strong>View</strong> &gt; <strong>Terminal</strong>).</li>
<li>Build the project by running:<pre><code class="bash">xmake
</code></pre>
</li>
</ul>
<h3 id="Step-6-Run-the-Program"><a href="#Step-6-Run-the-Program" class="headerlink" title="Step 6: Run the Program"></a>Step 6: Run the Program</h3><p>Execute the program with:</p>
<pre><code class="bash">xmake run
</code></pre>
<p>You should see the output:</p>
<pre><code>hello world!
</code></pre>
<h2 id="Variables-and-Data-Types"><a href="#Variables-and-Data-Types" class="headerlink" title="Variables and Data Types"></a>Variables and Data Types</h2><p>Variables store data that can be used and manipulated within your program. Each variable in C++ has a specific data type that determines the kind of values it can hold.</p>
<h3 id="Basic-Data-Types"><a href="#Basic-Data-Types" class="headerlink" title="Basic Data Types"></a>Basic Data Types</h3><ul>
<li><strong>Integer Types</strong>:<ul>
<li><code>int</code>: Standard integer.</li>
<li><code>short</code>, <code>long</code>, <code>long long</code>: Variations for different sizes.</li>
</ul>
</li>
<li><strong>Floating-Point Types</strong>:<ul>
<li><code>float</code>: Single-precision floating-point number.</li>
<li><code>double</code>: Double-precision floating-point number.</li>
</ul>
</li>
<li><strong>Character Type</strong>:<ul>
<li><code>char</code>: Represents a single character.</li>
</ul>
</li>
<li><strong>Boolean Type</strong>:<ul>
<li><code>bool</code>: Represents <code>true</code> or <code>false</code>.</li>
</ul>
</li>
<li><strong>String Type</strong>:<ul>
<li><code>std::string</code>: Represents a sequence of characters (requires including <code>&lt;string&gt;</code>).</li>
</ul>
</li>
</ul>
<h3 id="Declaring-and-Initializing-Variables"><a href="#Declaring-and-Initializing-Variables" class="headerlink" title="Declaring and Initializing Variables"></a>Declaring and Initializing Variables</h3><p>You can declare a variable by specifying its type followed by its name:</p>
<pre><code class="cpp">int age;
float salary;
char grade;
bool isEmployed;
</code></pre>
<p>You can also initialize variables at the time of declaration:</p>
<pre><code class="cpp">int age = 30;
float salary = 75000.50;
char grade = &#39;A&#39;;
bool isEmployed = true;
std::string name = &quot;Alice&quot;;
</code></pre>
<h3 id="Using-Variables-in-Code"><a href="#Using-Variables-in-Code" class="headerlink" title="Using Variables in Code"></a>Using Variables in Code</h3><p>Let’s modify our program to include variables and data types.</p>
<h4 id="Step-1-Update-main-cpp"><a href="#Step-1-Update-main-cpp" class="headerlink" title="Step 1: Update main.cpp"></a>Step 1: Update <code>main.cpp</code></h4><p>Open <code>src/main.cpp</code> and replace its contents with:</p>
<pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;string&gt;

int main() &#123;
    // Declare and initialize variables
    std::string name = &quot;Alice&quot;;
    int age = 30;
    float height = 1.65f; // Height in meters
    char grade = &#39;A&#39;;
    bool isEmployed = true;

    // Output the variables to the console
    std::cout &lt;&lt; &quot;Name: &quot; &lt;&lt; name &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;Age: &quot; &lt;&lt; age &lt;&lt; &quot; years old&quot; &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;Height: &quot; &lt;&lt; height &lt;&lt; &quot; meters&quot; &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;Grade: &quot; &lt;&lt; grade &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;Employed: &quot; &lt;&lt; std::boolalpha &lt;&lt; isEmployed &lt;&lt; std::endl;

    return 0;
&#125;
</code></pre>
<h4 id="Step-2-Build-and-Run-the-Program"><a href="#Step-2-Build-and-Run-the-Program" class="headerlink" title="Step 2: Build and Run the Program"></a>Step 2: Build and Run the Program</h4><p>In the terminal, build the project:</p>
<pre><code class="bash">xmake
</code></pre>
<p>Run the program:</p>
<pre><code class="bash">xmake run
</code></pre>
<h4 id="Expected-Output"><a href="#Expected-Output" class="headerlink" title="Expected Output"></a>Expected Output</h4><pre><code>Name: Alice
Age: 30 years old
Height: 1.65 meters
Grade: A
Employed: true
</code></pre>
<h3 id="Explanation"><a href="#Explanation" class="headerlink" title="Explanation"></a>Explanation</h3><ul>
<li><strong>Headers Included</strong>:<ul>
<li><code>#include &lt;iostream&gt;</code>: Allows for input and output streams.</li>
<li><code>#include &lt;string&gt;</code>: Enables the use of <code>std::string</code>.</li>
</ul>
</li>
<li><strong>Variables</strong>:<ul>
<li><code>std::string name</code>: Stores text strings.</li>
<li><code>int age</code>: Stores integer numbers.</li>
<li><code>float height</code>: Stores floating-point numbers (note the <code>f</code> suffix for floats).</li>
<li><code>char grade</code>: Stores single characters.</li>
<li><code>bool isEmployed</code>: Stores boolean values (<code>true</code> or <code>false</code>).</li>
</ul>
</li>
<li><strong><code>std::cout</code> Statements</strong>:<ul>
<li>Used to output text and variable values to the console.</li>
<li><code>std::boolalpha</code>: Formats boolean output as <code>true</code> or <code>false</code> instead of <code>1</code> or <code>0</code>.</li>
</ul>
</li>
</ul>
<h2 id="Comments-in-C"><a href="#Comments-in-C" class="headerlink" title="Comments in C++"></a>Comments in C++</h2><p>Comments are lines in your code that are ignored by the compiler. They are used to explain code logic, provide context, or leave notes for yourself and other developers. Good commenting practices enhance code readability and maintainability.</p>
<h3 id="Types-of-Comments"><a href="#Types-of-Comments" class="headerlink" title="Types of Comments"></a>Types of Comments</h3><p>C++ supports two types of comments:</p>
<ol>
<li><strong>Single-line comments</strong>: Start with <code>//</code> and continue to the end of the line.</li>
<li><strong>Multi-line comments</strong>: Enclosed between <code>/*</code> and <code>*/</code>, can span multiple lines.</li>
</ol>
<h4 id="Single-line-Comments"><a href="#Single-line-Comments" class="headerlink" title="Single-line Comments"></a>Single-line Comments</h4><p>Single-line comments are useful for brief explanations or notes.</p>
<p><strong>Example:</strong></p>
<pre><code class="cpp">int main() &#123;
    // Output a greeting message
    std::cout &lt;&lt; &quot;Hello, World!&quot; &lt;&lt; std::endl; // End of line comment
    return 0;
&#125;
</code></pre>
<h4 id="Multi-line-Comments"><a href="#Multi-line-Comments" class="headerlink" title="Multi-line Comments"></a>Multi-line Comments</h4><p>Multi-line comments are useful for longer explanations or commenting out blocks of code.</p>
<p><strong>Example:</strong></p>
<pre><code class="cpp">/*
    This program demonstrates the use of variables and data types.
    Author: Your Name
    Date: Today&#39;s Date
*/
int main() &#123;
    // Code goes here
&#125;
</code></pre>
<h3 id="Using-Comments-Effectively"><a href="#Using-Comments-Effectively" class="headerlink" title="Using Comments Effectively"></a>Using Comments Effectively</h3><ul>
<li><p><strong>Explain the Why, Not the What</strong>: Comments should provide insight into why certain decisions were made, not just describe what the code is doing.</p>
<p><strong>Ineffective Comment:</strong></p>
<pre><code class="cpp">int x = 5; // Assign 5 to x
</code></pre>
<p><strong>Effective Comment:</strong></p>
<pre><code class="cpp">int maxRetries = 5; // Maximum number of retry attempts before aborting
</code></pre>
</li>
<li><p><strong>Keep Comments Up-to-Date</strong>: Always update comments when modifying code to prevent misinformation.</p>
</li>
<li><p><strong>Avoid Obvious Comments</strong>: Do not state the obvious, as it can clutter the code.</p>
<p><strong>Obvious:</strong></p>
<pre><code class="cpp">i++; // Increment i by 1
</code></pre>
</li>
<li><p><strong>Use Comments for Complex Logic</strong>: When dealing with complex algorithms or tricky parts of the code, comments can clarify intent.</p>
<p><strong>Example:</strong></p>
<pre><code class="cpp">// Use binary search to find the target value in a sorted array
</code></pre>
</li>
</ul>
<h3 id="Commenting-Out-Code"><a href="#Commenting-Out-Code" class="headerlink" title="Commenting Out Code"></a>Commenting Out Code</h3><p>During debugging or testing, you might want to disable certain parts of your code.</p>
<p><strong>Example:</strong></p>
<pre><code class="cpp">int main() &#123;
    std::cout &lt;&lt; &quot;This line will execute.&quot; &lt;&lt; std::endl;

    // Temporarily disable the following line
    // std::cout &lt;&lt; &quot;This line is commented out and won&#39;t execute.&quot; &lt;&lt; std::endl;

    return 0;
&#125;
</code></pre>
<h3 id="Practical-Example-with-Comments"><a href="#Practical-Example-with-Comments" class="headerlink" title="Practical Example with Comments"></a>Practical Example with Comments</h3><p>Let’s revisit our previous program and add comments to enhance understanding.</p>
<pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;string&gt;

/*
    This program demonstrates variables, data types, and comments in C++.
*/

int main() &#123;
    // Declare and initialize variables
    std::string name = &quot;Alice&quot;;    // User&#39;s name
    int age = 30;                  // User&#39;s age
    float height = 1.65f;          // User&#39;s height in meters
    char grade = &#39;A&#39;;              // User&#39;s grade
    bool isEmployed = true;        // Employment status

    // Output the variables to the console
    std::cout &lt;&lt; &quot;Name: &quot; &lt;&lt; name &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;Age: &quot; &lt;&lt; age &lt;&lt; &quot; years old&quot; &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;Height: &quot; &lt;&lt; height &lt;&lt; &quot; meters&quot; &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;Grade: &quot; &lt;&lt; grade &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;Employed: &quot; &lt;&lt; std::boolalpha &lt;&lt; isEmployed &lt;&lt; std::endl;

    return 0;
&#125;
</code></pre>
<h3 id="Generating-Documentation-from-Comments"><a href="#Generating-Documentation-from-Comments" class="headerlink" title="Generating Documentation from Comments"></a>Generating Documentation from Comments</h3><p>For larger projects, consider using tools like <strong>Doxygen</strong> to generate documentation from specially formatted comments.</p>
<p><strong>Doxygen Comment Example:</strong></p>
<pre><code class="cpp">/**
 * @brief Calculates the factorial of a number.
 * 
 * @param n The number to calculate the factorial for.
 * @return The factorial of n.
 */
int factorial(int n) &#123;
    // Implementation
&#125;
</code></pre>
<h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><p>In this chapter, you’ve:</p>
<ul>
<li>Set up your development environment with VSCode, the appropriate compiler, <code>clangd</code>, and <code>xmake</code>.</li>
<li>Created and ran your first C++ program using <code>xmake</code>.</li>
<li>Learned about variables and data types in C++, including how to declare, initialize, and use them.</li>
<li>Explored how to use comments in C++ to document and annotate your code effectively.</li>
</ul>
<p>Understanding how to use comments properly is crucial for writing clear, maintainable code. As you continue your programming journey, good commenting habits will aid in collaboration and make revisiting your code much easier.</p>
<hr>
<p>Now you’re ready to move on to <strong>Control Structures</strong>, where you’ll learn how to make decisions and control the flow of your programs.</p>
<p>Next chapter: <a href="/2024/09/26/cpp-unleash/02h-ctrlstruct">Control Structures</a></p>

            
        </div>
    </div>
    <div class="post-tags">
        
        <span class="icon">
            <i class="fa-solid fa-tags fa-fw"></i>
        </span>
        
        
        
        <span class="tag">
            
            <a href="/tags/c-cpp/" style="color: #ff7d73">c-cpp</a>
        </span>
        
        <span class="tag">
            
            <a href="/tags/modern-cpp/" style="color: #00a596">modern-cpp</a>
        </span>
        
        <span class="tag">
            
            <a href="/tags/cpp-unleash/" style="color: #03a9f4">cpp-unleash</a>
        </span>
        
        <span class="tag">
            
            <a href="/tags/02Hero/" style="color: #00a596">02Hero</a>
        </span>
        
    </div>
    <a href="/2024/09/26/cpp-unleash/02h-getstart/" class="go-post">阅读全文</a>
</div>


        <div class="page-current">
    
    <a class="page-num" href="/">
        <i class="fa-solid fa-caret-left fa-fw"></i>
    </a>
    <a class="page-num" href="/">1</a>
    <span class="page-omit">...</span>
    
    <span class="current">2</span>
    
    <a class="page-num" href="/page/3">
        3
    </a>
    
    
    
    
    <a class="page-num" href="/page/3/">
        <i class="fa-solid fa-caret-right fa-fw"></i>
    </a>
    
</div>

    </div>
    
    <div id="home-card">
        <div id="card-style">
    <div id="card-div">
        <div class="avatar">
            <img src="/images/avatar1.png" alt="avatar" />
        </div>
        <div class="name">Tab Nahida</div>
        <div class="description">
            <p>Estas Tab-klavo ĉi tie</p>

        </div>
        
        <div class="icon-links">
            
            <span class="icon-link">
                <a target="_blank" rel="noopener" href="https://github.com/TabNahida">
                    <i
                        class="fa-brands fa-github fa-fw"
                    ></i>
                </a>
            </span>
            
            <span class="icon-link">
                <a href="mailto:tab@tabye.top">
                    <i
                        class="fa-solid fa-envelope fa-fw"
                    ></i>
                </a>
            </span>
            
            <span class="icon-link">
                <a target="_blank" rel="noopener" href="https://wpa.qq.com/msgrd?v=3&uin=1517725261&site=qq&menu=yes">
                    <i
                        class="fa-brands fa-qq fa-fw"
                    ></i>
                </a>
            </span>
            
        </div>
        
        
        <div class="friend-links">
            
            <div class="friend-link">
                <a target="_blank" rel="noopener" href="https://argvchs.github.io">Argvchs</a>
            </div>
            
        </div>
        
    </div>
</div>

    </div>
    
</div>

            <footer id="footer">
    <div id="footer-wrap">
        <div>
            &copy;
            2024 - 2024 Tab&#39;s Blog
            <span id="footer-icon">
                <i class="fa-solid fa-font-awesome fa-fw"></i>
            </span>
            &commat;Tab Nahida
        </div>
        <div>
            Based on the <a target="_blank" rel="noopener" href="https://hexo.io">Hexo Engine</a> &amp;
            <a target="_blank" rel="noopener" href="https://github.com/theme-particlex/hexo-theme-particlex">ParticleX Theme</a>
        </div>
        
    </div>
</footer>

        </div>
        
        <transition name="fade">
            <div id="preview" ref="preview" v-show="previewShow">
                <img id="preview-content" ref="previewContent" />
            </div>
        </transition>
        
    </div>
    <script src="/js/main.js"></script>
    
</body>
</html>
